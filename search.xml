<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 897 Increasing Order Search Tree]]></title>
    <url>%2Fleetcode-897%2F</url>
    <content type="text"><![CDATA[题意给定一颗二叉搜索树，重新进行排序，使其根节点是最小值，且每个节点都没有左子树，只有一个右子树，最终还要保持该树是一颗二叉搜索树. 123456789101112131415161718192021222324252627282930例 1:给予树: 5 / \ 3 6 / \ \ 2 4 8 / / \ 1 7 9输出: 1 \ 2 \ 3 \ 4 \ 5 \ 6 \ 7 \ 8 \ 9 解法使用中序遍历即可。 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private TreeNode result = new TreeNode(0); private TreeNode dummy = result; public TreeNode increasingBST(TreeNode root) &#123; if (root == null) &#123; return null; &#125; increasingBST(root.left); dummy.right = new TreeNode(root.val); dummy = dummy.right; increasingBST(root.right); return result.right; &#125;&#125; Runtime: 2 ms, faster than 99.97% of Java online submissions for Increasing Order Search Tree. Memory Usage: 44.9 MB, less than 59.39% of Java online submissions for Increasing Order Search Tree.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
        <tag>二叉搜索树</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 590 N-ary Tree Postorder Traversal]]></title>
    <url>%2Fleetcode-590%2F</url>
    <content type="text"><![CDATA[题意给定一颗 N 叉树 的根节点，返回后序遍历后的数组. 例 : 1234567给予树： 1 / | \ 3 2 4 / \ 5 6 将其后序遍历返回: [5,6,3,2,4,1]. 解法和二叉树的中序遍历差不多，需要注意处理好子节点的顺序即可。 非递归解法： 1234567891011121314151617181920212223242526272829303132333435363738394041/*// Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123; public List&lt;Integer&gt; postorder(Node root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node node = stack.peek(); List&lt;Node&gt; children = node.children; if (children != null &amp;&amp; children.size() != 0) &#123; for (int i = children.size() - 1; i &gt;= 0; i--) &#123; stack.add(children.get(i)); &#125; &#125; else &#123; list.add(stack.pop().val); &#125; node.children = new ArrayList&lt;&gt;(); &#125; return list; &#125;&#125; 递归解法： 1234567891011121314151617181920212223242526272829303132/*// Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; postorder(Node root) &#123; if (root == null) &#123; return list; &#125; for (Node child : root.children) &#123; postorder(child); &#125; list.add(root.val); return list; &#125;&#125; Runtime: 1 ms, faster than 100.00% of Java online submissions for N-ary Tree Postorder Traversal.Memory Usage: 48.2 MB, less than 40.66% of Java online submissions for N-ary Tree Postorder Traversal.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>N叉树</tag>
        <tag>后序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 559 Maximum Depth of N-ary Tree]]></title>
    <url>%2Fleetcode-559%2F</url>
    <content type="text"><![CDATA[题意给定一颗 N 叉树 的根节点，返回树的深度. 例 : 1234567给予树： 1 / | \ 3 2 4 / \ 5 6 返回深度 3. 解法采用 DFS (深度优先算法)，代码比较简单，不再赘言。 12345678910111213141516171819202122232425/*// Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123; public int maxDepth(Node root) &#123; int depth = 1; if (root == null) return 0; for (Node n : root.children)&#123; depth = Math.max(depth, maxDepth(n) + 1); &#125; return depth; &#125;&#125; Runtime: 1 ms, faster than 99.56% of Java online submissions for Maximum Depth of N-ary Tree.Memory Usage: 49.8 MB, less than 5.41% of Java online submissions for Maximum Depth of N-ary Tree.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>N叉树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 589 N-ary Tree Preorder Traversal]]></title>
    <url>%2Fleetcode-589%2F</url>
    <content type="text"><![CDATA[题意给定一颗 N 叉树 的根节点，返回前序遍历后的数组. 例 : 1234567给予树： 1 / | \ 3 2 4 / \ 5 6 将其前序遍历返回: [1,3,5,6,2,4]. 解法和二叉树的前序遍历差不多，需要注意处理好子节点的顺序即可。 非递归解法： 12345678910111213141516171819202122232425262728293031323334/*// Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123; public List&lt;Integer&gt; preorder(Node root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.add(root); while (!stack.isEmpty()) &#123; root = stack.pop(); list.add(root.val); for (int i = root.children.size() - 1; i &gt;= 0; i--) &#123; stack.add(root.children.get(i)); &#125; &#125; return list; &#125;&#125; 递归解法： 12345678910111213141516171819202122232425262728293031/*// Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorder(Node root) &#123; if (root == null) &#123; return list; &#125; list.add(root.val); for (Node child : root.children) &#123; preorder(child); &#125; return list; &#125;&#125; Runtime: 1 ms, faster than 100.00% of Java online submissions for N-ary Tree Preorder Traversal. Memory Usage: 47.9 MB, less than 51.19% of Java online submissions for N-ary Tree Preorder Traversal.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>N叉树</tag>
        <tag>前序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 965 Univalued Binary Tree]]></title>
    <url>%2Fleetcode-965%2F</url>
    <content type="text"><![CDATA[题意 判断二叉树是否是 唯一二叉树. 当树中所有节点的值都一样时，我们认为他是一颗 唯一二叉树。 1234567给予一棵树: 1 / \ 1 1 / \ 1 1应当返回 `true` 1234567给予一棵树: 1 / \ 1 1 / \ 5 1应当返回 `false` 解法这道题其实只是考一下对二叉树的遍历，我比较习惯用栈来实现，而不是递归，所以有以下代码： 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isUnivalTree(TreeNode root) &#123; int i = root.val; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); if (node.val != i) &#123; return false; &#125; if (node.left != null) &#123; stack.push(node.left); &#125; if (node.right != null) &#123; stack.push(node.right); &#125; &#125; return true; &#125;&#125; Runtime: 1 ms, faster than 83.52% of Java online submissions for Univalued Binary Tree. Memory Usage: 35.9 MB, less than 92.59% of Java online submissions for Univalued Binary Tree.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 700 Search in a Binary Search Tree]]></title>
    <url>%2Fleetcode-700%2F</url>
    <content type="text"><![CDATA[题意 给定一颗 二叉搜索树 的根节点，和一个要插入的值，将值插入进去，并返回根节点 保证原树中不存在新值 只要保证返回的树同样也是 二叉搜索树 即可 例:123456给予一棵树: 4 / \ 2 7 / \ 1 3 对于搜索值: 2, 你应该返回以下子树:123 2 / \ 1 3 解法因为是二叉搜索树, 所以根据二叉搜索树的规则遍历即可. 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; while (root != null) &#123; if (root.val &lt; val) &#123; root = root.right; &#125; else if (root.val &gt; val) &#123; root = root.left; &#125; else &#123; return root; &#125; &#125; return root; &#125;&#125; Runtime: 0 ms, faster than 100.00% of Java online submissions for Search in a Binary Search Tree. Memory Usage: 40.4 MB, less than 17.60% of Java online submissions for Search in a Binary Search Tree.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 344 Merge Two Binary Trees]]></title>
    <url>%2Fleetcode-617%2F</url>
    <content type="text"><![CDATA[题意合并两颗二叉树, 合并规则是相同位置的值进行相加, 返回生成后二叉树的根节点. 例 : 12345678910111213输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 3 / \ 4 5 / \ \ 5 4 7 解法基本思路是将两棵树, 合并到左树上, 基本规则是只有当 tree1 和 tree2 相同位置的节点都不为空时, 才能进行相加操作, 当 tree1 为空时, 把 tree2 的节点嫁接过来, 当 tree2 为空时, 保留 tree1 即可. 以此类推, 把每个节点都看成根节点即可. 1234567891011121314class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if (t1 == null) &#123; return t2; &#125; else if (t2 == null) &#123; return t1; &#125; t1.val += t2.val; t1.left = mergeTrees(t1.left, t2.left); t1.right = mergeTrees(t1.right, t2.right); return t1; &#125;&#125; Runtime: 0 ms, faster than 100.00% of Java online submissions for Merge Two Binary Trees.Memory Usage: 41.2 MB, less than 78.32% of Java online submissions for Merge Two Binary Trees.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 动态代理初探]]></title>
    <url>%2Fjava-dynamic-proxy%2F</url>
    <content type="text"><![CDATA[前言对于使用过 Spring 的朋友, 应该都使用过 AOP, 那么今天我们来对 AOP 的原理: 动态代理 来一探究竟. 静态代理在动态代理之前, 我们先来看看静态代理, 看下其实现方式及其优缺点. 静态代理的原理是委托类和代理类都实现同一个接口, 代理类中会调用委托类的方法, 同时代理类中可以加一些自己的逻辑. 公共接口123public interface IService &#123; public void sayHello();&#125; 委托类123456public class RealService implements IService &#123; @Override public void sayHello() &#123; System.out.println("hello"); &#125;&#125; 代理类123456789101112131415public class ProxyService implements IService &#123; private IService iService; public ProxyService(IService iService) &#123; this.iService = iService; &#125; @Override public void sayHello() &#123; System.out.println("before..."); iService.sayHello(); System.out.println("after..."); &#125;&#125; 测试12345678public class Main &#123; public static void main(String[] args) &#123; IService realService = new RealService(); IService proxyService = new ProxyService(realService); proxyService.sayHello(); &#125;&#125; 输出: before... hello after... 可以看到委托类和代理类都实现了同一个接口, 然后代理类在初始化时, 传入委托类对象, 然后在代理类自己的 sayHello() 方法中, 即调用了委托类的 sayHello() 方法, 还加了自己的逻辑, 输出了 before 和 after.但这种方式有着明显的缺点: 必须要继承一个接口 必须要手工创建对应的代理类 硬编码, 当接口需要改动或代理类较多时不宜维护. 动态代理JDK 动态代理公共接口123public interface IService &#123; public void sayHello();&#125; 委托类123456public class RealService implements IService &#123; @Override public void sayHello() &#123; System.out.println("hello"); &#125;&#125; 代理类12345678910111213141516171819import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class SimpleInvocationHandler implements InvocationHandler &#123; private Object realObject; public SimpleInvocationHandler(Object realObject) &#123; this.realObject = realObject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("before " + method.getName()); Object result = method.invoke(realObject, args); System.out.println("leaving " + method.getName()); return result; &#125;&#125; 测试1234567891011121314151617import java.lang.reflect.Proxy;public class Main &#123; public static void main(String[] args) &#123; // 保存生成的代理类的字节码文件 System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true"); IService realService = new RealService(); IService proxyService = (IService) Proxy.newProxyInstance( IService.class.getClassLoader(), new Class&lt;?&gt;[]&#123;IService.class&#125;, new SimpleInvocationHandler(realService)); proxyService.sayHello(); &#125;&#125; 代码看起来好像更复杂了一些, 我们可以看到 IService 和 RealService 的定义不变, 但创建代理类的方式变化了, 它使用 java.lang.reflect.Proxy 的静态方法 newProxyInstance 来创建代理类. 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 它有三个参数: loader 表示类加载器. interfaces 表示代理类要实现的接口列表, 元素的类型只能是接口. h 就是上面我们定义的 SimpleInvocationHandler 它实现了 InvocationHandler 接口, 并复写了 invoke 方法, 对代理接口的所有方法调用都会转到此方法上. newProxyInstance 的返回值是 Object, 可以强制转化为 interfaces 数组中的任意接口类型, 但不能转化为某个普通类型, 如 RealService. 即使它代理的实际对象是 RealService. 接着我们在来看看 SimpleInvocationHandler, 它实现了 InvocationHandler 接口, 它通过构造方法传入被代理对象 realObject. 复写的 invoke 方法有三个参数: proxy 表示代理对象本身, 需要注意, 它不是被代理的对象. method 表示正在被调用的方法 args 表示方法的参数 需要注意这句代码:123456789101112Object result = method.invoke(realObject, args);``千万不能把 proxy 当成 method.invoke 的第一个参数. 这样会造成死循环, 因为这样表示代理类代理了它自身.#### 原理解析刚才的测试类中, 我们有一段代码, 它用来保存生成后的代理类的 class 文件: ```javaSystem.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true") 我们来反编译看下, 它为我们动态生成的代理类:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.sun.proxy;import im.zhaojun.jdk_proxy.IService;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements IService &#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public $Proxy0(InvocationHandler var1) &#123; super(var1); &#125; public final boolean equals(Object var1) &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void sayHello() &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final String toString() &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object")); m3 = Class.forName("im.zhaojun.jdk_proxy.IService").getMethod("sayHello"); m2 = Class.forName("java.lang.Object").getMethod("toString"); m0 = Class.forName("java.lang.Object").getMethod("hashCode"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 可以看到, 其实也就是生成了一个类, 实现了我们传入的接口, 它所有方法都是调用的 SimpleInvocationHandler 的 invoke 方法. 相比于静态代理, 这里的动态代理看起来麻烦了不少, 但它却更加通用. 我们不用为每个被代理的类都创建一个静态代理类, 而是当代理类要做的功能不变时, 只需要有这一个代理类即可. 说起来可能有些不好理解, 看代码吧: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class GeneralProxyDemo &#123; static interface IServiceA &#123; public void sayHello(); &#125; static class ServiceAImpl implements IServiceA &#123; @Override public void sayHello() &#123; System.out.println("hello"); &#125; &#125; static interface IServiceB &#123; public void fly(); &#125; static class ServiceBImpl implements IServiceB &#123; @Override public void fly() &#123; System.out.println("flying"); &#125; &#125; static class SimpleInvocationHandler implements InvocationHandler &#123; private Object realObj; public SimpleInvocationHandler(Object realObj) &#123; this.realObj = realObj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("entering " + realObj.getClass().getSimpleName() + "::" + method.getName()); Object result = method.invoke(realObj, args); System.out.println("leaving " + realObj.getClass().getSimpleName() + "::" + method.getName()); return result; &#125; &#125; @SuppressWarnings("unchecked") private static &lt;T&gt; T getProxy(Class&lt;T&gt; intf, T realObj) &#123; return (T) Proxy.newProxyInstance(intf.getClassLoader(), new Class&lt;?&gt;[] &#123; intf &#125;, new SimpleInvocationHandler(realObj)); &#125; public static void main(String[] args) throws Exception &#123; IServiceA a = new ServiceAImpl(); IServiceA aProxy = getProxy(IServiceA.class, a); aProxy.sayHello(); IServiceB b = new ServiceBImpl(); IServiceB bProxy = getProxy(IServiceB.class, b); bProxy.fly(); &#125;&#125; 在这里有两个接口 ServiceA 和 ServiceB, 他们对应的实现类为 ServiceAImpl 和 ServiceBImpl. 虽然他们的接口和实现类完全不同, 但通过动态代理. 他们都可以使用 SimpleInvocationHandler 中 invoke 中的代理逻辑. CGLIB 动态代理上面讲到的 JDK 动态代理, 有一定的局限性, 那就是只能为接口创建代理, 返回的对象也只能是接口类型的, 如果一个类没有接口, 或者想代理非接口中定义的方法, JDK 动态代理就无法实现了. 这里就要用到 CGLIB 动态代理了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class SimpleCGLibDemo &#123; /** * 被代理类. */ static class RealService &#123; public void sayHello() &#123; System.out.println("hello"); &#125; &#125; /** * 方法拦截器. */ static class SimpleInterceptor implements MethodInterceptor &#123; @Override public Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println("entering " + method.getName()); Object result = proxy.invokeSuper(object, args); System.out.println("leaving " + method.getName()); return result; &#125; &#125; private static &lt;T&gt; T getProxy(Class&lt;T&gt; cls) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(cls); // 设置被代理类 enhancer.setCallback(new SimpleInterceptor()); // 设置方法拦截器 return (T) enhancer.create(); &#125; public static void main(String[] args) &#123; RealService proxyService = getProxy(RealService.class); proxyService.sayHello(); &#125;&#125; RealService 表示被代理的类, 它没有实现任何接口. getProxy() 方法为一个类生成代理对象, 这个代理对象可以转换为被代理类的类型, 它使用了 cglib 的 Enhancer 类, Enhancer 类的 setSuperclass 设置被代理的类, setCallback 设置被代理类的方法被调用时的处理类, Enhancer 支持多种类型, 这里使用的类实现了 MethodInterceptor 接口, 它与 JDK 动态代理中的 InvocationHandler 有点类似, 方法名称变成了intercept, 多了一个MethodProxy类型的参数. 与前面的 InvocationHandler 不同，SimpleInterceptor 中没有被代理的对象，它通过 MethodProxy 的 invokeSuper 方法调用被代理类的方法： 1Object result = proxy.invokeSuper(object, args); 注意，它不能这样调用被代理类的方法： 1Object result = method.invoke(object, args); object 是代理对象，不能自己代理自己，会造成死循环。 基本的使用就这些, 先消化下, 自己动手实现, 后续我会更新一些 JDK 更细节上的内容.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态代理</tag>
        <tag>cglib</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一款基于 Shiro 的权限管理系统，支持 restful 风格 URL.]]></title>
    <url>%2Fshiro-action%2F</url>
    <content type="text"><![CDATA[Shiro-Action本项目使用 Spring Boot 搭建, 用于加深对 Spring Boot 与 Shiro 的学习, 项目特色是支持 restful 风格权限控制, 支持对同一 URL, 不同 HTTP Mehtod 的权限控制, 适用于更多的场景. 预览地址: http://shiro.zhaojun.im/项目地址: https://github.com/zhaojun1998/Shiro-Action默认管理员账号: admin, 密码: 123456.普通用户账号: user, 密码: 123456. 为了不影响其他人的浏览体验, 请尽量不要进行删除类的敏感操作. admin 为超级管理员, 自动拥有全部权限. 运行环境 JDK 1.8 MySQL 5.7 Redis 快速开始下载项目1git clone https://github.com/zhaojun1998/Shiro-Action.git 导入项目使用自己的 IDE 导入, Eclipse 和 Intellij IDEA 均可. 导入数据库创建数据库, 字符集选择 utf8, 排序规则选择 utf8_general_ci. 然后导入 shiro_action.sql 到数据库中. 配置文件打开 application.properties 修改 MySQL 和 Redis 连接信息. 1234567spring.redis.host=127.0.0.1spring.redis.port=6379spring.cache.type=redisspring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://127.0.0.1:3306/shiro_action?useSSL=false&amp;characterEncoding=UTF8 启动项目在完成了上述步骤后，找到 ShiroActionApplication 启动类, 启动即可. 启动后访问地址为：http://localhost:8080，用户名：zhaojun，密码：123456. 系统预览]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1008 Construct Binary Search Tree from Preorder Traversal]]></title>
    <url>%2Fleetcode-1008%2F</url>
    <content type="text"><![CDATA[题意 给定一个前序遍历的数组，还原 二叉搜索树。 数组中不存在重复值 例 : 1234567输入：[8,5,1,7,10,12] 输出： 8 / \ 5 10 / \ \ 1 7 12 解法 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode bstFromPreorder(int[] preorder) &#123; if (preorder.length == 0) &#123; return null; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode root = new TreeNode(preorder[0]); stack.push(root); for (int i = 1; i &lt; preorder.length; i++) &#123; TreeNode temp = stack.peek(); int n = preorder[i]; if (n &lt; temp.val) &#123; temp.left = new TreeNode(n); stack.push(temp.left); &#125; else &#123; TreeNode prev = stack.pop(); while (!stack.isEmpty() &amp;&amp; stack.peek().val &lt; n) &#123; prev = stack.pop(); &#125; prev.right = new TreeNode(n); stack.push(prev.right); &#125; &#125; return root; &#125;&#125; 时间复杂度 O(n)，空间复杂度 O(n)。 Runtime: 1 ms, faster than 82.12% of Java online submissions for Construct Binary Search Tree from Preorder Traversal. Memory Usage: 36.8 MB, less than 100.00% of Java online submissions for Construct Binary Search Tree from Preorder Traversal.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 701 Insert into a Binary Search Tree]]></title>
    <url>%2Fleetcode-701%2F</url>
    <content type="text"><![CDATA[题意 给定一颗 二叉搜索树 的根节点，和一个要插入的值，将值插入进去，并返回根节点 保证原树中不存在新值 只要保证返回的树同样也是 二叉搜索树 即可 例 : 1234567给予树： 4 / \ 2 7 / \ 1 3 并且要插入的值：5 您可以返回此 二叉搜索树： 12345 4 / \ 2 7 / \ /1 3 5 这棵树也有效： 1234567 5 / \ 2 7 / \ 1 3 \ 4 解法因为是二叉搜索树，所以依次判断新值与每个节点的大小即可，大于当前节点，则判断此节点的右节点与新节点。小于当前节点，则判断此节点的左节点与新节点，直到子节点为空，那么再根据此节点的大小选择放到左侧还是右侧。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null) &#123; throw new IllegalArgumentException("Tree Root can not be empty"); &#125; TreeNode current = root; TreeNode preNode = null; while (current != null) &#123; preNode = current; if (current.val &lt; val) &#123; current = current.right; &#125; else if (current.val &gt; val)&#123; current = current.left; &#125; &#125; if (preNode.val &lt; val) &#123; System.out.println("1"); preNode.right = new TreeNode(val); &#125; else &#123; System.out.println("2"); preNode.left = new TreeNode(val); &#125; return root; &#125;&#125; Runtime: 1 ms, faster than 100.00% of Java online submissions for Insert into a Binary Search Tree. Memory Usage: 39.8 MB, less than 94.61% of Java online submissions for Insert into a Binary Search Tree.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 654 Maximum Binary Tree]]></title>
    <url>%2Fleetcode-654%2F</url>
    <content type="text"><![CDATA[题意 给定一个整数数组，生成一棵 最大二叉树，规则是数组中的最大值为根节点，然后分割出最大值左侧的子数组再构造 最大二叉树，最大值的右侧也构造成 最大二叉树。 例 : 12345678910输入: [3,2,1,6,0,5]输出: 返回表示以下树的根节点: 6 / \ 3 5 \ / 2 0 \ 1 解法根据题意，是经典的分而治之的题目，用递归就可以很简单的实现： 1234567891011121314151617181920public TreeNode constructMaximumBinaryTree(int[] nums) &#123; int len = nums.length; if (len == 0) &#123; return null; &#125; int max = Integer.MIN_VALUE; int maxIndex = -1; for (int i = 0; i &lt; len; i++) &#123; int num = nums[i]; if (num &gt; max) &#123; max = num; maxIndex = i; &#125; &#125; TreeNode node = new TreeNode(max); node.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, 0, maxIndex)); node.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIndex + 1, len)); return node; &#125; Runtime: 6 ms, faster than 69.99% of Java online submissions for Maximum Binary Tree. Memory Usage: 39.1 MB, less than 88.96% of Java online submissions for Maximum Binary Tree.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基于反射的通用树形结构工具类]]></title>
    <url>%2Fjava-tree-util%2F</url>
    <content type="text"><![CDATA[在日常的开发中, 经常会遇到许多树形结构的场景, 如菜单树, 部门树, 目录树等. 而这些一般都会涉及到要将数据库查询出来的集合转化为树形结构的功能.由于 list -&gt; tree 是一个比较通用的功能, 无非就是根据 id, pid, children 这三个字段进行转换. 但由于字段名可能不一致, 如菜单里可能叫 menuId, 而部门里叫 deptId，所以我用反射来实现了一个通用的工具类, 来进行转换. 工具类:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153import org.springframework.util.StringUtils;import javax.validation.constraints.NotNull;import java.lang.reflect.Field;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Set;public class TreeUtils &#123; /** * 集合转树结构 * * @param collection 目标集合 * @param clazz 集合元素类型 * @return 转换后的树形结构 */ public static &lt;T&gt; Collection&lt;T&gt; toTree(@NotNull Collection&lt;T&gt; collection, @NotNull Class&lt;T&gt; clazz) &#123; return toTree(collection, null, null, null, clazz); &#125; /** * 集合转树结构 * * @param collection 目标集合 * @param id 节点编号字段名称 * @param parent 父节点编号字段名称 * @param children 子节点集合属性名称 * @param clazz 集合元素类型 * @return 转换后的树形结构 */ public static &lt;T&gt; Collection&lt;T&gt; toTree(@NotNull Collection&lt;T&gt; collection, String id, String parent, String children, @NotNull Class&lt;T&gt; clazz) &#123; try &#123; if (collection == null || collection.isEmpty()) return null;// 如果目标集合为空,直接返回一个空树 if (StringUtils.isEmpty(id)) id = "id"; // 如果被依赖字段名称为空则默认为id if (StringUtils.isEmpty(parent)) parent = "parent"; // 如果依赖字段为空则默认为parent if (StringUtils.isEmpty(children)) children = "children"; // 如果子节点集合属性名称为空则默认为children // 初始化根节点集合, 支持 Set 和 List Collection&lt;T&gt; roots; if (collection.getClass().isAssignableFrom(Set.class)) &#123; roots = new HashSet&lt;&gt;(); &#125; else &#123; roots = new ArrayList&lt;&gt;(); &#125; // 获取 id 字段, 从当前对象或其父类 Field idField; try &#123; idField = clazz.getDeclaredField(id); &#125; catch (NoSuchFieldException e1) &#123; idField = clazz.getSuperclass().getDeclaredField(id); &#125; // 获取 parentId 字段, 从当前对象或其父类 Field parentField; try &#123; parentField = clazz.getDeclaredField(parent); &#125; catch (NoSuchFieldException e1) &#123; parentField = clazz.getSuperclass().getDeclaredField(parent); &#125; // 获取 children 字段, 从当前对象或其父类 Field childrenField; try &#123; childrenField = clazz.getDeclaredField(children); &#125; catch (NoSuchFieldException e1) &#123; childrenField = clazz.getSuperclass().getDeclaredField(children); &#125; // 设置为可访问 idField.setAccessible(true); parentField.setAccessible(true); childrenField.setAccessible(true); // 找出所有的根节点 for (T c : collection) &#123; Object parentId = parentField.get(c); if (isRootNode(parentId)) &#123; roots.add(c); &#125; &#125; // 从目标集合移除所有根节点 collection.removeAll(roots); // 遍历根节点, 依次添加子节点 for (T root : roots) &#123; addChild(root, collection, idField, parentField, childrenField); &#125; // 关闭可访问 idField.setAccessible(false); parentField.setAccessible(false); childrenField.setAccessible(false); return roots; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; /** * 为目标节点添加孩子节点 * * @param node 目标节点 * @param collection 目标集合 * @param idField ID 字段 * @param parentField 父节点字段 * @param childrenField 字节点字段 */ private static &lt;T&gt; void addChild(@NotNull T node, @NotNull Collection&lt;T&gt; collection, @NotNull Field idField, @NotNull Field parentField, @NotNull Field childrenField) throws IllegalAccessException &#123; Object id = idField.get(node); Collection&lt;T&gt; children = (Collection&lt;T&gt;) childrenField.get(node); // 如果子节点的集合为 null, 初始化孩子集合 if (children == null) &#123; if (collection.getClass().isAssignableFrom(Set.class)) &#123; children = new HashSet&lt;&gt;(); &#125; else children = new ArrayList&lt;&gt;(); &#125; for (T t : collection) &#123; Object o = parentField.get(t); if (id.equals(o)) &#123; // 将当前节点添加到目标节点的孩子节点 children.add(t); // 重设目标节点的孩子节点集合,这里必须重设,因为如果目标节点的孩子节点是null的话,这样是没有地址的,就会造成数据丢失,所以必须重设,如果目标节点所在类的孩子节点初始化为一个空集合,而不是null,则可以不需要这一步,因为java一切皆指针 childrenField.set(node, children); // 递归添加孩子节点 addChild(t, collection, idField, parentField, childrenField); &#125; &#125; &#125; /** * 判断是否是根节点, 判断方式为: 父节点编号为空或为 0, 则认为是根节点. 此处的判断应根据自己的业务数据而定. * @param parentId 父节点编号 * @return 是否是根节点 */ private static boolean isRootNode(Object parentId) &#123; boolean flag = false; if (parentId == null) &#123; flag = true; &#125; else if (parentId instanceof String &amp;&amp; (StringUtils.isEmpty(parentId) || parentId.equals("0"))) &#123; flag = true; &#125; else if (parentId instanceof Integer &amp;&amp; Integer.valueOf(0).equals(parentId)) &#123; flag = true; &#125; return flag; &#125;&#125; 菜单实体类:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Menu implements Serializable &#123; private static final long serialVersionUID = 5561561457068906366L; private Integer menuId; private Integer parentId; private String menuName; private String url; private List&lt;Menu&gt; children; public Integer getMenuId() &#123; return menuId; &#125; public void setMenuId(Integer menuId) &#123; this.menuId = menuId; &#125; public Integer getParentId() &#123; return parentId; &#125; public void setParentId(Integer parentId) &#123; this.parentId = parentId; &#125; public String getMenuName() &#123; return menuName; &#125; public void setMenuName(String menuName) &#123; this.menuName = menuName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public List&lt;Menu&gt; getChildren() &#123; return children; &#125; public void setChildren(List&lt;Menu&gt; children) &#123; this.children = children; &#125;&#125; 测试类:1234567891011@Testpublic void test() &#123; List&lt;Menu&gt; menuList = new ArrayList&lt;&gt;(); menuList.add(new Menu(1, null, "节点1")); menuList.add(new Menu(2, null, "节点2")); menuList.add(new Menu(3, 1, "节点1.1")); menuList.add(new Menu(4, 1, "节点1.2")); menuList.add(new Menu(5, 3, "节点1.1.1")); Collection&lt;Menu&gt; menus = TreeUtils.toTree(menuList, "menuId", "parentId", "children", Menu.class); System.out.println(JSONUtil.toJsonStr(menus));&#125; 运行结果:1234567891011121314151617181920212223242526272829[ &#123; "menuId": 1, "menuName": "节点1", "children": [ &#123; "children": [ &#123; "menuId": 5, "menuName": "节点1.1.1", "parentId": 3 &#125; ], "menuId": 3, "menuName": "节点1.1", "parentId": 1 &#125;, &#123; "menuId": 4, "menuName": "节点1.2", "parentId": 1 &#125; ] &#125;, &#123; "menuId": 2, "menuName": "节点2" &#125;]]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>工具类</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SLF4J MDC ☞ 将用户信息添加到日志信息中]]></title>
    <url>%2Fspringboot-slf4j-mdc%2F</url>
    <content type="text"><![CDATA[前言你是否有过排查某个用户的操作出现 BUG 时, 从茫茫日志中寻找这个用户操作的痛苦经历, SLF4J 为我们提供了一种基于 ThreadLocal 来实现的 MDC 功能, 用来将自定义信息放入到日志中. 你可能没太明白啥意思, 那么先来看看效果把: 普通日志: 加上MDC的日志: 食用方式可以使用过滤器, 拦截器或 AOP 等方式来实现, 即在用户请求时, 将用户信息写入到 MDC 中, 然后在请求完成后, 清空此 MDC. 我这里使用 SpringMVC 的拦截器 HandlerInterceptor 来演示下, (我这里使用了 Shiro, 所以会调用 Shiro 的代码来获取当前登录用户): 123456789101112131415161718192021222324252627282930@Componentpublic class LogInterceptor implements HandlerInterceptor &#123; private final static String MDC_USERNAME = "username"; private static final Logger LOGGER = LoggerFactory.getLogger(LogInterceptor.class); @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; // 如已进行登录, 则获取当前登录者的用户名放入 MDC 中. String username = ""; if (SecurityUtils.getSubject().getPrincipal() != null) &#123; username = ((User) SecurityUtils.getSubject().getPrincipal()).getUsername(); &#125; MDC.put(MDC_USERNAME, username); LOGGER.debug("MDC : PUT MDC_USERNAME (&#123;&#125;) in logger", username); return true; &#125; @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; String username = MDC.get(MDC_USERNAME); LOGGER.debug("MDC : remove MDC_USERNAME (&#123;&#125;) from logger", username); MDC.remove(username); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; 再将其配置到 Spring 拦截器中:123456789101112@Configurationpublic class WebMvcConfigurer extends WebMvcConfigurerAdapter &#123; @Autowired private LogInterceptor logInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(logInterceptor); super.addInterceptors(registry); &#125;&#125; 然后在日志格式中使用 %X{username} 将 MDC 添加进去即可, 由于我使用的是 SpringBoot 的 logback， 所以在保留原 SpringBoot 默认格式的同时, 加上了 MDC: 1logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:%5p&#125;) %clr($&#123;PID&#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; [%10.10X&#123;username&#125;] %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>SLF4J</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 统一异常处理最佳实践 -- 拓展篇]]></title>
    <url>%2Fspringboot-exception-expand%2F</url>
    <content type="text"><![CDATA[前言之前一篇文章介绍了基本的统一异常处理思路: Spring MVC/Boot 统一异常处理最佳实践. 上篇文章也有许多人提出了一些问题: 如何区分 Ajax 请求和普通页面请求, 以分别返回 JSON 错误信息和错误页面. 如何结合 HTTP 状态码进行统一异常处理. 今天这篇文章就主要来讲讲这些, 以及其他的一些拓展点. 区分请求方式其实 Spring Boot 本身是内置了一个异常处理机制的, 会判断请求头的参数来区分要返回 JSON 数据还是错误页面. 源码为: org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController, 他会处理 /error 请求. 核心处理代码如下: 1234567891011121314151617181920212223242526@RequestMapping( produces = &#123;"text/html"&#125;)// 如果请求头是 text/html, 则找到错误页面, 并返回public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; // 1. 获取 HTTP 错误状态码 HttpStatus status = this.getStatus(request); // 2. 调用 getErrorAttributes 获取响应的 map 结果集. Map&lt;String, Object&gt; model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.TEXT_HTML))); // 3. 设置响应头的状态码 response.setStatus(status.value()); // 4. 获取错误页面的路径 ModelAndView modelAndView = this.resolveErrorView(request, response, status, model); return modelAndView != null ? modelAndView : new ModelAndView("error", model);&#125;@RequestMapping@ResponseBodypublic ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; // 调用 getErrorAttributes 获取响应的 map 结果集. Map&lt;String, Object&gt; body = this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.ALL)); // 获取 HTTP 错误状态码 HttpStatus status = this.getStatus(request); // 返回给页面 JSON 信息. return new ResponseEntity(body, status);&#125; 这两个方法的共同点是: 他们都调用了 this.getErrorAttributes(…) 方法来获取响应信息. 然后来看看他默认情况下对于 AJAX 请求和 HTML 请求, 分别的返回结果是怎样的: 对于返回错误页面, 其中还调用了一个非常重要的方法: this.resolveErrorView(...) 方法, 源码我就不带大家看了, 他的作用就是根据 HTTP 状态码来去找错误页面, 如 500 错误会去找 /error/500.html, 403 错误回去找 /error/403.html, 如果找不到则再找 /error/4xx.html 或 /error/5xx.html 页面. 还找不到的话, 则会去找 /error.html 页面, 如果都没有配置, 则会使用 Spring Boot 默认的页面. 即: 看到这里, 应该就清楚了, 我们主要需要做四件事: 发送异常后, 重定向到 BasicErrorController 来处理 (既然Spring Boot 都已经写好了区分请求的功能, 我们就不必要再写这些判断代码了) 自定义 HTTP 错误状态码 他返回的信息格式可能不是我们想要的, 所以必须要改造 getErrorAttributes(...) 方法, 以自定义我们向页面返回的数据. (自定义错误信息) 创建我们自己的 /error/4xx.html 或 /error/5xx.html 等页面, (自定义错误页面) BasicErrorController第一点很简单, BasicErrorController 他处理 /error 请求, 我们只需要将页面重定向到 /error 即可, 在 ControllerAdvice 中是这样的: 123456789@ControllerAdvicepublic class WebExceptionHandler &#123; @ExceptionHandler public String methodArgumentNotValid(BindException e) &#123; // do something return "/error"; &#125;&#125; 自定义 HTTP 错误状态码我们来看下 this.getStatus(request); 的源码, 看他原来时如何获取错误状态码的: 123456789101112protected HttpStatus getStatus(HttpServletRequest request) &#123; Integer statusCode = (Integer)request.getAttribute("javax.servlet.error.status_code"); if (statusCode == null) &#123; return HttpStatus.INTERNAL_SERVER_ERROR; &#125; else &#123; try &#123; return HttpStatus.valueOf(statusCode); &#125; catch (Exception var4) &#123; return HttpStatus.INTERNAL_SERVER_ERROR; &#125; &#125;&#125; 简单来说就是从 request 域中获取 javax.servlet.error.status_code 的值, 如果为 null 或不合理的值, 都返回 500. 既然如何在第一步, 重定向到 /error 之前将其配置到 request 域中即可, 如: 12345678910@ControllerAdvicepublic class WebExceptionHandler &#123; @ExceptionHandler public String methodArgumentNotValid(BindException e, HttpServletRequest request) &#123; request.setAttribute("javax.servlet.error.status_code", 400); // do something return "forward:/error"; &#125;&#125; 自定义错误信息也就是 getErrorAttributes 方法, 默认的代码是这样的: 12345678public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap(); errorAttributes.put("timestamp", new Date()); this.addStatus(errorAttributes, webRequest); this.addErrorDetails(errorAttributes, webRequest, includeStackTrace); this.addPath(errorAttributes, webRequest); return errorAttributes;&#125; 他获取了时间戳, 错误状态码, 错误信息, 错误路径等信息, 和我们之前看到默认的返回内容是一致的:1234567&#123; "timestamp": "2019-01-27T07:08:30.011+0000", "status": 500, "error": "Internal Server Error", "message": "/ by zero", "path": "/user/index"&#125; 同样的思路, 我们将错误信息也放到 request 域中, 然后在 getErrorAttributes 中从 request 域中获取: 123456789101112@ControllerAdvicepublic class WebExceptionHandler &#123; @ExceptionHandler public String methodArgumentNotValid(BindException e, HttpServletRequest request) &#123; request.setAttribute("javax.servlet.error.status_code", 400); request.setAttribute("code", 1); request.setAttribute("message", "参数校验失败, xxx"); // do something return "forward:/error"; &#125;&#125; 再继承 DefaultErrorAttributes 类, 重写 getErrorAttributes 方法: 1234567891011121314151617//@Componentpublic class MyDefaultErrorAttributes extends DefaultErrorAttributes &#123; @Override //重写 getErrorAttributes方法-添加自己的项目数据 public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 从 request 域中获取 code Object code = webRequest.getAttribute("code", RequestAttributes.SCOPE_REQUEST); // 从 request 域中获取 message Object message = webRequest.getAttribute("message", RequestAttributes.SCOPE_REQUEST); map.put("code", code); map.put("message", message); return map; &#125;&#125; 自定义错误页面我们遵循 SpringBoot 的规则, 在 /error/ 下建立 400.html, 500.html 等页面细粒度的错误, 并配置一个 /error.html 用来处理细粒度未处理到的其他错误. /error/400.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;400&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;400&lt;/h1&gt; &lt;h1 th:text="$&#123;code&#125;"&gt;&lt;/h1&gt; &lt;h1 th:text="$&#123;message&#125;"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; /error/500.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;500&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;500&lt;/h1&gt; &lt;h1 th:text="$&#123;code&#125;"&gt;&lt;/h1&gt; &lt;h1 th:text="$&#123;message&#125;"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; /error.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;系统出现了错误&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;ERROR PAGE&lt;/h1&gt; &lt;h1 th:text="$&#123;code&#125;"&gt;&lt;/h1&gt; &lt;h1 th:text="$&#123;message&#125;"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 测试效果到此位置, 大功告成, 然后来创造一个异常来测试一下效果: 前端 error 处理现在使用了 HTTP 状态码, 所以 Ajax 请求出现错误后, 需要在每个 Ajax 请求方法中都写 error: function() {} 方法, 甚至麻烦. 好在 jQuery 为我们提供了全局处理 Ajax 的 error 结果的方法 ajaxError() : 12345$(document).ajaxError(function(event, response)&#123; console.log("错误响应状态码: ",response.status); console.log("错误响应结果: ",response.responseJSON); alert("An error occurred!");&#125;); 结语回顾一下讲到的这些内容： 理解 SpringBoot 默认提供的 BasicErrorController 自定义 HTTP 错误状态码, (通过 request 域的 javax.servlet.error.status_code 参数) 自定义错误信息, (将我们自定义的错误信息放到 request 域中, 并重写 DefaultErrorAttributes 的 getErrorAttributes 方法, 从 request 域中获取这些信息). 自定义错误页面, (根据 SpringBoot 查找错误页面的逻辑来自定义错误页面: /error/500.html, /error/400.html, /error.html) 可以自己根据文章一步一步走一遍, 或者看我写好的演示项目先看看效果, 总是动手实践, 而不是收藏文章并封存。演示项目地址: https://github.com/zhaojun1998/exception-handler-demo]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>异常处理</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC/Boot 统一异常处理最佳实践]]></title>
    <url>%2Fspringboot-exception%2F</url>
    <content type="text"><![CDATA[前言在 Web 开发中, 我们经常会需要处理各种异常, 这是一件棘手的事情, 对于很多人来说, 可能对异常处理有以下几个问题: 什么时候需要捕获(try-catch)异常, 什么时候需要抛出(throws)异常到上层. 在 dao 层捕获还是在 service 捕获, 还是在 controller 层捕获. 抛出异常后要怎么处理. 怎么返回给页面错误信息. 异常处理反例既然谈到异常, 我们先来说一下异常处理的反例, 也是很多人容易犯的错误, 这里我们同时讲到前端处理和后端处理 : 捕获异常后只输出到控制台前端代码12345678$.ajax(&#123; type: "GET", url: "/user/add", dataType: "json", success: function(data)&#123; alert("添加成功"); &#125;&#125;); 后端代码12345try &#123; // do something&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 这是见过最多的异常处理方式了, 如果这是一个添加商品的方法, 前台通过 ajax 发送请求到后端, 期望返回 json 信息表示添加结果. 但如果这段代码出现了异常: 那么用户看到的场景就是点击了添加按钮, 但没有任何反应(其实是返回了 500 错误页面, 但这里前端没有监听 error 事件, 只监听了 success 事件. 但即使加上了error: function(data) {alert(&quot;添加失败&quot;);}) 又如何呢? 到底因为啥失败了呢, 用户也不得而知. 后台 e.printStackTrace() 打印在控制台的日志也会在漫漫的日志中被埋没, 很可能会看不到输出的异常. 但这并不是最糟的情况, 更糟糕的事情是连 e.printStackTrace() 都没有, catch 块中是空的, 这样后端的控制台中更是什么都看不到了, 这段代码会像一个隐形的炸弹一样一直埋伏在系统中. 混乱的返回方式前端代码 123456789101112131415$.ajax(&#123; type: "GET", url: "/goods/add", dataType: "json", success: function(data) &#123; if (data.flag) &#123; alert("添加成功"); &#125; else &#123; alert(data.message); &#125; &#125;, error: function(data)&#123; alert("添加失败"); &#125;&#125;); 后端代码1234567891011121314@RequestMapping("/goods/add")@ResponseBodypublic Map add(Goods goods) &#123; Map map = new HashMap(); try &#123; // do something map.put(flag, true); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put("flag", false); map.put("message", e.getMessage()); &#125; reutrn map;&#125; 这种方式捕获异常后, 返回了错误信息, 且前台做了一定的处理, 看起来很完善? 但用 HashMap 中的 flag 和 message 这种字符串来当键很容易处理, 例如你这里叫 message, 别人起名叫 msg, 甚至有时手抖打错了, 怎么办? 前台再改成 msg 或其他的字符?, 前端后端这样一直来回改?更有甚者在情况 A 的情况下, 返回 json, 在情况 B 的情况下, 重定向到某个页面, 这就更乱了. 对于这种不统一的结构处理起来非常麻烦. 异常处理规范既然要进行统一异常处理, 那么肯定要有一个规范, 不能乱来. 这个规范包含前端和后端. 不要捕获任何异常对的, 不要在业务代码中进行捕获异常, 即 dao、service、controller 层的所以异常都全部抛出到上层. 这样不会导致业务代码中的一堆 try-catch 会混乱业务代码. 统一返回结果集不要使用 Map 来返回结果, Map 不易控制且容易犯错, 应该定义一个 Java 实体类. 来表示统一结果来返回, 如定义实体类:123456789101112131415161718192021222324252627282930313233public class ResultBean&lt;T&gt; &#123; private int code; private String message; private Collection&lt;T&gt; data; private ResultBean() &#123; &#125; public static ResultBean error(int code, String message) &#123; ResultBean resultBean = new ResultBean(); resultBean.setCode(code); resultBean.setMessage(message); return resultBean; &#125; public static ResultBean success() &#123; ResultBean resultBean = new ResultBean(); resultBean.setCode(0); resultBean.setMessage("success"); return resultBean; &#125; public static &lt;V&gt; ResultBean&lt;V&gt; success(Collection&lt;V&gt; data) &#123; ResultBean resultBean = new ResultBean(); resultBean.setCode(0); resultBean.setMessage("success"); resultBean.setData(data); return resultBean; &#125; // getter / setter 略&#125; 正常情况: 调用 ResultBean.success() 或 ResultBean.success(Collection&lt;V&gt; data), 不需要返回数据, 即调用前者, 需要返回数据, 调用后者. 如: 123456@RequestMapping("/goods/add")@ResponseBodypublic ResultBean&lt;Goods&gt; getAllGoods() &#123; List&lt;Goods&gt; goods = goodsService.findAll(); return ResultBean.success(goods);&#125; 123456@RequestMapping("/goods/update")@ResponseBodypublic ResultBean updateGoods(Goods goods) &#123; goodsService.update(goods); return ResultBean.success();&#125; 一般只有查询方法需要调用 ResultBean.success(Collection&lt;V&gt; data) 来返回 N 条数据, 其他诸如删除, 修改等方法都应该调用 ResultBean.success(), 即在业务代码中只处理正确的功能, 不对异常做任何判断. 也不需要对 update 或 delete 的更新条数做判断(个人建议, 实际需要根据业务). 只要没有抛出异常, 我们就认为用户操作成功了. 且操作成功的提示信息在前端处理, 不要后台返回 “操作成功” 等字段. 前台接受到的信息为:1234567891011121314&#123; "code": 0, "message": "success", "data": [ &#123; "name": "商品1", "price": 50.00, &#125;, &#123; "name": "商品2", "price": 99.99, &#125; ]&#125; 抛出异常: 抛出异常后, 我们应该调用 ResultBean.error(int code, String message), 来将状态码和错误信息返回, 我们约定 code 为 0 表示操作成功, 1 或 2 等正数表示用户输入错误, -1, -2 等负数表示系统错误. 前台接受到的信息为:12345&#123; "code": -1, "message": "XXX 参数有问题, 请重新填写", "data": null&#125; 前端统一处理:返回的结果集规范后, 前端就很好处理了: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 显示错误信息 * @param result： 错误信息 */function showError(s) &#123; alert(s);&#125;/** * 处理 ajax 请求结果 * @param result： ajax 返回的结果 * @param fn： 成功的处理函数 ( 传入data: fn(result.data) ) */function handlerResult(result, fn) &#123; // 成功执行操作，失败提示原因 if (result.code == 0) &#123; fn(result.data); &#125; // 用户操作异常, 这里可以对 1 或 2 等错误码进行单独处理, 也可以 result.code &gt; 0 来粗粒度的处理, 根据业务而定. else if (result.code == 1) &#123; showError(result.message); &#125; // 系统异常, 这里可以对 -1 或 -2 等错误码进行单独处理, 也可以 result.code &gt; 0 来粗粒度的处理, 根据业务而定. else if (result.code == -1) &#123; showError(result.message); &#125; // 如果进行细粒度的状态码判断, 那么就应该重点注意这里没出现过的状态码. 这个判断仅建议在开发阶段保留用来发现未定义的状态码. else &#123; showError("出现未定义的状态码:" + result.code); &#125;&#125;/** * 根据 id 删除商品 */function deleteGoods(id) &#123; $.ajax(&#123; type: "GET", url: "/goods/delete", dataType: "json", success: function(result)&#123; handlerResult(result, deleteDone); &#125; &#125;);&#125;function deleteDone(data) &#123; alert("删除成功");&#125; showError 和 handlerResult 是公共方法, 分别用来显示错误和统一处理结果集. 然后将主要精力放在发送请求和处理正确结果的方法上即可, 如这里的 deleteDone 函数, 用来处理操作成功给用户的提示信息, 正所谓各司其职, 前端负责操作成功的消息提示更合理, 而错误信息只有后台知道, 所以需要后台来返回. 后端统一处理异常说了这么多, 还没讲到后端不在业务层捕获任何异常的事, 既然所有业务层都没有捕获异常, 那么所有的异常都会抛出到 Controller 层, 我们只需要用 AOP 对 Controller 层的所有方法处理即可. 好在 Spring 为我们提供了一个注解, 用来统一处理异常:12345678910111213141516171819202122232425@ControllerAdvice@ResponseBodypublic class WebExceptionHandler &#123; private static final Logger log = LoggerFactory.getLogger(WebExceptionHandler.class); @ExceptionHandler public ResultBean unknownAccount(UnknownAccountException e) &#123; log.error("账号不存在", e); return ResultBean.error(1, "账号不存在"); &#125; @ExceptionHandler public ResultBean incorrectCredentials(IncorrectCredentialsException e) &#123; log.error("密码错误", e); return ResultBean.error(-2, "密码错误"); &#125; @ExceptionHandler public ResultBean unknownException(Exception e) &#123; log.error("发生了未知异常", e); // 发送邮件通知技术人员. return ResultBean.error(-99, "系统出现错误, 请联系网站管理员!"); &#125;&#125; 在这里统一配置需要处理的异常, 同样, 对于未知的异常, 一定要及时发现, 并进行处理. 推荐出现未知异常后发送邮件, 提示技术人员. 总结总结一下统一异常处理的方法: 不使用随意返回各种数据类型, 要统一返回值规范. 不在业务代码中捕获任何异常, 全部交由 @ControllerAdvice 来处理. 一个简单的演示项目: https://github.com/zhaojun1998/exception-handler-demo]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>异常处理</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 299 Bulls and Cows]]></title>
    <url>%2Fleetcode-299%2F</url>
    <content type="text"><![CDATA[题意 你正和你的朋友一起玩下面的公牛和母牛游戏：你写下一个数字然后让你的朋友猜猜这个数字是多少. 每当你的朋友猜测时, 你提供一个提示, 表明所述猜测中有多少位数与你的密码完全匹配，包括数字和位置(称为”公牛”)以及有多少位数与密码匹配但位于错误的位置(称为”奶牛”)。编写一个函数, 根据秘密数字和朋友的猜测返回提示, 用于 A 表示公牛, B 表示奶牛. 例 1: 12345输入: secret = &quot;1807&quot;, guess = &quot;7810&quot;输出: &quot;1A3B&quot;说明: 1 个公牛和 3 个奶牛. 公牛是 8, 奶牛是 0, 1 和 7. 例 2: 12345输入: secret = &quot;1123&quot;, guess = &quot;0111&quot;输出: &quot;1A1B&quot;说明: The 1st 1 in friend&apos;s guess is a bull, the 2nd or 3rd 1 is a cow. 解法刚开始我的想法是依次获取公牛和奶牛的数量, 但奶牛的判断需要 O(n^2) 的时间复杂度, 后面想到, 用所有匹配的数量 - 公牛的数量就是奶牛的数量, 只需要 O(n) 的时间复杂度和 O(1) 的空间复杂度. 1234567891011121314151617181920public String getHint(String secret, String guess) &#123; int[] table = new int[10]; int total = 0; int bulls = 0; for (char c :secret.toCharArray()) &#123; table[c - '0']++; &#125; for (int i = 0; i &lt; guess.length(); i++) &#123; if (secret.charAt(i) == guess.charAt(i)) &#123; bulls++; &#125; if (table[guess.charAt(i) - '0']-- &gt; 0) &#123; total++; &#125; &#125; return bulls + "A" + (total - bulls) + "B";&#125; Runtime: 1 ms, faster than 100.00% of Java online submissions for Bulls and Cows.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 80 Remove Duplicates from Sorted Array II]]></title>
    <url>%2Fleetcode-80%2F</url>
    <content type="text"><![CDATA[题意 给定一个数组，删除其中的重复元素，使重复项最多出现两次，然后返回新的长度，要求 O(1) 空间复杂度。 例 1: 123给予 nums = [1, 1, 1, 2, 2, 3],你的函数应该返回 length = 5,前五个元素分别为 1, 1, 2, 2, 3. 例 2: 123给予 nums = [0, 0, 1, 1, 1, 1, 2, 3, 3],你的函数应该返回 length = 7,前五个元素分别为 0, 0, 1, 1, 2, 3, 3. 解法和 LeetCode 26 Remove Duplicates from Sorted Array 这道题比较类似。定义变量 k，表示待修改的元素位置，默认为 0，然后遍历后面的元素判断符合条件时，覆盖 k，然后 k 向后移动一位。判断条件为： 遍历的元素 n 不等于元素 k，也就代表不重复 遍历的元素 n 等于元素 k，但不等于 k - 1。则表示已经有两个重复元素了 对于第二点，需要注意，当 k = 0 时，没有 k - 1。 1234567891011class Solution &#123; public int removeDuplicates(int[] nums) &#123; int k = 0; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] != nums[k] || k == 0 || (nums[i] == nums[k] &amp;&amp; nums[i] != nums[k - 1])) &#123; nums[++k] = nums[i]; &#125; &#125; return k + 1; &#125;&#125; Runtime: 6 ms, faster than 95.36% of Java online submissions for Remove Duplicates from Sorted Array II.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 26 Remove Duplicates from Sorted Array]]></title>
    <url>%2Fleetcode-26%2F</url>
    <content type="text"><![CDATA[题意 给定一个有序的 int 数组，使每个元素只出现一次，并返回新的长度。要求在原数组修改，即 O(1) 的空间复杂度。 解法从头开始获取不重复的元素，依次填充到数组的前几位，并返回不重复的元素个数。 1234567891011class Solution &#123; public int removeDuplicates(int[] nums) &#123; int k = 0; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] != nums[k]) &#123; nums[++k] = nums[i]; &#125; &#125; return k+1; &#125;&#125; Runtime: 7 ms, faster than 82.95% of Java online submissions for Remove Duplicates from Sorted Array.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 27 Remove Element]]></title>
    <url>%2Fleetcode-27%2F</url>
    <content type="text"><![CDATA[题意 给定一个字符串数组，从数组中删除指定值 n，返回删除后的长度 k。（并不用真的删除，元素顺序可以改变，只需要保证返回的前 k 个数字不包含 n 即可。） 解法定义 left 为 0, right 为数组长度 - 1，left 依次向右走，碰到当前元素等于 n 时，将 right 所在的元素覆盖 n 所在的元素，并将 right 左移一位，直到 left 碰到 right。 1234567891011class Solution &#123; public int removeElement(int[] nums, int val) &#123; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; while (nums[i] == val &amp;&amp; i &lt; len) &#123; nums[i] = nums[--len]; &#125; &#125; return len; &#125;&#125; Runtime: 4 ms, faster than 99.11% of Java online submissions for Remove Element.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 917 Reverse Only Letters]]></title>
    <url>%2Fleetcode-917%2F</url>
    <content type="text"><![CDATA[题意 反转字符串，但只反转字符串中的字母，即 a-z，A-Z。其他的字符保持原位。 Example 1: 12Input: &quot;ab-cd&quot;Output: &quot;dc-ba&quot; Example 2:12Input: &quot;a-bC-dEf-ghIj&quot;Output: &quot;j-Ih-gfE-dCba&quot; Example 3:12Input: &quot;Test1ng-Leet=code-Q!&quot;Output: &quot;Qedo1ct-eeLg=ntse-T!&quot; 解法将字符串转为字符数组，用两个指针，从两端向中间走, 依次找下一个字母进行交换，直到两个指针相碰撞。 1234567891011121314151617181920212223242526class Solution &#123; public String reverseOnlyLetters(String S) &#123; char[] chars = S.toCharArray(); int i = 0, j = chars.length - 1; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; !isLetter(chars[i])) &#123; i++; &#125; while (i &lt; j &amp;&amp; !isLetter(chars[j])) &#123; j--; &#125; if (i &lt; j) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; i++; j--; &#125; &#125; return new String(chars); &#125; private boolean isLetter(char c) &#123; return (c &gt;= 65 &amp;&amp; c &lt;= 90) || (c &gt;= 97 &amp;&amp; c &lt;= 122); &#125;&#125; Runtime: 5 ms, faster than 93.93% of Java online submissions for Reverse Only Letters.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 344 Reverse String]]></title>
    <url>%2Fleetcode-344%2F</url>
    <content type="text"><![CDATA[题意 翻转字符串。 解法两个指针，分别在首和尾，都向中间走，直到首超过尾。 1234567891011class Solution &#123; public String reverseString(String s) &#123; char[] chars = s.toCharArray(); for (int i = 0, j = chars.length - 1; i &lt; j; i++, j--) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; &#125; return new String(chars); &#125;&#125; Runtime: 2 ms, faster than 79.62% of Java online submissions for Reverse String.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 557 Reverse Words in a String III]]></title>
    <url>%2Fleetcode-557%2F</url>
    <content type="text"><![CDATA[题意 给定一个字符串, 翻转字符串中的每个单词, 每个单词以空格分隔, 保留空格和初始单词顺序。 解法首先按照空格对字符串进行分隔，然后将每个单词进行翻转后再拼接回字符串即可，需要注意拼接时记得加空格，但最后一个单词不需要加。 12345678910111213141516171819class Solution &#123; public String reverseWords(String s) &#123; StringBuilder result = new StringBuilder(); String[] strs = s.split(" "); for (String str : strs) &#123; char[] chars = str.toCharArray(); for (int i = 0, j = chars.length - 1; i &lt; j; i++, j--) &#123; char c = chars[i]; chars[i] = chars[j]; chars[j] = c; &#125; result.append(new String(chars)).append(" "); &#125; return result.substring(0, result.length() - 1); &#125;&#125; Runtime: 6 ms, faster than 93.75% of Java online submissions for Reverse Words in a String III.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 657 Robot Return to Origin]]></title>
    <url>%2Fleetcode-657%2F</url>
    <content type="text"><![CDATA[题意 其实就是给一个字符串, 每个字符包含 “U”、”D”、”L”、”R”, 分别表示上下左右, 表示机器人向这个位置走一步, 判断最终是否机器人是否还在原来的位置。 解法这道题很简单，只需要假设当前节点是 0, 0，定义两个变量, i 和 j，默认值都为 0，每当向上 i + 1，向下 i - 1，向右 j + 1，向左 j - 1。最终只需要判断 i 和 j 是否都等于 0 即可。 12345678910111213141516171819class Solution &#123; public boolean judgeCircle(String moves) &#123; int i = 0; int j = 0; char[] chars = moves.toCharArray(); for (char ch : chars) &#123; if (ch == 'U') &#123; i += 1; &#125; else if (ch == 'D') &#123; i -= 1; &#125; else if (ch == 'R') &#123; j += 1; &#125; else if (ch == 'L') &#123; j -= 1; &#125; &#125; return i == 0 &amp;&amp; j == 0; &#125;&#125; Runtime: 8 ms, faster than 97.27% of Java online submissions for Robot Return to Origin.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 520 Detect Capital]]></title>
    <url>%2Fleetcode-520%2F</url>
    <content type="text"><![CDATA[题意 给与一个单词，判断其大写字母的使用是否正确，即每个字母都是大写或都是小写，或首字母大写。 Example 1:12Input: &quot;USA&quot;Output: True Example 2:12Input: &quot;FlaG&quot;Output: False 解法定义两个变量，记录小写字母个数和大写字母个数，然后判断条件是否符合。 123456789101112131415161718192021222324252627class Solution &#123; public boolean detectCapitalUse(String word) &#123; if (word.length() &lt; 2) &#123; return true; &#125; char[] chars = word.toCharArray(); int lower = 0, upper = 0; for (int i = 0; i &lt; chars.length; i++) &#123; if (isLowerCaseLetter(chars[i])) &#123; lower++; &#125; else &#123; upper++; &#125; &#125; return lower == chars.length || upper == chars.length || (isUpperCaseLetter(chars[0]) &amp;&amp; lower == chars.length - 1); &#125; public boolean isUpperCaseLetter(char c) &#123; return c &gt;= 65 &amp;&amp; c &lt;= 90; &#125; public boolean isLowerCaseLetter(char c) &#123; return c &gt;= 97 &amp;&amp; c &lt;= 122; &#125;&#125; Runtime: 12 ms, faster than 98.36% of Java online submissions for Detect Capital.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 804 Unique Morse Code Words]]></title>
    <url>%2Fleetcode-804%2F</url>
    <content type="text"><![CDATA[题意 给予一个编码表，26 个字母分别对应一个编码，给定一组单词，获取单词的所有字母组合后的编码中不重复的数量。 解法首先为每个单词的每个字符进行转码, 将转码后的数据放到 Set 集合中, 最后返回 Set 的长度。 123456789101112131415161718192021class Solution &#123; private String[] codes = &#123;".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."&#125;; public int uniqueMorseRepresentations(String[] words) &#123; HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); for (String word : words) &#123; hashSet.add(convertCode(word)); &#125; return hashSet.size(); &#125; private String convertCode(String word) &#123; char[] chars = word.toCharArray(); String code = ""; for (char ch : chars) &#123; code += codes[ch - 97]; &#125; return code; &#125;&#125; Runtime: 4 ms, faster than 100.00% of Java online submissions for Unique Morse Code Words.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 709 To Lower Case]]></title>
    <url>%2Fleetcode-709%2F</url>
    <content type="text"><![CDATA[题意 传入字符串，将其小写形式。 解法根据 ASCII 码判断并返回即可，大写 A - Z 为 065 - 090，小写 a - z 为 097 - 122，正好相隔 32，当为大写时，将 ASCII 码 + 32 即可。 123456789101112class Solution &#123; public String toLowerCase(String str) &#123; char[] chars = str.toCharArray(); for (int i = 0; i &lt; chars.length; i++) &#123; char c = chars[i]; if (c &gt;= 65 &amp;&amp; c &lt;= 90) &#123; chars[i] = (c += 32); &#125; &#125; return new String(chars); &#125;&#125; Runtime: 0 ms, faster than 100.00% of Java online submissions for To Lower Case.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 929 Unique Email Addresses]]></title>
    <url>%2Fleetcode-929%2F</url>
    <content type="text"><![CDATA[题意 给与一组 email 地址，email 分为两部分， @ 前我们称为 local name, @ 后称为 domain name。现规定只可以出现小写字母和字符 .、+。其中 . 可以忽略, 如 `alice.z@leetcode.com和al.icez@leetcode.com都表示alicez@leetcode.com。+出现在local name中时，将忽略第一个+后的所有内容，如m.y+name@email.com和m.y@email.com都表示my@email.com`。 解法按照题意，先取 local name 的第一个字符到第一个加号之前的内容, 然后删除其中的所有 ., 并与 @ 后的 domain name 拼接, 将结果放入 Set 集合中，最后返回 Set 的长度即可。 123456789101112131415class Solution &#123; public int numUniqueEmails(String[] emails) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (String email : emails) &#123; int start = email.indexOf("+"); int end = email.indexOf("@"); String localName = email.substring(0, start); localName = localName.replace(".", ""); String domainName = email.substring(end, email.length()); set.add(localName + domainName); &#125; return set.size(); &#125;&#125; Runtime: 35 ms, faster than 63.93% of Java online submissions for Unique Email Addresses.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 拓展之 Restful URL 鉴权]]></title>
    <url>%2Fshiro-restful%2F</url>
    <content type="text"><![CDATA[前言在使用 Shiro 的过程中，遇到一个痛点，就是对 restful 支持不太好，也查了很多资料，各种各样的方法都有，要不就是功能不完整，要不就是解释不清楚，还有一些对原有功能的侵入性太强，经过一番探索，算是最简的配置下完成了需要的功能，这里给大家分享下。大家如果又更好的方案，也可以在评论区留言，互相探讨下。 虽然深入到了源码进行分析，但过程并不复杂，希望大家可以跟着我的思路捋顺了耐心看下去，而不是看见源码贴就抵触。 分析首先先回顾下 Shiro 的过滤器链，一般我们都有如下配置：1234/login.html = anon/login = anon/users = perms[user:list]/** = authc 不太熟悉的朋友可以了解下这篇文章：Shiro 过滤器。 其中 /users 请求对应到 perms 过滤器，对应的类: org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter，其中的 onAccessDenied 方法是在没有权限时被调用的, 源码如下:123456789101112131415161718protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException &#123; Subject subject = getSubject(request, response); // 如果未登录, 则重定向到配置的 loginUrl if (subject.getPrincipal() == null) &#123; saveRequestAndRedirectToLogin(request, response); &#125; else &#123; // 如果当前用户没有权限, 则跳转到 UnauthorizedUrl // 如果没有配置 UnauthorizedUrl, 则返回 401 状态码. String unauthorizedUrl = getUnauthorizedUrl(); if (StringUtils.hasText(unauthorizedUrl)) &#123; WebUtils.issueRedirect(request, response, unauthorizedUrl); &#125; else &#123; WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED); &#125; &#125; return false;&#125; 我们可以在这里可以判断当前请求是否时 AJAX 请求，如果是，则不跳转到 logoUrl 或 UnauthorizedUrl 页面，而是返回 JSON 数据。 还有一个方法是 pathsMatch，是将当前请求的 url 与所有配置的 perms 过滤器链进行匹配，是则进行权限检查，不是则接着与下一个过滤器链进行匹配，源码如下：12345protected boolean pathsMatch(String path, ServletRequest request) &#123; String requestURI = getPathWithinApplication(request); log.trace("Attempting to match pattern '&#123;&#125;' with current requestURI '&#123;&#125;'...", path, requestURI); return pathsMatch(path, requestURI);&#125; 方法了解完这两个方法，我来说说如何利用这两个方法来实现功能。 我们可以从配置的过滤器链来入手，原先的配置如： 1/users = perms[user:list] 我们可以改为 /user==GET，/user==POST 方式。== 用来分隔, 后面的部分指 HTTP Method。 使用这种方式还要注意一个方法，即：org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver 中的 getChain 方法，用来获取当前请求的 URL 应该使用的过滤器，源码如下： 123456789101112131415161718192021222324252627public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) &#123; // 1. 判断有没有配置过滤器链, 没有一个过滤器都没有则直接返回 null FilterChainManager filterChainManager = getFilterChainManager(); if (!filterChainManager.hasChains()) &#123; return null; &#125; // 2. 获取当前请求的 URL String requestURI = getPathWithinApplication(request); // 3. 遍历所有的过滤器链 for (String pathPattern : filterChainManager.getChainNames()) &#123; // 4. 判断当前请求的 URL 与过滤器链中的 URL 是否匹配. if (pathMatches(pathPattern, requestURI)) &#123; if (log.isTraceEnabled()) &#123; log.trace("Matched path pattern [" + pathPattern + "] for requestURI [" + requestURI + "]. " + "Utilizing corresponding filter chain..."); &#125; // 5. 如果路径匹配, 则获取其实现类.(如 perms[user:list] 或 perms[user:delete] 都返回 perms) // 具体对 perms[user:list] 或 perms[user:delete] 的判断是在上面讲到的 PermissionsAuthorizationFilter 的 pathsMatch 方法中. return filterChainManager.proxy(originalChain, pathPattern); &#125; &#125; return null;&#125; 这里大家需要注意，第四步的判断，我们已经将过滤器链，也就是这里的 pathPattern 改为了 /xxx==GET 这种方式，而请求的 URL 却仅包含 /xxx，那么这里的 pathMatches 方法是肯定无法匹配成功，所以我们需要在第四步判断的时候，只判断前面的 URL 部分。 整个过程如下： 在过滤器链上对 restful 请求配置需要的 HTTP Method，如：/user==DELETE。 修改 PathMatchingFilterChainResolver 的 getChain 方法，当前请求的 URL 与过滤器链匹配时，过滤器只取 URL 部分进行判断。 修改过滤器的 pathsMatch 方法，判断当前请求的 URL 与请求方式是否与过滤器链中配置的一致。 修改过滤器的 onAccessDenied 方法，当访问被拒绝时，根据普通请求和 AJAX 请求分别返回 HTML 和 JSON 数据。 下面我们逐步来实现： 实现过滤器链添加 http method在我的项目中是从数据库获取的过滤器链，所以有如下代码：1234567891011121314151617181920212223public Map&lt;String, String&gt; getUrlPermsMap() &#123; Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); filterChainDefinitionMap.put("/favicon.ico", "anon"); filterChainDefinitionMap.put("/css/**", "anon"); filterChainDefinitionMap.put("/fonts/**", "anon"); filterChainDefinitionMap.put("/images/**", "anon"); filterChainDefinitionMap.put("/js/**", "anon"); filterChainDefinitionMap.put("/lib/**", "anon"); filterChainDefinitionMap.put("/login", "anon"); List&lt;Menu&gt; menus = selectAll(); for (Menu menu : menus) &#123; String url = menu.getUrl(); if (menu.getMethod() != null &amp;&amp; !"".equals(menu.getMethod())) &#123; url += ("==" + menu.getMethod()); &#125; String perms = "perms[" + menu.getPerms() + "]"; filterChainDefinitionMap.put(url, perms); &#125; filterChainDefinitionMap.put("/**", "authc"); return filterChainDefinitionMap;&#125; 如: /xxx==GET = perms[user:list]这里的 getUrl，getMethod 和 getPerms 分别对应 /xxx，GET 和 user:list。 不过需要注意的是，如果在 XML 里配置，会被 Shiro 解析成 /xxx 和 =GET = perms[user:list]，解决办法是使用其他符号代替 ==。 修改 PathMatchingFilterChainResolver 的 getChain 方法由于 Shiro 没有提供相应的接口，且我们不能直接修改源码，所以我们需要新建一个类继承 PathMatchingFilterChainResolver 并重写 getChain 方法，然后替换掉 PathMatchingFilterChainResolver 即可。 首先继承并重写方法：12345678910111213141516171819202122232425262728293031323334353637383940414243package im.zhaojun.shiro;import org.apache.shiro.web.filter.mgt.FilterChainManager;import org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.FilterChain;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class RestPathMatchingFilterChainResolver extends PathMatchingFilterChainResolver &#123; private static final Logger log = LoggerFactory.getLogger(RestPathMatchingFilterChainResolver.class); @Override public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) &#123; FilterChainManager filterChainManager = getFilterChainManager(); if (!filterChainManager.hasChains()) &#123; return null; &#125; String requestURI = getPathWithinApplication(request); //the 'chain names' in this implementation are actually path patterns defined by the user. We just use them //as the chain name for the FilterChainManager's requirements for (String pathPattern : filterChainManager.getChainNames()) &#123; String[] pathPatternArray = pathPattern.split("=="); // 只用过滤器链的 URL 部分与请求的 URL 进行匹配 if (pathMatches(pathPatternArray[0], requestURI)) &#123; if (log.isTraceEnabled()) &#123; log.trace("Matched path pattern [" + pathPattern + "] for requestURI [" + requestURI + "]. " + "Utilizing corresponding filter chain..."); &#125; return filterChainManager.proxy(originalChain, pathPattern); &#125; &#125; return null; &#125;&#125; 然后替换掉 PathMatchingFilterChainResolver，它是在 ShiroFilterFactoryBean 的 createInstance 方法里初始化的。 所以同样的套路，继承 ShiroFilterFactoryBean 并重写 createInstance 方法，将 new PathMatchingFilterChainResolver(); 改为 new RestPathMatchingFilterChainResolver(); 即可。 代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package im.zhaojun.shiro;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.filter.mgt.FilterChainManager;import org.apache.shiro.web.filter.mgt.FilterChainResolver;import org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;import org.apache.shiro.web.mgt.WebSecurityManager;import org.apache.shiro.web.servlet.AbstractShiroFilter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.BeanInitializationException;public class RestShiroFilterFactoryBean extends ShiroFilterFactoryBean &#123; private static final Logger log = LoggerFactory.getLogger(RestShiroFilterFactoryBean.class); @Override protected AbstractShiroFilter createInstance() &#123; log.debug("Creating Shiro Filter instance."); SecurityManager securityManager = getSecurityManager(); if (securityManager == null) &#123; String msg = "SecurityManager property must be set."; throw new BeanInitializationException(msg); &#125; if (!(securityManager instanceof WebSecurityManager)) &#123; String msg = "The security manager does not implement the WebSecurityManager interface."; throw new BeanInitializationException(msg); &#125; FilterChainManager manager = createFilterChainManager(); //Expose the constructed FilterChainManager by first wrapping it in a // FilterChainResolver implementation. The AbstractShiroFilter implementations // do not know about FilterChainManagers - only resolvers: PathMatchingFilterChainResolver chainResolver = new RestPathMatchingFilterChainResolver(); chainResolver.setFilterChainManager(manager); //Now create a concrete ShiroFilter instance and apply the acquired SecurityManager and built //FilterChainResolver. It doesn't matter that the instance is an anonymous inner class //here - we're just using it because it is a concrete AbstractShiroFilter instance that accepts //injection of the SecurityManager and FilterChainResolver: return new SpringShiroFilter((WebSecurityManager) securityManager, chainResolver); &#125; private static final class SpringShiroFilter extends AbstractShiroFilter &#123; protected SpringShiroFilter(WebSecurityManager webSecurityManager, FilterChainResolver resolver) &#123; super(); if (webSecurityManager == null) &#123; throw new IllegalArgumentException("WebSecurityManager property cannot be null."); &#125; setSecurityManager(webSecurityManager); if (resolver != null) &#123; setFilterChainResolver(resolver); &#125; &#125; &#125;&#125; 最后记得将 ShiroFilterFactoryBean 改为 RestShiroFilterFactoryBean。 XML 方式：123&lt;bean id="shiroFilter" class="im.zhaojun.shiro.RestShiroFilterFactoryBean"&gt; &lt;!-- 参数配置略 --&gt;&lt;/bean&gt; Bean 方式：123456@Beanpublic ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new RestShiroFilterFactoryBean(); // 参数配置略 return shiroFilterFactoryBean;&#125; 修改过滤器的 pathsMatch 方法同样新建一个类继承原有的 PermissionsAuthorizationFilter 并重写 pathsMatch 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142package im.zhaojun.shiro.filter;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.StringUtils;import org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter;import org.apache.shiro.web.util.WebUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;/** * 修改后的 perms 过滤器, 添加对 AJAX 请求的支持. */public class RestAuthorizationFilter extends PermissionsAuthorizationFilter &#123; private static final Logger log = LoggerFactory .getLogger(RestAuthorizationFilter.class); @Override protected boolean pathsMatch(String path, ServletRequest request) &#123; String requestURI = this.getPathWithinApplication(request); String[] strings = path.split("=="); if (strings.length &lt;= 1) &#123; // 普通的 URL, 正常处理 return this.pathsMatch(strings[0], requestURI); &#125; else &#123; // 获取当前请求的 http method. String httpMethod = WebUtils.toHttp(request).getMethod().toUpperCase(); // 匹配当前请求的 http method 与 过滤器链中的的是否一致 return httpMethod.equals(strings[1].toUpperCase()) &amp;&amp; this.pathsMatch(strings[0], requestURI); &#125; &#125;&#125; 修改过滤器的 onAccessDenied 方法同样是上一步的类，重写 onAccessDenied 方法即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 当没有权限被拦截时: * 如果是 AJAX 请求, 则返回 JSON 数据. * 如果是普通请求, 则跳转到配置 UnauthorizedUrl 页面. */@Overrideprotected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException &#123; Subject subject = getSubject(request, response); // 如果未登录 if (subject.getPrincipal() == null) &#123; // AJAX 请求返回 JSON if (im.zhaojun.util.WebUtils.isAjaxRequest(WebUtils.toHttp(request))) &#123; if (log.isDebugEnabled()) &#123; log.debug("用户: [&#123;&#125;] 请求 restful url : &#123;&#125;, 未登录被拦截.", subject.getPrincipal(), this.getPathWithinApplication(request)); &#125; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("code", -1); im.zhaojun.util.WebUtils.writeJson(map, response); &#125; else &#123; // 其他请求跳转到登陆页面 saveRequestAndRedirectToLogin(request, response); &#125; &#125; else &#123; // 如果已登陆, 但没有权限 // 对于 AJAX 请求返回 JSON if (im.zhaojun.util.WebUtils.isAjaxRequest(WebUtils.toHttp(request))) &#123; if (log.isDebugEnabled()) &#123; log.debug("用户: [&#123;&#125;] 请求 restful url : &#123;&#125;, 无权限被拦截.", subject.getPrincipal(), this.getPathWithinApplication(request)); &#125; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("code", -2); map.put("msg", "没有权限啊!"); im.zhaojun.util.WebUtils.writeJson(map, response); &#125; else &#123; // 对于普通请求, 跳转到配置的 UnauthorizedUrl 页面. // 如果未设置 UnauthorizedUrl, 则返回 401 状态码 String unauthorizedUrl = getUnauthorizedUrl(); if (StringUtils.hasText(unauthorizedUrl)) &#123; WebUtils.issueRedirect(request, response, unauthorizedUrl); &#125; else &#123; WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED); &#125; &#125; &#125; return false;&#125; 重写完 pathsMatch 和 onAccessDenied 方法后，将这个类替换原有的 perms 过滤器的类： XML 方式：12345678910&lt;bean id="shiroFilter" class="im.zhaojun.shiro.RestShiroFilterFactoryBean"&gt; &lt;!-- 参数配置略 --&gt; &lt;property name="filters"&gt; &lt;map&gt; &lt;entry key="perms" value-ref="restAuthorizationFilter"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="restAuthorizationFilter" class="im.zhaojun.shiro.filter.RestAuthorizationFilter"/&gt; Bean 方式：123456789@Beanpublic ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new RestShiroFilterFactoryBean(); Map&lt;String, Filter&gt; filters = shiroFilterFactoryBean.getFilters(); filters.put("perms", new RestAuthorizationFilter()); // 其他配置略 return shiroFilterFactoryBean;&#125; 这里只改了 perms 过滤器，对于其他过滤器也是同样的道理，重写过滤器的 pathsMatch 和 onAccessDenied 方法，并覆盖原有过滤器即可。 附上面用到的工具类:1234567891011121314151617181920212223242526272829303132333435363738394041package im.zhaojun.util;import cn.hutool.json.JSONUtil;import com.alibaba.druid.support.json.JSONUtils;import org.springframework.boot.jackson.JsonComponent;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import java.io.PrintWriter;import java.util.Map;public class WebUtils &#123; /** * 是否是Ajax请求 */ public static boolean isAjaxRequest(HttpServletRequest request) &#123; String requestedWith = request.getHeader("x-requested-with"); return requestedWith != null &amp;&amp; "XMLHttpRequest".equalsIgnoreCase(requestedWith); &#125; /** * 输出JSON */ public static void writeJson(Object obj, ServletResponse response) &#123; PrintWriter out = null; try &#123; response.setCharacterEncoding("UTF-8"); response.setContentType("application/json; charset=utf-8"); out = response.getWriter(); out.write(JSONUtil.toJsonStr(obj)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (out != null) &#123; out.close(); &#125; &#125; &#125;&#125; 结语基本的过程就是这些，这是我在学习 Shiro 的过程中的一些见解，希望可以帮助到大家。具体应用的项目地址为：https://github.com/zhaojun1998/Shiro-Action，功能在不断完善中，代码可能有些粗糙，还请见谅。]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理 - 源码分析 - restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无限级菜单/权限树该如何设计]]></title>
    <url>%2Fpermission-tree%2F</url>
    <content type="text"><![CDATA[前言在开发中我们经常会遇到：导航菜单、部门菜单、权限树、评论等功能。 这些功能都有共同的特点： 有父子关系 可无限递归 我们以导航菜单为例, 我们将导航菜单设置为动态的, 即从动态加载菜单数据。 数据库设计适用于数据库存储的设计如下: 1234567create table `menus`( `id` int primary key auto_increment, `name` varchar(20) comment '菜单名称', `pid` int default 0 comment '父级 ID, 最顶级为 0', `order` int comment '排序, 序号越大, 越靠前') 前端渲染对于前端来说, 我们一般需要这种效果: 菜单配置页面: 对应的导航菜单: 常用的树形显示插件有: JsTree, zTree, Layui Tree, Bootstrap Tree View 等。 这些插件一般需要这两种格式: 基础格式:1234567891011121314151617181920212223242526[ &#123; "id": 1, "name": "权限管理", "pid": 0, "order": 1 &#125;, &#123; "id": 2, "name": "用户管理", "pid": 1, "order": 2 &#125;, &#123; "id": 3, "name": "角色管理", "pid": 1, "order": 3 &#125;, &#123; "id": 4, "name": "权限管理", "pid": 1, "order": 4 &#125;] 树形格式:12345678910111213141516171819202122232425262728293031[ &#123; "id": 1, "name": "权限管理", "pid": 0, "order": 1, "children": [ &#123; "id": 2, "name": "用户管理", "pid": 1, "order": 2, "children": [] &#125;, &#123; "id": 3, "name": "角色管理", "pid": 1, "order": 3, "children": [] &#125;, &#123; "id": 4, "name": "权限管理", "pid": 1, "order": 4, "children": [] &#125; ] &#125;] 有的插件这两种格式都支持, 而有些只支持树形结构, 但我们数据库查询出来的结果往往又是普通结构, 这时候我们就需要将普通格式转换成树形格式。 这个转换一般是在服务端进行(因为前端插件大多都是请求后台的一个 URL 来接收 JSON 数据, 没有提供加载数据后 - 渲染前的事件, 所以无法在前端完成转换.) 数据转换首先有 Java 实体类:1234567public class Menu &#123; private int id, private String name, private int pid // getter setter 略&#125; 数据库查询后的一般是在 List 中:1List&lt;Menu&gt; menus = xxxMapper.selectXXX(); 然后我们需要将这个 List 转换为树形结构, 首先定义一个树形结构的 VO 类：12345678public class MenuTreeVO &#123; private int id, private String name, private int pid, private List&lt;MenuVo&gt; children, // getter setter 略&#125; 转换工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package im.zhaojun.util;import im.zhaojun.model.vo.MenuTreeVO;import java.util.ArrayList;import java.util.List;public class TreeUtil &#123; /** * 所有待用"菜单" */ private static List&lt;MenuTreeVO&gt; all = null; /** * 转换为树形 * @param list 所有节点 * @return 转换后的树结构菜单 */ public static List&lt;MenuTreeVO&gt; toTree(List&lt;MenuTreeVO&gt; list) &#123; // 最初, 所有的 "菜单" 都是待用的 all = new ArrayList&lt;&gt;(list); // 拿到所有的顶级 "菜单" List&lt;MenuTreeVO&gt; roots = new ArrayList&lt;&gt;(); for (MenuTreeVO menuTreeVO : list) &#123; if (menuTreeVO.getParentId() == 0) &#123; roots.add(menuTreeVO); &#125; &#125; // 将所有顶级菜单从 "待用菜单列表" 中删除 all.removeAll(roots); for (MenuTreeVO menuTreeVO : roots) &#123; menuTreeVO.setChildren(getCurrentNodeChildren(menuTreeVO));; &#125; return roots; &#125; /** * 递归函数 * 递归目的: 拿到子节点 * 递归终止条件: 没有子节点 * @param parent 父节点 * @return 子节点 */ private static List&lt;MenuTreeVO&gt; getCurrentNodeChildren(MenuTreeVO parent) &#123; // 判断当前节点有没有子节点, 没有则创建一个空长度的 List, 有就使用之前已有的所有子节点. List&lt;MenuTreeVO&gt; childList = parent.getChildren() == null ? new ArrayList&lt;&gt;() : parent.getChildren(); // 从 "待用菜单列表" 中找到当前节点的所有子节点 for (MenuTreeVO child : all) &#123; if (parent.getMenuId().equals(child.getParentId())) &#123; childList.add(child); &#125; &#125; // 将当前节点的所有子节点从 "待用菜单列表" 中删除 all.removeAll(childList); // 所有的子节点再寻找它们自己的子节点 for (MenuTreeVO menuTreeVO : childList) &#123; menuTreeVO.setChildren(getCurrentNodeChildren(menuTreeVO)); &#125; return childList; &#125;&#125; 调用方式: 123456789101112131415// 从数据库获取List&lt;Menu&gt; menus = xxxMapper.selectXXX();// Menu 转为 MenuTreeVOList&lt;MenuTreeVO&gt; menuTreeVOS = new ArrayList&lt;&gt;();for (Menu menu : menus) &#123; MenuTreeVO menuTreeVO = new MenuTreeVO(); BeanUtils.copyProperties(menu, menuTreeVO); menuTreeVOS.add(menuTreeVO);&#125;// 调用转换方法xxxUtil.toTree(menuTreeVOS);// 通过 Json 或 ModelAndView 返回给前台. 附:模板引擎渲染有时我们会使用模板引擎来渲染菜单, 但由于菜单是树形结构的, 所以在模板引擎中单纯的使用 for 是无法完成无限极菜单的渲染的. 这里有一个很新奇的方法, 我以 thymeleaf 引擎为例: index.html 的导航部分:1234567&lt;div class="left-nav"&gt; &lt;div id="side-nav"&gt; &lt;ul id="nav"&gt; &lt;th:block th:include="public::menu($&#123;menus&#125;)"/&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; public.html 公共模板部分:123456789101112131415161718&lt;th:block th:fragment="menu(menus)"&gt; &lt;li th:each="menu:$&#123;menus&#125;"&gt; &lt;a href="javascript:;"&gt; &lt;i class="iconfont"&gt;&amp;#xe6b8;&lt;/i&gt; &lt;cite th:text="$&#123;menu.menuName&#125;"&gt;系统管理&lt;/cite&gt; &lt;i class="iconfont nav_right"&gt;&amp;#xe697;&lt;/i&gt; &lt;/a&gt; &lt;ul class="sub-menu"&gt; &lt;li th:each="child:$&#123;menu.children&#125;"&gt; &lt;a th:if="$&#123;#lists.isEmpty(child.children)&#125;" data-th-_href="$&#123;child.url&#125;" _href="users"&gt; &lt;i class="iconfont"&gt;&amp;#xe6a7;&lt;/i&gt; &lt;cite th:text="$&#123;child.menuName&#125;"&gt;用户管理&lt;/cite&gt; &lt;/a&gt; &lt;th:block th:unless="$&#123;#lists.isEmpty(child.children)&#125;" th:include="this::menu($&#123;child&#125;)" /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/th:block&gt; 基本逻辑就是使用 include 引用模板, 各种模板引擎都有这种功能, 然后判断当前节点有没有子节点, 有的话, 模板文件引用自身, 来完成递归. 结语上述代码是在开发一个 Shiro 的权限管理后台的时候的一些思路和代码, 完整的代码可以参考: https://github.com/zhaojun1998/Shiro-Action]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 进阶之从数据库读取过滤器链]]></title>
    <url>%2Fshiro-12%2F</url>
    <content type="text"><![CDATA[我们之前使用过滤器链都是在 XML 中手动添加和维护的，本章我们来介绍下如何从数据库读取这些过滤器配置，这样做的好处是便于维护，且可以通过程序来添加过滤器配置，因为我们只需要添加一条记录到数据库即可。 回顾下，之前我们是这样配置的： 12345678910111213141516171819&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;!-- 登录页面, 未认证时访问需要认证或授权的资源会自动跳转到此页面 --&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;!-- 登录成功页面 --&gt; &lt;property name="successUrl" value="/index.jsp"/&gt; &lt;!-- 登录后, 访问未授权的资源会跳转到此页面 --&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; /login.jsp = anon /login = anon /user.jsp = anyRoles[user, admin] /userList.jsp = perms[select:delete] /logout = logout /** = authc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 主要是 filterChainDefinitions 属性，现在我们将其修改为： 1&lt;property name="filterChainDefinitionMap" ref=""/&gt; 我们点开 ShiroFilterFactoryBean 的 filterChainDefinitionMap 属性来看下，它是 Map 类型的： 123public void setFilterChainDefinitionMap(Map&lt;String, String&gt; filterChainDefinitionMap) &#123; this.filterChainDefinitionMap = filterChainDefinitionMap;&#125; 这样我们就可以创建一个类，他从数据库读取权限数据组成一个 Map 类型作为返回值即可，这里我们用实例工厂来实现： 123456789101112import java.util.LinkedHashMap;public class FilterChainDefinitionMapBuilder &#123; public LinkedHashMap&lt;String, String&gt; buildFilterChainDefinitionMap() &#123; LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); // 这里根据自己使用的数据库查询, 将值 put 到 Map 中. return map; &#125;&#125; 使用 LinkedHashMap 的原因是为了保证插入顺序有序，具体连接数据库和查询代码这里就不在演示了，自行根据项目使用的 ORM 框架来实现。 最后的配置文件是这样的： 12345678910111213141516&lt;!-- shiro 过滤器, 要与 web.xml 中的 Filter Name 相同--&gt;&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;!-- 登录页面, 未认证时访问需要认证或授权的资源会自动跳转到此页面 --&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;!-- 登录成功页面 --&gt; &lt;property name="successUrl" value="/index.jsp"/&gt; &lt;!-- 登录后, 访问未授权的资源会跳转到此页面 --&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; &lt;property name="filterChainDefinitionMap" ref="filterChainDefinitionMap"/&gt;&lt;/bean&gt;&lt;bean id="filterChainDefinitionMap" factory-bean="filterChainDefinitionMapBuilder" factory-method="buildFilterChainDefinitionMap"/&gt;&lt;bean id="filterChainDefinitionMapBuilder" class="im.zhaojun.factory.FilterChainDefinitionMapBuilder"/&gt; 本章代码地址 : https://github.com/zhaojun1998/Premission-Study/tree/master/Permission-Shiro-12/]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 集成 Spring 之记住我]]></title>
    <url>%2Fshiro-11%2F</url>
    <content type="text"><![CDATA[我们经常在登陆网站时看到一个选项，就是 记住我、 n天内自动登陆。本章我们使用 Shiro 来实现这个功能。 首先需要在 spring-shiro.xml 中配置： 12345678910&lt;bean id="rememberMeManager" class="org.apache.shiro.web.mgt.CookieRememberMeManager"&gt; &lt;property name="cookie" ref="cookie"/&gt;&lt;/bean&gt;&lt;bean id="cookie" class="org.apache.shiro.web.servlet.SimpleCookie"&gt; &lt;!-- cookie 名称 --&gt; &lt;property name="name" value="rememberMe"/&gt; &lt;!-- cookie 过期时间 --&gt; &lt;property name="maxAge" value="86400"/&gt;&lt;/bean&gt; 并将 rememberMeManager 添加到 securityManager中： 1234&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="myRealm"/&gt; &lt;property name="rememberMeManager" ref="rememberMeManager"/&gt;&lt;/bean&gt; 在之前的章节中我们提到了过滤器链中的 user 过滤器，以及注解中的 @RequiresUser 都是用来表示已登陆或 rememberMe 状态可访问。 我们新建一个页面 remember.jsp，并为其配置 user 过滤器： remember.jsp 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;记住我&lt;/title&gt;&lt;/head&gt;&lt;body&gt; RememberMe Page&lt;/body&gt;&lt;/html&gt; 过滤器 1/remember.jsp = user 当然，还要通过表单的单选框来告诉 Shiro，当前用户是否使用 rememberMe 功能，修改后的login.jsp： 12345678910111213&lt;html&gt;&lt;body&gt;&lt;form action="login" method="post"&gt; username : &lt;input type="text" name="username"&gt; &lt;br&gt; password : &lt;input type="password" name="password"&gt; &lt;br&gt; rememberMe: &lt;input type="checkbox" name="rememberMe"&gt; &lt;br&gt; &lt;input type="submit" value="Login"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 并在 Controller 层接受后，将复选框选中结果配置给 Shiro： 12345678910111213@RequestMapping("login")@ResponseBodypublic String login(User user) &#123; Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword(), user.getRememberMe()); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; return e.getMessage(); &#125; return "login success";&#125; 一切配置完成后启动项目，登陆时勾选 rememberMe，然后关闭浏览器，重新打开，再访问 remember.jsp 看是否可以访问，并对比其他配置 authc 或需要授权的页面，是否可以访问。 其实他的原理就是通过 cookie 实现，勾选 remberMe 后登陆成功会给浏览器设置一个 cookie，以及其到期时间，请求页面时验证该 cookie 的内容是否是服务器颁发的，如果是则通过，不是则跳回登陆页面。 也可能你配置了 rememberMe 功能但未生效，也没有报错，那么可能是以下两种原因。 检查浏览器是否禁用了 Cookie 检查是否使用了注解 @RequiresUser并同时在过滤器链中配置了 /** = authc，原因是过滤器链的优先级高于 @RequiresUser，在 /** = authc 时，表示所有请求都要认证，所以还没有到注解的验证就已经被拦截并跳回到登陆页面了。 不过 rememberMe 功能要慎用，且过期时间不要设置太久，因为这样即使修改密码后，原先的 cookie 在过期之前还是可以使用的。还有一个问题是，rememberMe 状态下无法获取用户的 Session 信息，从而也会引发其他的问题。 本章代码地址 : https://github.com/zhaojun1998/Premission-Study/tree/master/Permission-Shiro-11/]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 集成 Spring 之注解]]></title>
    <url>%2Fshiro-10%2F</url>
    <content type="text"><![CDATA[前言集成 Spring 后我们通过过滤器链来配置每个 URL 需要的权限，但当配置多了以后就会不方便，而且只支持 URL 级别的配置。 好在 Shiro 提供了相应的注解用于权限控制，此处使用了 Spring MVC 来测试Shiro注解，当然 Shiro 注解不仅仅可以在 web 环境使用，在独立的JavaSE 中也是可以用的，此处只是以 web 为例了。 开启注解配置首先我们需要在 Spring Web 的配置文件 spring-web.xml 中加入以下内容来开启 Shiro 的注解支持 : 1234&lt;aop:config proxy-target-class="true"/&gt;&lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager"/&gt;&lt;/bean&gt; 简单演示接着我们就可以使用注解来配置权限： 123456789101112131415@RestControllerpublic class AuthorizationController &#123; @RequestMapping("/role1") @RequiresRoles("user") public String role1() &#123; return "success"; &#125; @RequestMapping("/role2") @RequiresRoles("admin") public String role2() &#123; return "success2"; &#125;&#125; 访问 role1 方法需要当前用户有 user 角色，role2 方法需要 admin 角色。 当验证失败时，会抛出 UnauthorizedException ，我们可以使用 Spring 的 ExceptionHandler 来进行异常处理： 1234@ExceptionHandler(UnauthorizedException.class)public String processUnauthorizedException(UnauthorizedException e) &#123; return e.getMessage();&#125; 更多注解当然不止有 @RequiresRoles 用来验证角色，Shiro 还提供了以下注解： @RequiresAuthentication验证用户是否登陆，等同于方法 subject.isAuthenticated() 。 @RequiresUser验证用户是否被 记忆，即登陆成功或 RememberMe 状态。等同于方法 : subject.isAuthenticated() 与 subject.isRemembered()。 @RequiresGuest仅未登录状态可访问，与 @RequiresUser 完全相反。 @RequiresPermissions验证是否具备权限，可通过参数 logical 来配置验证策略： 1234// 拥有 admin 或 user 角色即可@RequiresPermissions(logical = Logical.OR,value = &#123;"admin", "user"&#125;)// 需同时具备 admin 与 user 角色@RequiresPermissions(logical = Logical.AND,value = &#123;"admin", "user"&#125;) RequiresRoles 同样可以配置验证策略。 小结我们可以通过注解配置来更方便的实现权限配置，且这些方法不仅可以配置在 Controller 层，还可以在 Service 层，DAO 层等，只不过需要通过 IOC 容器来获取对象才能使用。 本章代码地址 : https://github.com/zhaojun1998/Premission-Study/tree/master/Permission-Shiro-10/]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 集成 Spring 之会话管理]]></title>
    <url>%2Fshiro-09%2F</url>
    <content type="text"><![CDATA[前言Shiro 提供了完整的会话管理功能，可以在不依赖底层容器，不仅可以在 WEB 环境下使用 Session，还可以在 JavaSE 环境下使用，且提供了会话管理，会话事件监听，会话持久化，过期支持。 会话操作所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。 获取 Session 方法： 12Subject subject = SecurityUtils.getSubject();Session session = subject.getSession(); Session 常用方法： 12345678910111213session.getId(); // 会话 ID, 唯一标识session.getHost(); // 获取当前 Subject 的主机地址session.getTimeout(); // 获取 Session 超时时间session.setTimeout(long time); // 设置 Session 超时时间session.getStartTimestamp(); // 会话创建时间session.getLastAccessTime(); // 最后活跃时间session.touch(); // 更新会话session.stop(); // 销毁会话// 当然也支持 getAttribute() 和 setAttribute() 方法 会话管理器会话管理器管理应用中所有 Subject 的会话的创建、维护、删除、失效、验证等工作。 Shiro提供了三个默认实现： DefaultSessionManager：DefaultSecurityManager 使用的默认实现，用于JavaSE环境； ServletContainerSessionManager：DefaultWebSecurityManager使用的默认实现，用于Web环境，其直接使用Servlet容器的会话； DefaultWebSessionManager：用于Web环境的实现，可以替代ServletContainerSessionManager，自己维护着会话，直接废弃了Servlet容器的会话管理。 会话监听器会话监听器用于监听会话创建、过期及停止事件： 123456789101112131415161718192021222324252627282930package im.zhaojun.session.listener;import org.apache.log4j.Logger;import org.apache.shiro.session.Session;import org.apache.shiro.session.SessionListener;import org.springframework.stereotype.Component;/** * Shiro 会话监听器 */@Componentpublic class MySessionListener implements SessionListener &#123; private static final Logger logger = Logger.getLogger(MySessionListener.class); @Override public void onStart(Session session) &#123; logger.info("create session : " + session.getId()); &#125; @Override public void onStop(Session session) &#123; logger.info("session stop : " + session.getId()); &#125; @Override public void onExpiration(Session session) &#123; logger.info("session expiration : " + session.getId()); &#125;&#125; 当然，如果你只想监听某个事件，可以继承自 SessionListenerAdapter： 123456789101112131415161718192021package im.zhaojun.session.listener;import org.apache.log4j.Logger;import org.apache.shiro.session.Session;import org.apache.shiro.session.SessionListener;import org.apache.shiro.session.SessionListenerAdapter;import org.springframework.stereotype.Component;/** * Shiro 会话监听器 */@Componentpublic class MySessionListener2 extends SessionListenerAdapter &#123; private static final Logger logger = Logger.getLogger(MySessionListener2.class); @Override public void onStart(Session session) &#123; logger.info("create session : " + session.getId()); &#125;&#125; 然后将会话监听器配置到 sessionManager 中，在将 sessionManager 配置到 securityManager： 123456789&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="myRealm"/&gt; &lt;property name="cacheManager" ref="redisCacheManager"/&gt; &lt;property name="sessionManager" ref="sessionManager"/&gt;&lt;/bean&gt;&lt;bean id="sessionManager" class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager"&gt; &lt;property name="sessionListeners" ref="mySessionListener"/&gt;&lt;/bean&gt; 会话持久化/存储Shiro 提供 SessionDAO 用于会话的 CRUD，我们可以用它来从 Redis 中增删改查 Session 信息，只需要继承自 SessionDAO： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package im.zhaojun.session;import im.zhaojun.util.JedisUtil;import org.apache.log4j.Logger;import org.apache.shiro.session.Session;import org.apache.shiro.session.UnknownSessionException;import org.apache.shiro.session.mgt.eis.AbstractSessionDAO;import org.springframework.stereotype.Component;import org.springframework.util.SerializationUtils;import javax.annotation.Resource;import java.io.Serializable;import java.util.Collection;import java.util.HashSet;@Componentpublic class RedisSessionDAO extends AbstractSessionDAO &#123; private static final Logger logger = Logger.getLogger(RedisSessionDAO.class); @Resource private JedisUtil jedisUtil; private final String SHIRO_SESSION_PREFIX = "shiro-session:"; @Override protected Serializable doCreate(Session session) &#123; Serializable sessionId = generateSessionId(session); assignSessionId(session, sessionId); saveSession(session); logger.info("sessionDAO doCreate : " + session.getId()); return sessionId; &#125; @Override protected Session doReadSession(Serializable sessionId) &#123; if (sessionId == null) &#123; return null; &#125; byte[] key = getKeyBytes(sessionId.toString()); byte[] value = jedisUtil.get(key); return (Session) SerializationUtils.deserialize(value); &#125; @Override public void update(Session session) throws UnknownSessionException &#123; saveSession(session); &#125; @Override public void delete(Session session) &#123; logger.info("session delete : " + session.getId()); if (session != null &amp;&amp; session.getId() != null) &#123; byte[] key = getKeyBytes(session.getId().toString()); jedisUtil.del(key); &#125; &#125; @Override public Collection&lt;Session&gt; getActiveSessions() &#123; Collection&lt;byte[]&gt; keys = jedisUtil.getKeysByPrefix(SHIRO_SESSION_PREFIX); Collection&lt;Session&gt; sessions = new HashSet&lt;&gt;(); if (sessions.isEmpty()) &#123; return sessions; &#125; for (byte[] key : keys) &#123; Session session = (Session) SerializationUtils.deserialize(jedisUtil.get(key)); sessions.add(session); &#125; return sessions; &#125; private byte[] getKeyBytes(String key) &#123; return (SHIRO_SESSION_PREFIX + key).getBytes(); &#125; private void saveSession(Session session) &#123; if (session != null &amp;&amp; session.getId() != null) &#123; byte[] key = getKeyBytes(session.getId().toString()); byte[] value = SerializationUtils.serialize(session); jedisUtil.set(key, value); jedisUtil.expire(key, 600); &#125; &#125;&#125; 这里和上一章，授权数据的缓存很相像，那里是对授权数据的增删改查，这里是对 Session 数据的增删改查。 然后将其配置到 sessionManager 中： 1234&lt;bean id="sessionManager" class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager"&gt; &lt;property name="sessionListeners" ref="mySessionListener"/&gt; &lt;property name="sessionDAO" ref="redisSessionDAO"/&gt;&lt;/bean&gt; 小结我们可以使用 Shiro 提供的这一系列操作会话的工具来完成很多功能，如单点登陆，单设备登陆，踢出用户，获取所有登陆用户等信息。 本章代码地址 : https://github.com/zhaojun1998/Premission-Study/tree/master/Permission-Shiro-09/]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 集成 Spring 之授权缓存]]></title>
    <url>%2Fshiro-08%2F</url>
    <content type="text"><![CDATA[前言在 手撸 Java Web RBAC 权限管理 中，我们自己实现了一个简易的 RBAC 权限管理框架，且我们也提到了一些缺陷，其中一点就是 : 每次请求需要授权的页面都会去数据库查询此用户对应的权限数据和角色数据，太耗费资源，应该进行缓存。 本章我们就来讲讲如何将 Shiro 中的授权数据缓存到 Redis 中。 APIShiro 为授权数据的缓存提供了两个借口，一个是 CacheManager，一个是 Cache。 根据这两个接口，我们完全可以将授权数据缓存到任何地方，包括 redis、ehcache 、内存等。 Redis既然我们要缓存到 Redis 中，我们需要搭建 Redis 环境，并导入 Redis 工具类： 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 新建配置文件 spring-redis.xml： 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="jedisPool" class="redis.clients.jedis.JedisPool"&gt; &lt;!-- Jedis 配置信息 --&gt; &lt;constructor-arg name="poolConfig" ref="jedisPoolConfig"/&gt; &lt;!-- Redis URL --&gt; &lt;constructor-arg name="host" value="127.0.0.1"/&gt; &lt;!-- Redis 端口--&gt; &lt;constructor-arg name="port" value="6379"/&gt; &lt;!-- Redis 密码 --&gt; &lt;!--&lt;constructor-arg value=""/&gt;--&gt; &lt;/bean&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="500"/&gt; &lt;!-- 最大闲置 --&gt; &lt;property name="maxIdle" value="100"/&gt; &lt;!-- 最小闲置 --&gt; &lt;property name="minIdle" value="10"/&gt; &lt;!-- 最大等待 --&gt; &lt;property name="maxWaitMillis" value="5000"/&gt; &lt;!-- 可以获取 --&gt; &lt;property name="testOnBorrow" value="true"/&gt; &lt;/bean&gt;&lt;/beans&gt; Cache我们来创建一个 RedisCache 继承自 org.apache.shiro.cache.Cache，来实现它的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package im.zhaojun.cache;import im.zhaojun.util.JedisUtil;import org.apache.log4j.Logger;import org.apache.shiro.cache.Cache;import org.apache.shiro.cache.CacheException;import org.springframework.stereotype.Component;import org.springframework.util.SerializationUtils;import javax.annotation.Resource;import java.util.Collection;import java.util.Set;@Componentpublic class RedisCache&lt;K, V&gt; implements Cache&lt;K, V&gt; &#123; private static final Logger logger = Logger.getLogger(RedisCache.class); @Resource private JedisUtil jedisUtil; private final String CACHE_PREFIX = "shiro-cache:"; private byte[] getKeyBytes(K k) &#123; return (CACHE_PREFIX + k).getBytes(); &#125; @Override public V get(K k) throws CacheException &#123; logger.info("从 Redis 中读取授权信息..."); byte[] key = getKeyBytes(k); byte[] value = jedisUtil.get(key); if (value != null) &#123; return (V) SerializationUtils.deserialize(value); &#125; return null; &#125; @Override public V put(K k, V v) throws CacheException &#123; byte[] key = getKeyBytes(k); byte[] value = SerializationUtils.serialize(v); jedisUtil.set(key, value); jedisUtil.expire(key, 600); return v; &#125; @Override public V remove(K k) throws CacheException &#123; byte[] key = getKeyBytes(k); byte[] value = jedisUtil.get(key); jedisUtil.del(key); if (value != null) &#123; SerializationUtils.deserialize(value); &#125; return null; &#125; @Override public void clear() throws CacheException &#123; jedisUtil.delKeysByPrefix(CACHE_PREFIX); &#125; @Override public int size() &#123; return jedisUtil.getKeysByPrefix(CACHE_PREFIX).size(); &#125; @Override public Set&lt;K&gt; keys() &#123; return (Set&lt;K&gt;) jedisUtil.getKeysByPrefix(CACHE_PREFIX); &#125; @Override public Collection&lt;V&gt; values() &#123; return jedisUtil.getValuesByPrefix(CACHE_PREFIX); &#125;&#125; 其中没什么难点，只是对 redis 的基本增删改查操作，由于是存储到 redis 中，所以我们为缓存数据的 key 添加了前缀，以便再次获取。 CacheManager我们创建一个 RedisCacheManager 类来继承自 org.apache.shiro.cache.AbstractCacheManager，当然你也可以直接继承自 org.apache.shiro.cacheCacheManager： 12345678910111213141516171819package im.zhaojun.cache;import org.apache.shiro.cache.Cache;import org.apache.shiro.cache.CacheException;import org.apache.shiro.cache.AbstractCacheManager;import javax.annotation.Resource;@Componentpublic class RedisCacheManager extends AbstractCacheManager &#123; @Resource private RedisCache redisCache; @Override protected Cache createCache(String s) throws CacheException &#123; return redisCache; &#125;&#125; 这里在 createCache() 方法中返回我们的自定义 RedisCache 对象即可。 Spring然后我们将 RedisCacheManager 配置到 securityManager 中： 1234&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="myRealm"/&gt; &lt;property name="cacheManager" ref="redisCacheManager"/&gt;&lt;/bean&gt; 以及将 spring-redis.xml 配置到 web.xml 中： 12345678&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:spring.xml, classpath:spring-shiro.xml, classpath:spring-redis.xml &lt;/param-value&gt;&lt;/context-param&gt; Test然后我们分别在 Realm 的 doGetAuthorizationInfo 方法和 RedisCache 的 get 方法中分别打印一条日志，看何时会访问数据库，何时会访问 Redis 缓存的数据。 首先是未认证的情况下，访问需要权限的的页面，不会输出任何信息，因为需要认证后，才会根据认证信息去获取授权现象，没有认证时，会直接拦截。 认证之后，访问需要授权的页面，会输入如下信息： 12im.zhaojun.cache.RedisCache 15:09:14,015 INFO RedisCache:30 - 从 Redis 中读取授权信息...im.zhaojun.realm.MyRealm 15:09:14,016 INFO MyRealm:23 - 从数据库中读取授权信息... 由此可见，Shiro 会先去 Redis 中取数据，如果 Redis 中没有，再去 Realm(数据库) 中取。然后再次访问这个页面，输入： 1im.zhaojun.cache.RedisCache 15:11:13,351 INFO RedisCache:30 - 从 Redis 中读取授权信息... 因为缓存中已经有了，就不再去数据库中查询了。 小结其实频繁从 Redis 中读取也是比较浪费资源的， Redis 的连接同样宝贵，最好的办法还是直接存储在内存中，但也是各有利弊，需要根据实际项目来决定使用哪种方案。 放到 Redis 的好处是：可以用来做跨项目/机器的数据缓存，可以集群，持久化等。 放到内存的好处是：速度快，使用方便快捷。 但使用这种缓存还有一个比较重要的事情，就是当数据库中的授权数据发生修改时，也要记得刷新缓存中的数据，不然会出现数据错乱，实现方式可以通过直接覆盖缓存，消息队列通知等方式，需要根据不同项目来选区不同方式，由于篇幅原因这里不再展开讲了。 本章代码地址 : https://github.com/zhaojun1998/Premission-Study/tree/master/Permission-Shiro-08/]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 集成 Spring 之过滤器]]></title>
    <url>%2Fshiro-07%2F</url>
    <content type="text"><![CDATA[前言在之前 Shiro 集成 Spring 这一章中我们简单使用了 shiroFilter 中的 filterChainDefinitions 来做 认证 和 授权 的拦截，其实还有许多过滤器，可以做各种各样的拦截，并且 Shiro 还提供了接口来让我们自定义过滤器。 身份认证相关anon例：/admins/**=anon，没有参数，表示可以匿名使用。 authc例：/admins/user/**=authc，没有参数，表示需要认证(登录)才能使用。 authcBasic例：/admins/user/**=authcBasic，没有参数，表示 httpBasic 认证。 user例：/admins/user/**=user ，没有参数，表示用户已登陆或 rememberMe 状态可访问。 logout例：/logout=logout，没有参数，注销当前登陆用户，成功后会重定向地址到 /。 授权相关roles例：/admins/user/**=roles[admin]，参数可以写多个，用逗号分割，当有多个参数时，例如 admins/user/**=roles[admin, guest]，每个参数通过才算通过，相当于 hasAllRoles() 方法。 perms例：/admins/user/**=perms[user:add:*]，参数可以写多个，用逗号分割，如：/admins/user/**=perms[user:add:*, user:modify:*]，当有多个参数时必须每个参数都通过才通过，想当于 isPermitedAll() 方法。 port例： /admins/user/**=port[8081]，单个参数，当请求的 url 的端口不是 8081 时重定向到 schemal://hostName:8081?queryString, 也就是说，除了端口，其他东西都会保留。 rest例：/admins/user/**=rest[user]，根据请求的方法，相当于 /admins/user/**=perms[user:method]，其中method为post，get，delete等。 ssl例：/admins/user/**=ssl 没有参数，表示安全的 url 请求，协议为 https，其实也等同于 /admin/user/**=port[443]，即重定向到 443 端口。 自定义过滤器以 roles 过滤器为例：/admin/page1= roles[&quot;admin, user&quot;] ，表示 /admin/page1 这个页面必须需要用户同时具备 admin 与 user 角色才可访问。 我们开发一个自定义的过滤器，判定需要 admin 或 user 可访问。 1234567891011121314151617181920212223242526package im.zhaojun.filter;import org.apache.shiro.subject.Subject;import org.apache.shiro.web.filter.authz.AuthorizationFilter;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class AnyRolesFilter extends AuthorizationFilter &#123; @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123; Subject subject = this.getSubject(request, response); String[] rolesArray = (String[]) ((String[]) mappedValue); if (rolesArray != null &amp;&amp; rolesArray.length != 0) &#123; for (String role : rolesArray) &#123; if (subject.hasRole(role)) &#123; return true; &#125; &#125; &#125; else &#123; return true; &#125; return false; &#125;&#125; 注：这里用到了 ServletRequest 和 ServletResponse 类，所以还需要导入相应的库： 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 然后将其配置到 IOC 容器中： 1&lt;bean id="anyRolesFilter" class="im.zhaojun.filter.AnyRolesFilter"/&gt; 最后为其分配别名，并添加到过滤器链中： 123456789101112131415161718&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;!-- 略 --&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; /login.jsp = anon /login = anon /user.jsp = anyRoles[user, admin] /userList.jsp = perms[select:delete] /logout = logout /** = authc &lt;/value&gt; &lt;/property&gt; &lt;property name="filters"&gt; &lt;map&gt; &lt;entry key="anyRoles" value-ref="anyRolesFilter"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 我们分别将 /user.jsp 设为 roles[user, admin] 和 anyRoles[user, admin]。 目前 Relam 中的用户 zhao - 123456 仅具备 user 角色，所以可以分别测试出，anyRoles 过滤的页面可以正常访问，而 roles 过滤器的内容因未同时具备 user 与 admin 角色而被拦截，跳转到未授权页面。 通配符上面的示例中，我们还用到了 ** 做通配符，其实还有几个通配符： ?：匹配一个字符，如 /admin? 可以匹配 /admin1、/admin2，但不能匹配 /admin。 *：匹配零个或一个或多个字符，如 /admin* 可以匹配 /admin、/admin1、/admin123，但不能匹配 /admin/123。 **：匹配零个或多个路径，如 /admin/** 可以匹配 /admin、/admin/a/b/c。 本章代码地址 : https://github.com/zhaojun1998/Premission-Study/tree/master/Permission-Shiro-07/]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 集成 Spring 之加密]]></title>
    <url>%2Fshiro-06%2F</url>
    <content type="text"><![CDATA[本章我们来讲解，如果使用 Shiro 集成 Spring 后，使用加密功能。本章基础代码为上一章 : Shiro 集成 Spring 中的代码。 我们这里演示使用 md5 散列算法进行加密, 并用 TestSalt 作为盐。 首先导入上一章的代码，然后修改 spring-shiro.xml ，添加内容: 123&lt;bean id="credentialsMatcher" class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"&gt; &lt;property name="hashAlgorithmName" value="md5" /&gt;&lt;/bean&gt; 然后将此凭证匹配器 credentialsMatcher 注入到 Realm 中 : 123&lt;bean id="myRealm" class="im.zhaojun.realm.MyRealm"&gt; &lt;property name="credentialsMatcher" ref="credentialsMatcher"/&gt;&lt;/bean&gt; 并在 Realm 中的 doGetAuthenticationInfo 方法里添加盐的配置 : 12345678910111213@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println("MyRealm doGetAuthenticationInfo..."); String username = (String) authenticationToken.getPrincipal(); User user = selectUserByUserName(username); if (user == null) &#123; throw new UnknownAccountException("当前账户不存在"); &#125; return new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), ByteSource.Util.bytes("TestSalt"), super.getName());&#125; 既然为 Relam 配置了凭证匹配器，那么就应该把我们存储的密码也进行加密，原始我们的密码为 123456，这里我们使用 md5 散列算法进行加密，并使用 TestSalt 作为盐 : 12345678public class GenerateHash &#123; public static void main(String[] args) &#123; Md5Hash md5Hash = new Md5Hash("123456", ByteSource.Util.bytes("TestSalt")); System.out.println(md5Hash.toString()); &#125;&#125;// 输出结果为 e5f728a966d050296c428290c9160dda 然后我们将 Realm 中获取的密码改为加密后的值 e5f728a966d050296c428290c9160dda : 123456private User selectUserByUserName(String username) &#123; if ("zhao".equals(username)) &#123; return new User(username, "e5f728a966d050296c428290c9160dda"); &#125; return null;&#125; 同上一章，运行项目，进行登陆测试，即可检验结果。 本章代码地址 : https://github.com/zhaojun1998/Premission-Study/tree/master/Permission-Shiro-06/]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 集成 Spring]]></title>
    <url>%2Fshiro-05%2F</url>
    <content type="text"><![CDATA[前言本章我们来学习 Shiro 集成 Spring，即在 Web 环境下如何使用 Shiro 来进行权限控制。 本章所需知识： Shiro 认证 &amp;&amp; 授权 Spring、SpringMVC 基础环境搭建引入依赖1234567891011121314151617181920212223242526&lt;!-- Spring MVC 依赖包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Shiro 依赖包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Log4j 日志依赖包 --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;!-- SLF4J 与 Log4j 适配包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt; web.xml123456789101112131415161718192021222324&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:spring.xml, classpath:spring-shiro.xml &lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-web.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 比较常见的 Spring 配置，这里就不过多介绍了。我们需要 3 个配置文件，分别为 spring.xml, spring-web.xml, spring-shiro.xml。 我们暂时只需要配置 spring-web.xml, spring-shiro.xml 即可 (spring.xml 文件也需要创建，但不需要配置东西)。 spring-web.xml123456789101112&lt;context:component-scan base-package="im.zhaojun.controller"/&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;constructor-arg value="UTF-8" /&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;&lt;mvc:default-servlet-handler/&gt; spring-shiro.xml之前我们都是手工 new 一个 DefaultSecurityManager ，但既然用到了 Spring，就将交由 Spring 容器来管理 : 123456789101112131415161718192021222324252627&lt;!-- shiro 过滤器, 要与 web.xml 中的 Filter Name 相同--&gt;&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;!-- 登录页面, 未认证时访问需要认证或授权的资源会自动跳转到此页面 --&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;!-- 登录成功页面 --&gt; &lt;property name="successUrl" value="/index.jsp"/&gt; &lt;!-- 登录后, 访问未授权的资源会跳转到此页面 --&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; /login.jsp = anon /login = anon /user.jsp = roles[user] /admin.jsp = roles[admin] /userList.jsp = perms[select] /** = authc &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="myRealm"/&gt;&lt;/bean&gt;&lt;!-- 自定义 Relam --&gt;&lt;bean id="myRealm" class="im.zhaojun.realm.MyRealm"/&gt; securityManager 和自定义 Realm 的配置很容易理解，但 shiroFilter 是个啥东西呢？ 其实他是 Shiro 的权限过滤器，用来在 web 环境下对权限进行过滤，既然是一个 Filter，显然我们还需要在 web.xml 中增加 Shiro 的 Filter 配置: 12345678910111213&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注意：这里的 filter-name 一定要与 spring-shiro.xml 中我们配置的对应的 bean 的名称相同。在此示例中均为 ：shiroFilter。 这里还有一个 filterChainDefinitions 表示的是过滤器链，即从上到下以此判断，直到获取到当前请求资源的权限。 此处我们将 /login.jsp 和 /login 配置成 anon，表示的是可以匿名访问。 user.jsp 配置为 roles[user]， 表示的是需要 user 角色可以访问。admin.jsp 配置为 roles[admin]， 表示的是需要 admin 角色可以访问。 userList.jsp 配置为 perms[select]，表示的是需要 select 权限才可访问。 /** 配置为 authc 表示的是所有页面都需要认证(登录)后才可访问。 当然还有更多的权限通配符，以及自定义权限通配符，我们会在后面的章节讲到 前端页面index.jsp12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Index Page&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; login.jsp1234567891011&lt;html&gt;&lt;body&gt;&lt;form action="login" method="post"&gt; username : &lt;input type="text" name="username"&gt; &lt;br&gt; password : &lt;input type="password" name="password"&gt; &lt;br&gt; &lt;input type="submit" value="Login"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; user.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;User Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;User Page&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; admin.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Admin Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Admin Page&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; userList.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;UserList Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;UserList Page&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 后端代码MyRealm12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package im.zhaojun.realm;import im.zhaojun.pojo.User;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import java.util.HashSet;import java.util.Set;/** * 自定义 Relam */public class MyRealm extends AuthorizingRealm &#123; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println("MyRealm doGetAuthorizationInfo..."); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); // 拥有 admin 角色 Set&lt;String&gt; roles = new HashSet&lt;&gt;(); roles.add("admin"); authorizationInfo.setRoles(roles); // 拥有权限 Set&lt;String&gt; permissions = new HashSet&lt;&gt;(); permissions.add("select"); authorizationInfo.setStringPermissions(permissions); return authorizationInfo; &#125; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println("MyRealm doGetAuthenticationInfo..."); String username = (String) authenticationToken.getPrincipal(); User user = selectUserByUserName(username); if (user == null) &#123; throw new UnknownAccountException("当前账户不存在"); &#125; return new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), super.getName()); &#125; /** * 模拟查询数据库, 假设数据库只有 zhao - 123456 这条数据 * @param username 用户名 * @return 查询到的用户 */ private User selectUserByUserName(String username) &#123; if ("zhao".equals(username)) &#123; return new User(username, "123456"); &#125; return null; &#125;&#125; 当前只有一个用户，账户为 zhao， 密码为 123456。且拥有 admin 角色和 select 权限。 Controller123456789101112131415161718192021222324252627282930package im.zhaojun.controller;import im.zhaojun.pojo.User;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.subject.Subject;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * 登录 Controller */@Controllerpublic class LoginController &#123; @RequestMapping("login") @ResponseBody public String login(User user) &#123; Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword()); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; return e.getMessage(); &#125; return "login success"; &#125;&#125; 登录成功，返回 login success，登录失败则返回对应的异常信息。 测试过滤器基本测试启动 web 服务，默认情况下会访问 index.jsp，但我们启动启动项目后自动跳转到了 login.jsp，且手动访问 index.jsp 页面也会自动跳转到 login.jsp。 原因是因为我们在 filterChainDefinitions 过滤器链中仅为 login.jsp 与 login 配置了可匿名访问，而 index.jsp 这上述配置中的是需要认证后才可访问。 由此可见 filterChainDefinitions，过滤器链是正常的。 认证/登录测试认证失败先来试试用户名错误 (使用 admin, 123456 来进行登录)，返回结果为 当前账户不存在，因为我们在 Realm 中抛出了 UnknownAccountException 异常，并设置了相应的 message，所以在 controller 中捕获到了异常并返回给了页面。 再来试试密码错误 (使用 zhao, 123456 来进行登录)，返回结果为 Submitted credentials for token [org.apache.shiro.authc.UsernamePasswordToken - zhao, rememberMe=false] did not match the expected credentials.。 认证成功使用正常的账号密码进行登录，返回结果为 login success。 由此可见认证成功和失败的功能是正常的。 授权测试角色我们在过滤器链中关于角色的配置有：/user.jsp = roles[user] 和 /admin.jsp = roles[admin]。下面测试，假设以账号是 zhao 为例 (具备 user 角色)： 未登录情况下：访问 user.jsp 会跳转到登录页面。 已登录 zhao 且具备相应的角色：可以正常访问 user.jsp。 已登录 zhao 且未具备相应的角色：访问 admin.jsp会跳转到 unauthorized.jsp。 权限我们在过滤器链中关于权限的配置有：/userList.jsp = perms[select]。下面测试，假设以账号是 zhao 为例 (具备 select 权限)： 未登录情况下：访问 userList.jsp 会跳转到登录页面。 已登录 zhao 且具备相应的权限：可以正常访问 userList.jsp。 已登录 zhao 且未具备相应的权限：和不具备角色一样会跳转到 unauthorized.jsp。 缓存测试可能细心的朋友会注意到我在 MyRealm 中的 doGetAuthorizationInfo() 和 doGetAuthenticationInfo() 分别加了一条输出语句，会有以下效果： 认证时会触发 doGetAuthenticationInfo 中的输出语句，证明每次登陆都会调用该方法。 授权时同样会触发 doGetAuthorizationInfo 中的输出语句，且每次授权也需要调用此方法一次。 那么我们来考虑一下缓存问题： 认证就不用说了，涉及到的查询就一条，根据用户名返回用户信息即可，没必要进行缓存。 但授权却比较麻烦，因为授权时我们一般都会去调用数据库来查询其用户所拥有的角色和权限，往往这都会涉及到多表查询。所以我们是否可以将授权数据缓存起来呢？应该如何进行缓存？缓存后角色或权限数据修改了怎么办？这里留下一个悬念，后面的章节中我们会讲到 Shiro 的缓存模块来完善缓存功能。 本章代码地址：https://github.com/zhaojun1998/Premission-Study/tree/master/Permission-Shiro-05/]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DigitalOcean 挂载 volume 硬盘]]></title>
    <url>%2Fdigitalocean-mount-volume%2F</url>
    <content type="text"><![CDATA[前言DigitalOcean 的默认硬盘容量只有 25G，但 DigitalOcean 已经在部分服务器区域增加了 volume 的特性，大大方便了用户的存储需求，以下是我的试用记录，系统为 CentOS7。 挂载 首先需要在 DigitalOcean 控制台为机器添加一个 volume。 连接机器并切换到 root 用户 查看当前机器所添加的 volume。 12345cd /dev/disk/by-id &amp;&amp; ll## 输出:## lrwxrwxrwx 1 root root 9 Aug 15 10:30 scsi-0DO_Volume_test -&gt; ../../sda## 可得知 volume 名称为 : scsi-0DO_Volume_test 格式化 volume 为 ext4 格式。 123sudo mkfs.ext4 -F /dev/disk/by-id/scsi-0DO_Volume_test## 这里的路径要改为你的 volume 路径 创建挂载点 1sudo mkdir -p /mnt/volume1 进行挂载 1sudo mount -o discard,defaults /dev/disk/by-id/scsi-0DO_Volume_test /mnt/volume1 查看挂载后的状态 1234567891011df -h## 输出:# Filesystem Size Used Avail Use% Mounted on# devtmpfs 473M 0 473M 0% /dev# tmpfs 496M 16K 496M 1% /dev/shm# tmpfs 496M 13M 484M 3% /run# tmpfs 496M 0 496M 0% /sys/fs/cgroup# /dev/vda1 25G 3.5G 22G 14% /# /dev/sda 99G 0G 99G 0% /mnt/volume1# tmpfs 100M 0 100M 0% /run/user/0 配置开启自动挂载 1echo /dev/disk/by-id/scsi-0DO_Volume_test /mnt/volume1 ext4 defaults,nofail,discard 0 0 | sudo tee -a /etc/fstab 移除 卸载 volume: 1umount /mnt/volume1 移除自动挂载： 123vi /etc/fstab# 编辑这个文件，将刚才开机自动挂载的代码删除 在 DigitalOcean 管理界面中从关联的机器上删除这个 volume。 扩容 在 DigitalOcean 管理界面中找到这台机器对应的 volume，resize 至需要的大小，如 500G。 以 root 身份执行: 1resize2fs /dev/disk/by-id/scsi-0DO_Volume_test 使用 df -h 命令重新查看磁盘状态。]]></content>
      <tags>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 加密]]></title>
    <url>%2Fshiro-04%2F</url>
    <content type="text"><![CDATA[加密安全总是最重要的，对于用户的数据，我们一般都不会以原密码明文保存，而是经过加密后保存。 比较常见的是，当注册时使用 MD5 散列算法对初始密码处理后存入数据库，而后每次登陆请求，对用户输入的密码也进行 MD5 散列后与数据库中的散列后的密码进行匹配，已达到加密的目的。 基本使用MD5 加密Shiro 对加密处理也提供了相应的 API，老规矩，先导入依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 先来试试最简单的，将密码进行 md5 散列后输出结果： 12345678@Testpublic void testSimpleEncryption() &#123; String password = "123456"; Md5Hash md5Hash = new Md5Hash(password); System.out.println(md5Hash.toString());&#125;// output result: e10adc3949ba59abbe56e057f20f883e 加盐但上面这种加密其实安全性也不高，因为可以建立一个 密码 - hash 对应表，根据存储的海量数据，对 md5 进行”反解密”，如我们通过网站 : ，将密文输入进去，即可 “反解密”。 这时候就需要盐的存在，即我们对原始密码，加一些佐料：盐。 如刚才我们的密码 123456，盐为 ShiroStudy，我们可以将盐加入到密码前或密码后，结果就是: 123456ShiroStudy，这时再进行 md5 加密： 123456789@Testpublic void testSlatEncryption() &#123; String password = "123456"; String slat = "ShiroStudy"; Md5Hash md5Hash = new Md5Hash(password, ByteSource.Util.bytes(slat)); System.out.println(md5Hash.toString());&#125;// output result : ac7351ab94f40504aab7ac7fdf4ddad3 Md5Hash(source, slat) 构造函数的第二个参数就是盐，但他需要的是 ByteSource 类型的盐，所以我们需要将字符串类型的盐通过他的工具类转换成 ByteSource 类型，即：ByteSource.Util.bytes(slat)。 这次我们再去尝试 “反解密” : 集成 Relam使用加密后，我们需要告诉 Relam，我们使用了哪种加密算法。 首先自定义定义 Relam： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package im.zhaojun.realm;import im.zhaojun.pojo.User;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.util.ByteSource;import java.util.HashSet;import java.util.Set;/** * 自定义 Realm, 使用了加密, 盐 */public class MyCustomRealm extends AuthorizingRealm &#123; /** * 根据用户凭证查询所用拥有的角色和权限 * @param principalCollection 用户凭证 * @return 返回授权信息，包含所拥有的角色和权限 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; // 略 &#125; /** * 根据用户提交的凭证查询是否具有这个用户 (这里不判断密码是否正确) * @param authenticationToken 用户凭证 (账户密码) * @return 相应的用户信息 * @throws AuthenticationException 当用户不存在或具备其他状态, 如被锁定, 等状态会抛出相应的异常 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; // 这个方法也可以使用 DAO 层的方法来查询数据库，返回 user 对象。 User user = selectUserByUserName((String) authenticationToken.getPrincipal()); if (user == null) &#123; throw new UnknownAccountException("账号不存在"); &#125; // 告诉 Relam, 校验密码时需要加的盐. ByteSource slat = ByteSource.Util.bytes("ShiroStudy"); return new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), slat, super.getName()); &#125; private Set&lt;String&gt; selectPermissionsByUserName(String username) &#123; // 略 &#125; private Set&lt;String&gt; selectRolesByUserName(String username) &#123; // 略 &#125; private User selectUserByUserName(String username) &#123; // 略 &#125;&#125; 主要是 doGetAuthenticationInfo 方法，其他的代码与上一章的基本相同。 在 doGetAuthenticationInfo 中我们返回的 AuthenticationInfo 信息中，将盐加了进去。 我们来测试下这个 Realm : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package im.zhaojun;import im.zhaojun.realm.MyCustomRealm;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authc.credential.HashedCredentialsMatcher;import org.apache.shiro.crypto.hash.Md5Hash;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.ByteSource;import org.junit.Test;/** * Shiro 加密测试 */public class EncryptionTest &#123; @Test public void testEncryptionRealm() &#123; DefaultSecurityManager securityManager = new DefaultSecurityManager(); // 创建 Relam MyCustomRealm realm = new MyCustomRealm(); // 创建密码匹配器 HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher("md5"); // 告诉 Realm 密码匹配方式 realm.setCredentialsMatcher(credentialsMatcher); securityManager.setRealm(realm); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhao", "123456"); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; System.out.println("登陆失败"); e.printStackTrace(); &#125; System.out.println("当前登陆状态: " + subject.isAuthenticated()); &#125;&#125; 我们需要为 Relam 指定一个 CredentialsMatcher，这里我们使用他的一个是实现类 : HashedCredentialsMatcher，并设置加密算法为 md5。 基本的加密使用就这些，具体的细节上，还有更多的加密算法，加密次数等内容，本篇为不对新手造成更多的初学负担，便不再展开，如需要深入了解，请自行查询。 本章代码地址：https://github.com/zhaojun1998/Premission-Study/tree/master/Permission-Shiro-04/]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro Realm]]></title>
    <url>%2Fshiro-03%2F</url>
    <content type="text"><![CDATA[Realm 是什么Realm: 域，Shiro 从 Realm 中获取用户，角色，权限信息。可以把 Relam 看成 DataSource，即安全数据源。 在前两章的认证和授权中，我们也使用到了 SimpleAccountRealm，并通过其 addAccount(username, password, roles) 来预设用户和角色信息。 IniRealmIniRealm 顾名思义，即通过读取 .ini 文件来获取用户，角色，权限信息。 配置用户名/密码及其角色, 格式: “用户名=密码，角色1，角色2”，如: 123[users]zhao = 123456, admin, userwang = 123456, user 配置角色及权限之间的关系, 格式: “角色=权限1, 权限2”, 如: 123[roles]admin = user:deleteuser = user:select 结合起来，即 : 1234567[users]zhao = 123456, admin, userwang = 123456, user[roles]admin = user:deleteuser = user:select 然后进行测试 : 123456789101112131415161718192021222324252627282930313233343536373839404142import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.Realm;import org.apache.shiro.realm.text.IniRealm;import org.apache.shiro.subject.Subject;import org.junit.Test;import java.util.Arrays;public class IniRealmTest &#123; @Test public void testIniRealm() &#123; DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); Realm iniRealm = new IniRealm("classpath:shiro.ini"); defaultSecurityManager.setRealm(iniRealm); SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhao", "123456"); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); System.out.println("登陆失败"); &#125; System.out.println("--------------------认证--------------------"); System.out.println("是否具备 admin 权限: " + subject.hasRole("admin")); System.out.println("是否具备 user 权限: " + subject.hasRole("user")); System.out.println("是否同时具备 admin 和 user 权限: " + subject.hasAllRoles(Arrays.asList("admin", "user"))); System.out.println("--------------------授权--------------------"); System.out.println("是否具备 user:delete 权限" + subject.isPermitted("user:delete")); System.out.println("是否具备 user:select 权限" + subject.isPermitted("user:select")); System.out.println("是否同时具备 user:delete 和 user:select 权限" + subject.isPermittedAll("user:delete", "user:select")); &#125;&#125; 跟前两章的代码没有什么不同，只是将 SimpleAccountRealm 换成了 IniRealm。 JdbcRelamJdbcRelam 顾名思义，即通过通过访问数据库来获取用户，角色，权限信息。 首先需要导入 mysql 的驱动包和 druid 数据库连接池的包: 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 创建数据库表和初始化数据 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for roles_permissions-- ----------------------------DROP TABLE IF EXISTS `roles_permissions`;CREATE TABLE `roles_permissions` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `role_name` varchar(100) DEFAULT NULL, `permission` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `idx_roles_permissions` (`role_name`,`permission`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of roles_permissions-- ----------------------------INSERT INTO `roles_permissions` VALUES ('1', 'admin', 'user:delete');INSERT INTO `roles_permissions` VALUES ('2', 'user', 'user:select');-- ------------------------------ Table structure for users-- ----------------------------DROP TABLE IF EXISTS `users`;CREATE TABLE `users` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `username` varchar(100) DEFAULT NULL, `password` varchar(100) DEFAULT NULL, `password_salt` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `idx_users_username` (`username`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;-- ------------------------------ Records of users-- ----------------------------INSERT INTO `users` VALUES ('1', 'zhao', '123456', null);-- ------------------------------ Table structure for user_roles-- ----------------------------DROP TABLE IF EXISTS `user_roles`;CREATE TABLE `user_roles` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `username` varchar(100) DEFAULT NULL, `role_name` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `idx_user_roles` (`username`,`role_name`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_roles-- ----------------------------INSERT INTO `user_roles` VALUES ('1', 'zhao', 'admin');INSERT INTO `user_roles` VALUES ('2', 'zhao', 'user'); 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import com.alibaba.druid.pool.DruidDataSource;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.jdbc.JdbcRealm;import org.apache.shiro.subject.Subject;import org.junit.Before;import org.junit.Test;import java.util.Arrays;/** * Shiro JdbcRealm 测试 */public class JdbcRealmTest &#123; private DruidDataSource dataSource = new DruidDataSource(); /** * 初始化 DataSource */ @Before public void before() &#123; dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://127.0.0.1:3306/shiro"); dataSource.setUsername("root"); dataSource.setPassword("root"); &#125; @Test public void testJdbcRealm() &#123; DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); // 构建 JdbcRelam JdbcRealm jdbcRealm = new JdbcRealm(); // 为 JdbcRelam 设置数据源 jdbcRealm.setDataSource(dataSource); // 设置启用权限查询, 默认为 false jdbcRealm.setPermissionsLookupEnabled(true); defaultSecurityManager.setRealm(jdbcRealm); SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhao", "123456"); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); System.out.println("登陆失败"); &#125; System.out.println("--------------------认证--------------------"); System.out.println("是否具备 admin 权限: " + subject.hasRole("admin")); System.out.println("是否具备 user 权限: " + subject.hasRole("user")); System.out.println("是否同时具备 admin 和 user 权限: " + subject.hasAllRoles(Arrays.asList("admin", "user"))); System.out.println("--------------------授权--------------------"); System.out.println("是否具备 user:delete 权限" + subject.isPermitted("user:delete")); System.out.println("是否具备 user:select 权限" + subject.isPermitted("user:select")); System.out.println("是否同时具备 user:delete 和 user:select 权限" + subject.isPermittedAll("user:delete", "user:select")); &#125;&#125; 这里也只是将 Relam 修改了一下，其他代码是一样的。 细心的朋友可能会有疑问，我们这里没有写一行查询语句，那么Shiro 怎么知道你的数据库结构的，它如何来查询角色和权限信息。 其实我们点开 JdbcRelam 的源码看看就知道了，它内置了默认的查询角色和权限的 SQL 语句： 1234protected static final String DEFAULT_AUTHENTICATION_QUERY = "select password from users where username = ?";protected static final String DEFAULT_SALTED_AUTHENTICATION_QUERY = "select password, password_salt from users where username = ?";protected static final String DEFAULT_USER_ROLES_QUERY = "select role_name from user_roles where username = ?";protected static final String DEFAULT_PERMISSIONS_QUERY = "select permission from roles_permissions where role_name = ?"; 而上面我们建立的表结构是符合这些查询语句的。 但在实际项目开发中，我们不可能完全按照 Shiro 提供的这种方式来建表，我们可以通过修改 JdbcRealm 的默认查询语句来实现： 123jdbcRealm.setAuthenticationQuery(String authenticationQuery);jdbcRealm.setPermissionsQuery(String permissionsQuery);jdbcRealm.setUserRolesQuery(String userRolesQuery); 自定义 Relam在真实项目开发中，我们往往会使用自定义 Realm 来实现一些自定义的功能，如判断账号锁定，账号登陆次数限制等。 我们需要创建一个类来继承 AuthorizingRealm ，并实现其抽象方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import im.zhaojun.pojo.User;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import java.util.HashSet;import java.util.Set;/** * 自定义 Realm */public class MyCustomRealm extends AuthorizingRealm &#123; /** * 根据用户凭证查询所用拥有的角色和权限 * @param principalCollection 用户凭证 * @return 返回授权信息，包含所拥有的角色和权限 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String username = (String)principalCollection.getPrimaryPrincipal(); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); // 根据用户名其所拥有的角色和权限 Set&lt;String&gt; roles = selectRolesByUserName(username); Set&lt;String&gt; permissions = selectPermissionsByUserName(username); authorizationInfo.setRoles(roles); authorizationInfo.setStringPermissions(permissions); return authorizationInfo; &#125; /** * 根据用户提交的凭证查询是否具有这个用户 (这里不判断密码是否正确) * @param authenticationToken 用户凭证 (账户密码) * @return 相应的用户信息 * @throws AuthenticationException 当用户不存在或具备其他状态, 如被锁定, 等状态会抛出相应的异常 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; // 这个方法也可以使用 DAO 层的方法来查询数据库，返回 user 对象。 User user = selectUserByUserName((String) authenticationToken.getPrincipal()); if (user == null) &#123; throw new UnknownAccountException("账号不存在"); &#125; return new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), super.getName()); &#125; private Set&lt;String&gt; selectPermissionsByUserName(String username) &#123; HashSet&lt;String&gt; permissions = new HashSet&lt;&gt;(); // 假设只有 zhao 这个用户具备 select 权限 if ("zhao".equals(username)) &#123; permissions.add("select"); &#125; return permissions; &#125; private Set&lt;String&gt; selectRolesByUserName(String username) &#123; HashSet&lt;String&gt; roles = new HashSet&lt;&gt;(); // 假设只有 zhao 这个用户具备 user 角色 if ("zhao".equals(username)) &#123; roles.add("user"); &#125; return roles; &#125; private User selectUserByUserName(String username) &#123; User user = null; // 假设当前只有 zhao - 123465 这个账户. if ("zhao".equals(username)) &#123; user = new User("zhao", "123456"); &#125; return user; &#125;&#125; 这里的代码也很简单，主要是实现了父类的抽象方法 : doGetAuthenticationInfo : 获取用户认证信息，在这里我们不需要校验密码是否正确，因为有专门的密码校验器来做这件事，我们只需要返回认证信息即可。 (认证信息在这个示例中为 SimpleAuthenticationInfo， 即账号密码)当然你也可以在返回认证信息前根据用户的状态，如冻结，锁定，或登陆次数来抛出相应的异常，以直接返回登陆失败，而不再进行密码校验。 doGetAuthorizationInfo : 获取用户授权信息，授权信息包括所拥有的角色和权限信息，这里的逻辑很简单，只需要根据用户信息查询出角色和权限，配置到 AuthorizationInfo 中返回即可 。 测试： 1234567891011121314151617181920212223242526272829import im.zhaojun.realm.MyCustomRealm;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.subject.Subject;import org.junit.Test;/** * 自定义 Realm 测试 */public class MyCustomRealmTest &#123; @Test public void testCustomRealm() &#123; DefaultSecurityManager securityManager = new DefaultSecurityManager(); MyCustomRealm realm = new MyCustomRealm(); securityManager.setRealm(realm); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhao", "123456"); subject.login(token); System.out.println("是否具备 user 角色: " + subject.hasRole("user")); System.out.println("是否具备 select 权限: " + subject.isPermitted("select")); &#125;&#125; 本章代码地址 : https://github.com/zhaojun1998/Premission-Study/tree/master/Permission-Shiro-03/]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 授权]]></title>
    <url>%2Fshiro-02%2F</url>
    <content type="text"><![CDATA[授权在 Shiro 中被称为 Authorization，用来验证用户是否具备某个角色或权限。 首先需要导包，这里我们通过 maven 坐标的方式进行引用, 导入 shrio 和 junit 的包: 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 然后创建一个测试类来简单认识一下 Shiro 的授权流程: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.SimpleAccountRealm;import org.apache.shiro.subject.Subject;import org.junit.Before;import org.junit.Test;public class AuthorizationTest &#123; // 创建一个 Realm private SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm(); /** * 为 Realm 添加一个账户, 并赋予 admin 角色 */ @Before public void before() &#123; simpleAccountRealm.addAccount("zhao", "123456", "admin"); &#125; /** * 测试用户授权(是否具备某个角色或权限) */ @Test public void testAuthentication() &#123; // 构建 SecurityManager 环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); // 为 SecurityManager 设置 Realm defaultSecurityManager.setRealm(simpleAccountRealm); // 将 SecurityManager 放入 SecurityUtils 这个工具类中 SecurityUtils.setSecurityManager(defaultSecurityManager); // 获取一个 Subject Subject subject = SecurityUtils.getSubject(); // 创建一个账号密码 UsernamePasswordToken token = new UsernamePasswordToken("zhao", "123456"); // 进行登陆操作 subject.login(token); // 验证是否为登陆状态 System.out.println("是否登陆: " + subject.isAuthenticated()); // 验证是否具备某个角色 System.out.println("是否具备admin角色: " + subject.hasRole("admin")); &#125;&#125; 若登陆的用户具备 admin 角色的话，subject.hasRole(&quot;admin&quot;) 会返回 true，反之返回 false。 也可以使用 subject.checkRole(&quot;admin&quot;) 来校验，此方法没有返回值，但如账户不具备此角色，会抛出 UnauthorizedException 异常。 还有 subject.hasAllRoles(Collection&lt;String&gt; collection) 及 subject.CheckRoles(String... strings) 等 API 用来判断用来进行其他方式的校验角色。 本章代码地址 : https://github.com/zhaojun1998/Premission-Study/tree/master/Permission-Shiro-02/]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 认证]]></title>
    <url>%2Fshiro-01%2F</url>
    <content type="text"><![CDATA[认证在 Shiro 中被称为 Authentication，用来验证用户是不是拥有相应的身份，也可以理解为登陆时校验登陆凭证的过程。 首先需要导包，这里我们通过 maven 坐标的方式进行引用, 导入 shrio 和 junit 的包: 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 然后创建一个测试类来简单认识一下 Shiro 的认证流程: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.SimpleAccountRealm;import org.apache.shiro.subject.Subject;import org.junit.Before;import org.junit.Test;public class AuthenticateTest &#123; // 创建一个 Realm private SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm(); /** * 为 Realm 添加一个账户 */ @Before public void before() &#123; simpleAccountRealm.addAccount("zhao", "123456"); &#125; /** * 测试用户认证(登陆) */ @Test public void testAuthenticate() &#123; // 构建 SecurityManager 环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); // 为 SecurityManager 设置 Realm defaultSecurityManager.setRealm(simpleAccountRealm); // 将 SecurityManager 放入 SecurityUtils 这个工具类中 SecurityUtils.setSecurityManager(defaultSecurityManager); // 获取一个 Subject Subject subject = SecurityUtils.getSubject(); // 创建一个账号密码, 在 web 应用中一般为表单上填写并传入后台. UsernamePasswordToken token = new UsernamePasswordToken("zhao", "123456"); // 进行登陆操作 subject.login(token); // 验证是否为登陆状态 System.out.println("是否登陆: " + subject.isAuthenticated()); &#125;&#125; 登陆成功的话，subject.isAuthenticated()会返回 true 。 登陆失败的话，会抛出相应的异常，如： 12UnknownAccountException # 未知账户/没找到帐号IncorrectCredentialsException # 错误的凭证(密码)异常 本章代码地址 : https://github.com/zhaojun1998/Premission-Study/tree/master/Permission-Shiro-01/]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j 详解]]></title>
    <url>%2Flog4j%2F</url>
    <content type="text"><![CDATA[安装log4j 官网下载相应的 jar 包: 点击直达 或使用 maven 坐标:12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 快速开始首先需要在项目 src 目录下创建文件 log4j.properties : 12345678log4j.rootLogger = debug, stdoutlog4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = %c %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n 输出日志 1234567891011121314import org.apache.log4j.Logger;public class Test &#123; private static Logger logger = Logger.getLogger(Test.class); public static void main(String[] args) &#123; // 记录debug级别的信息 logger.debug("This is debug message."); // 记录info级别的信息 logger.info("This is info message."); // 记录error级别的信息 logger.error("This is error message."); &#125;&#125; 打印结果: im.zhaojun.Test 19:31:42,793 DEBUG Test:13 - This is debug message. im.zhaojun.Test 19:31:42,798 INFO Test:15 - This is info message. im.zhaojun.Test 19:31:42,798 ERROR Test:17 - This is error message. log4j 配置Appender输出方式也称之为输出目的地，Log4j 自带的 appender 类有： 123456org.apache.log4j.ConsoleAppender(控制台)， org.apache.log4j.FileAppender(文件)， org.apache.log4j.DailyRollingFileAppender(每天产生一个日志文件) org.apache.log4j.RollingFileAppender(文件大小到达指定尺寸的时候产生一个新的文件)org.apache.log4j.WriterAppender(将日志信息以流格式发送到任意指定的地方)org.apache.log4j.jdbc.JDBCAppender(输出到数据库) 配置方式如下: 1log4j.appender.appenderName=org.apache.log4j.ConsoleAppender Level日志信息的优先级从高到低有 OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL，但只建议使用 ERROR、WARN、INFO、DEBUG 四种级别。 Root Level可以在 log4j.properties 中来配置 Root Level，语法为: 1log4j.rootLogger = [ level ], appenderName, appenderName, … [level] 中可填写 info, debug 等级别，它表示所有 appender 的最低输出级别，如填写 info，则所有 appender 中低于 info 级别的日志将不会生效。 Appender Level每个 Appender 也可以配置 Level，不过这里称为 Threshold ： 1log4j.appender.appenderName.Threshold = [level] 其中 appenderName 为自定义的 appender 名称，[level] 为当前 appender 的最低输出级别。 Logger Level在程序中通过 logger.setLevel() 来设置当前 Logger 对象输出的最低 Level。 123456789101112131415public class Test &#123; private static Logger logger = Logger.getLogger(Test.class); public static void main(String[] args) &#123; // 设置只输出 INFO 及以上级别的信息 logger.setLevel(Level.INFO); // 记录debug级别的信息, (这里不会输出) logger.debug("This is debug message."); // 记录info级别的信息 logger.info("This is info message."); // 记录error级别的信息 logger.error("This is error message."); &#125;&#125; 不推荐使用，在 Appender 中会配置更加直观。 Level 相互关系三种 Level 的关系为：Root Level &gt; Appender Level &gt; Logger Level 。 它们之间可理解为父子关系，父级别会限制子级别的输出内容， LayoutLog4j 自带的 layout 有：1234org.apache.log4j.HTMLLayout（以HTML表格形式布局）， org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） 配置方式如下:1log4j.appender.appenderName.layout=org.apache.log4j.PatternLayout Logger 实例Logger类提供了多种方法来处理日志，它提供了两个静态方法获得一个 Logger 对象： public static Logger getRootLogger(); public static Logger getLogger(String name); 第一个返回应用程序实例根记录器并没有名字。 第二种方法通过记录器的名称获得。记录器名称是可以传递任何字符串，通常是类或包的名称 ，用于区分不同类的输出，可以在 Layout 中通过 %c 来获取。（也可传入 Class 类型，会自动调用其 getName 方法取得字符串）。 Logger类有专门用于打印日志信息下面的方法如下。 # 方法及描述 1 public void debug(Object message) 这种方法打印使用 Level.DEBUG 消息级别 2 public void error(Object message) 这种方法打印使用 Level.ERROR 消息级别 3 public void fatal(Object message); 这种方法打印使用 Level.FATAL 消息级别 4 public void info(Object message); 这种方法打印使用 Level.INFO 消息级别 5 public void warn(Object message); 这种方法打印使用 Level.WARN 消息级别 6 public void trace(Object message); 这种方法打印使用Level.TRACE消息级别 日志格式化PatternLayout最为常用的便是 org.apache.log4j.PatternLayout，它采用类似 C 语言中的 printf 函数的打印格式格式化日志信息。 %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为&quot;rn&quot;，Unix平台为&quot;n&quot; %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) 参数 描述 实例 c Logger 的名字, 即 Logger.getLogger(String name) 创建实例时的 name 值。 允许使用 %c{数字} 输出部分的名字(从右边往左边数)。见实例 %c 将输出 com.log4j.Log4jTest%c{1}将输出Log4jTest%c{2}将输出log4j.Log4jTest%c{3}将输出com.log4j.Log4jTest C 输出 Logger 所在类的名称。 %C 将输出com.log4j.Log4jTest%C{1}将输出Log4jTest%C{2}将输出log4j.Log4jTest%C{3}将输出com.log4j.Log4jTest d 输出日期。允许使用%d{yyyy-MM-dd HH:mm:ss}格式化日期。 %d将输出2018-07-28 22:24:25,353%d{yyyy-MM-dd}将输出2018-07-28%d{ABSOLUTE}将输出22:24:25,353 F 输出所在的类文件名称 %F将输出Log4jTest.java l 输出语句所在的行数,包括类名,方法名,文件名,行数等 %l将输出com.log4j.test.Log4jTest.main(Log4jTest.java:50) L 输出语句所在的行数，只输出数字 %L将输出 50 m 输出日志 输出日志,即log.info(“”), log.debug(“”)的内容 M 输出方法名 %M 将输出main n 换行符,Windows下输出\r\n,Linux下输出\n 含行 p 输出日志级别(prioriry) DEBUG,INFO,ERROR,FITAL等 r 输出从程序启动到输出该日志之间的时间间隔，单位毫秒 %r将输出300 t 输出当前的线程名称 %t将输出main,Thread-0,Thread-1等 % %%用来输出百分号 需要避免 “C”, “F”, “L”, “M” 等位置信息的记录，原因详见：http://logging.apache.org/log4j/2.x/manual/layouts.html#LocationInformation Log4j 能输出形形色色的参数, 但参数内容的长度可能不同。如 %C 输出类名，有的类名很长，有的类名很短，会导致日志比较凌乱。为了解决该问题，Log4j允许设置输出内容的长度等，不够的会用空格补上。 设置的方法是在 % 与参数符号间添加数字, 例如 %20p, %-20p等。正数表示右对齐，负数表示左对齐，数字表示最小宽度，不足时用空格补齐。还可以设置最大宽度，如果超出，则截取，方法是用小数点+数字设置，例如 %.30p。 以 %p 为例，所有的调整格式见表: 格式 对齐方式 最小宽度 最大宽度 描述 实例 [%10p] 右对齐 10 正数右对齐，最小宽度 [ ERROR] [%-10p] 左对齐 10 负数左对齐，最小宽度 [ERROR ] [%.4p] 4 最大宽度 [RROR] [%10.20p] 右对齐 10 20 正数右对齐，最大最小宽度 [ ERROR] 日志目的地控制台文件要写日志信息到一个文件中，必须使用 org.apache.log4j.FileAppender。配置参数： 属性 描述 immediateFlush 标志的默认设置为true，这意味着输出流的文件被刷新，在每个追加操作 encoding 它可以使用任何字符编码。默认情况下是特定于平台的编码方案 threshold 这个 appender 阈值级别 File 日志文件的路径，如 d:/test.log append 默认设置为true，这意味着记录的信息被附加到同一文件的末尾 bufferedIO 此标志表示是否需要写入缓存启用。默认设置为false bufferSize 如果 bufferedI/O 启用，这表示缓冲区的大小，默认设置为8KB 数据库log4j API 提供 org.apache.log4j.jdbc.JDBCAppender 对象，它能够将日志信息在指定的数据库，配置参数： Property 描述 bufferSize 设置缓冲区的大小。默认大小为1 driver 设置驱动程序类为指定的字符串。如果没有指定驱动程序类，默认为sun.jdbc.odbc.JdbcOdbcDriver layout 设置要使用的布局。默认布局是org.apache.log4j.PatternLayout password Sets the database password. sql 指定SQL语句在每次记录事件发生的时间执行。这可能是INSERT，UPDATE或DELETE URL 设置JDBC URL user 设置数据库用户名 开始使用基于JDBC日志，要创建在哪里保存日志信息的表。下面是创建日志表的SQL语句： 12345678CREATE TABLE `logs` ( `id` int(11) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`), `date` datetime NOT NULL, `logger` varchar(50) NOT NULL, `level` varchar(10) NOT NULL, `message` varchar(1000) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8; 以下是将用于将消息记录到一个日志表中的示例配置文件 log4j.properties的JDBCAppender 1234567891011log4j.rootLogger = DEBUG, DBlog4j.appender.DB=org.apache.log4j.jdbc.JDBCAppenderlog4j.appender.DB.URL=jdbc:mysql://localhost/dbnamelog4j.appender.DB.driver=com.mysql.jdbc.Driverlog4j.appender.DB.user=rootlog4j.appender.DB.password=rootlog4j.appender.DB.sql=INSERT INTO logs(`date`, `logger`, `level`, `message`)VALUES(&apos;%d&#123;yyyy-MM-dd HH:mm:ss&#125;&apos;,&apos;%C&apos;,&apos;%p&apos;,&apos;%m&apos;)log4j.appender.DB.layout=org.apache.log4j.PatternLayout 运行结果： 123456789101112mysql&gt; select * from logs;+---------------------+-----------------+-------+---------------------------+----+| date | logger | level | message | id |+---------------------+-----------------+-------+---------------------------+----+| 2018-07-28 23:25:40 | im.zhaojun.Test | INFO | This is info message.你好 | 1 || 2018-07-28 23:25:40 | im.zhaojun.Test | ERROR | This is error message. | 2 || 2018-07-28 23:25:40 | im.zhaojun.Test | INFO | This is info message.你好 | 3 || 2018-07-28 23:25:40 | im.zhaojun.Test | ERROR | This is error message. | 4 || 2018-07-28 23:25:40 | im.zhaojun.Test | INFO | This is info message.你好 | 5 || 2018-07-28 23:25:41 | im.zhaojun.Test | ERROR | This is error message. | 6 |+---------------------+-----------------+-------+---------------------------+----+4 rows in set (0.03 sec)]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手撸 Java Web RBAC 权限管理]]></title>
    <url>%2Fjava-permission-1%2F</url>
    <content type="text"><![CDATA[前言权限管理是在项目中经常要使用到的模块，有着极其重要的功能。 在 Java 帝国中有两个比较出名的权限框架，分别为 Shiro 和 Spring Security，两者各有优缺，但这不是本篇要讨论的重点，这次我们不用任何权限框架来实现 RBAC 权限管理。 本文所有代码下载地址：https://github.com/zhaojun1998/Premission-Study RBAC 简介RBAC (Role-Based Access Control) 基于角色的权限访问控制。 即用户拥有角色,角色拥有权限。具体关于 RBAC 的好处我就不再赘言，如感兴趣请自行查询。 数据库设计共有五张表，分别为用户表、角色表、权限表、用户-角色关系表、角色-权限关系表。其中用户表于角色表是多对多的关系，角色表于权限表也是多对多关系。具体每个字段的含义请查看相应的注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for permission-- ----------------------------DROP TABLE IF EXISTS `permission`;CREATE TABLE `permission` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限名称', `description` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限描述表', PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '权限表' ROW_FORMAT = Dynamic;-- ------------------------------ Table structure for role-- ----------------------------DROP TABLE IF EXISTS `role`;CREATE TABLE `role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限名称', `description` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限描述', PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '角色表' ROW_FORMAT = Dynamic;-- ------------------------------ Table structure for role_premission-- ----------------------------DROP TABLE IF EXISTS `role_premission`;CREATE TABLE `role_premission` ( `role_id` int(11) NULL DEFAULT NULL, `permission_id` int(11) NULL DEFAULT NULL, INDEX `role_premission_uid_fk`(`role_id`) USING BTREE, INDEX `role_premission_pid_fk`(`permission_id`) USING BTREE, CONSTRAINT `role_premission_pid_fk` FOREIGN KEY (`permission_id`) REFERENCES `permission` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT, CONSTRAINT `role_premission_uid_fk` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户名', `password` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码', PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户表' ROW_FORMAT = Dynamic;-- ------------------------------ Table structure for user_role-- ----------------------------DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `user_id` int(11) NULL DEFAULT NULL, `role_id` int(11) NULL DEFAULT NULL, INDEX `user_role_uid_fk`(`user_id`) USING BTREE, INDEX `user_role_rid_fk`(`role_id`) USING BTREE, CONSTRAINT `user_role_rid_fk` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT, CONSTRAINT `user_role_uid_fk` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户角色表' ROW_FORMAT = Dynamic;SET FOREIGN_KEY_CHECKS = 1; 环境配置本次基于的环境是 Spring + SpringMVC + MyBatis，不过即使你不会这几个框架也无所谓，因为权限管理没有涉及到太多这些框架的特性，用普通的 Servlet + JDBC 同样也可以实现。 因篇幅原因，框架的配置文件我这里就不再贴出，但我会将源码发到 Github，你可以去下载本实例完整代码。 实体类首先需要创建三个与数据库对应的实体类 123456789public class User &#123; private Integer id; private String username; private String password; // getter setter 略&#125; 123456789public class Role &#123; private Integer id; private String name; private String description; // getter setter 略&#125; 123456789public class Permission &#123; private Integer id; private String name; private String description; // getter setter 略&#125; DAO 数据操作层UserMapper12345678910111213141516171819202122232425262728293031323334353637383940public interface UserMapper &#123; int insert(User record); User selectByPrimaryKey(Integer id); int updateByPrimaryKey(User record); List&lt;User&gt; selectALL(); /** * 查询用户拥有的角色列表 * @param id 用户 id * @return 角色列表 */ List&lt;Role&gt; selectRolesByPrimaryKey(Integer id); /** * 删除用户所有角色 * @param id 用户id * @return 删除成功的条数 */ int deleteRoles(Integer id); /** * 为用户赋予角色 * @param userId 用户 id * @param roleId 授予的角色 id * @return 插入成功的条数 */ int insertUserRole(@Param("user_id") Integer userId, @Param("role_id") Integer roleId); /** * 根据用户名密码查询账号是否存在 * @param username 用户名 * @param password 密码 * @return 查询到的账号 */ User selectUserByUsernameAndPassword(@Param("username")String username,@Param("password")String password);&#125; RoleMapper12345678910111213141516171819202122232425262728293031public interface RoleMapper &#123; int insert(Role record); Role selectByPrimaryKey(Integer id); int updateByPrimaryKey(Role record); List&lt;Role&gt; selectAll(); /** * 查询角色拥有的权限列表 * @param id 角色 id * @return 权限列表 */ List&lt;Permission&gt; selectPermissionsByPrimaryKey(Integer id); /** * 删除角色所有的权限 * @param id 角色 id * @return 删除成功的条数 */ int deletePermissions(Integer id); /** * 为角色添加一个权限 * @param roleId 角色 id * @param permissionId 权限 id * @return 插入成功的条数 */ int insertRolePermission(@Param("role_id")Integer roleId, @Param("permission_id") Integer permissionId);&#125; PermissionMapper123456789public interface PermissionMapper &#123; int insert(Permission record); Permission selectByPrimaryKey(Integer id); int updateByPrimaryKey(Permission record); List&lt;Permission&gt; selectAll();&#125; 只需要一些简单的 SQL 操作，如需要对应的 mapper.xml 可去 Github 查看。 用户管理用户添加HTML 页面:12345&lt;form action="addUser" method="post"&gt; 用户名:&lt;input type="text" name="username"&gt; 密 码:&lt;input type="password" name="password"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; Controller:123public String addUserSubmit(User user) &#123; return userService.add(user) &gt; 0 ? "success" : "error";&#125; service 和 dao 略. 用户登陆HTML 页面: 12345&lt;form action="login" method="post"&gt; 用户名 :&lt;input type="text" name="username"&gt;&lt;br&gt; 密 码:&lt;input type="password" name="password"&gt;&lt;br&gt; &lt;input type="submit" value="登陆"&gt;&lt;/form&gt; Controller: 12345678public String login(String username, String password, HttpSession httpSession) &#123; User user = userService.selectUserByUsernameAndPassword(username, password); if (user != null) &#123; httpSession.setAttribute("user", user); return "登陆成功"; &#125; return "登陆失败";&#125; service 和 dao 略. 查看用户列表HTML 页面:12345678910111213141516&lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;users&#125;" var="user"&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.password&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="grantRoleView?id=$&#123;user.id&#125;"&gt;赋予角色&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; Controller:123public ModelAndView listUser() &#123; return new ModelAndView("user.jsp").addObject("users", userService.getAllUser());&#125; service 和 dao 略. 为用户赋予角色为用户赋予角色需要先添加角色，请先看下面的添加角色后再来操作。 HTML 页面:12345678910111213141516171819202122232425262728293031&lt;form action="grantRole"&gt; &lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;当前用户&lt;/td&gt; &lt;td&gt; $&#123;user.username&#125; &lt;input type="hidden" name="id" value="$&#123;user.id&#125;"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;已拥有角色&lt;/td&gt; &lt;td&gt; &lt;c:forEach items="$&#123;grantRole&#125;" var="role"&gt; &lt;span&gt;$&#123;role.name&#125;&lt;/span&gt; &lt;/c:forEach&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;所有角色&lt;/td&gt; &lt;td&gt; &lt;c:forEach items="$&#123;roles&#125;" var="role"&gt; &lt;input type="checkbox" name="roleId" value="$&#123;role.id&#125;"&gt; $&#123;role.name&#125; &lt;/c:forEach&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="submit" value="提交"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; Controller:1234public String grantRole(int id, int[] roleId) &#123; userService.updateRoles(id, roleId); return "success";&#125; Service: 12345678public void updateRoles(Integer id, int[] roleIds) &#123; userMapper.deleteRoles(id); if (roleIds != null) &#123; for (int roleId : roleIds) &#123; userMapper.insertUserRole(id, roleId); &#125; &#125;&#125; 其实这里的修改授权角色只是将原来它拥有的所有角色删除，再分配给它提交的所有角色。 角色管理添加角色HTML 页面: 12345&lt;form action="addRole" method="post"&gt; 角色名称:&lt;input type="text" name="name"&gt; 角色描述:&lt;input type="text" name="description"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; Controller: 123public String addRole(Role role) &#123; return roleService.add(role) &gt; 0 ? "success" : "error";&#125; service 和 dao 略. 角色列表HTML 页面:12345678910111213141516&lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;角色名称&lt;/td&gt; &lt;td&gt;角色描述&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;roles&#125;" var="role"&gt; &lt;tr&gt; &lt;td&gt;$&#123;role.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;role.description&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="grantPermissionView?id=$&#123;role.id&#125;"&gt;赋予权限&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; Controller:123public ModelAndView listRole() &#123; return new ModelAndView("role.jsp").addObject("roles", roleService.getAll());&#125; service 和 dao 略. 为角色赋予权限HTML 页面:12345678910111213141516171819202122232425262728293031&lt;form action="grantPermission"&gt; &lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;当前角色&lt;/td&gt; &lt;td&gt; $&#123;role.name&#125; &lt;input type="hidden" name="id" value="$&#123;role.id&#125;"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;已拥有权限&lt;/td&gt; &lt;td&gt; &lt;c:forEach items="$&#123;grantPermission&#125;" var="permission"&gt; &lt;span&gt;$&#123;permission.name&#125;&lt;/span&gt; &lt;/c:forEach&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;所有权限&lt;/td&gt; &lt;td&gt; &lt;c:forEach items="$&#123;permissions&#125;" var="permission"&gt; &lt;input type="checkbox" name="premissionId" value="$&#123;permission.id&#125;"&gt; $&#123;permission.name&#125; &lt;/c:forEach&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="submit" value="提交"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; Controller:1234public String grantPermission(int id, int[] premissionId) &#123; roleService.updatePermission(id, premissionId); return "success";&#125; Service:12345678public void updatePermission(Integer roleId, int[] permissionsIds) &#123; roleMapper.deletePermissions(roleId); if (permissionsIds != null) &#123; for (int permissionId : permissionsIds) &#123; roleMapper.insertRolePermission(roleId, permissionId); &#125; &#125;&#125; 这里的为角色赋予权限同样也是先删除角色所拥有的权限，再添加表单提交的所有权限。 权限管理添加权限HTML 页面:12345&lt;form action="addPermission" method="post"&gt; 权限名称:&lt;input type="text" name="name"&gt; 权限描述:&lt;input type="text" name="description"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; Controller:123public String add(Permission permission) &#123; return permissionService.add(permission) &gt; 0 ? "success" : "error";&#125; service 和 dao 略. 权限列表HTML 页面:12345&lt;form action="addPermission" method="post"&gt; 权限名称:&lt;input type="text" name="name"&gt; 权限描述:&lt;input type="text" name="description"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; Controller: 123public String add(Permission permission) &#123; return permissionService.add(permission) &gt; 0 ? "success" : "error";&#125; service 和 dao 略. 权限拦截既然已经分配好用户，角色以及权限之间的关系了，那么我们就可以设置一些需要权限才能访问的资源了。 我设置了 5 个 url, 并标注了需要何权限或何角色才可访问: 12345/api/add # add 权限/api/delete # delete 权限/api/get # get 权限/api/employee # employee 角色/api/boss # boos 角色 我们可以用拦截器来拦截 /api/* 下的所有请求，那么如何区分不同请求分别需要什么权限呢？ 这里我参考了 Shiro 的设计，即采用注解的方式，在相应的方法上用 @RequiredRole 和 @RequiredPremission 来标注相应的请求需要某个角色或某个权限才可访问。 12345678910111213141516171819202122232425262728293031323334@RestController@RequestMapping("/api")public class APIController &#123; @RequiredPermission("add") @RequestMapping("/add") public String add() &#123; return "添加数据成功"; &#125; @RequiredPermission("delete") @RequestMapping("/delete") public String delete() &#123; return "删除数据成功"; &#125; @RequiredPermission("get") @RequestMapping("/get") public String select() &#123; return "查询数据成功"; &#125; @RequiredRole("boss") @RequestMapping("/boss") public String boss() &#123; return "此数据为 Boss 专用数据, 你是 boss, 你可以查看"; &#125; @RequiredRole("employee") @RequestMapping("/employee") public String employee() &#123; return "此数据为员工专用数据, 你是员工, 可以查看"; &#125;&#125; 拦截器获取拦截的方法上的注解即可得知需要什么权限，以便来进行相应的判断，Spring 拦截器：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class PermissionHandlerInterceptor implements HandlerInterceptor &#123; @Resource private UserService userService; @Resource private RoleService roleService; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; response.setHeader("Content-type", "text/html;charset=UTF-8"); Method method = ((HandlerMethod)handler).getMethod(); RequiredRole requiredRole = method.getAnnotation(RequiredRole.class); RequiredPermission requiredPermission = method.getAnnotation(RequiredPermission.class); User user = (User) request.getSession().getAttribute("user"); if (user == null) &#123; response.getWriter().write("未登录"); return false; &#125; List&lt;Role&gt; userRoles = userService.getUserRoles(user.getId()); if (requiredRole != null) &#123; for (Role role : userRoles) &#123; if (role.getName().equals(requiredRole.value())) &#123; return true; &#125; &#125; &#125; if (requiredPermission != null) &#123; for (Role role : userRoles) &#123; List&lt;Permission&gt; permissions = roleService.getPermissions(role.getId()); for (Permission persission : permissions) &#123; if (requiredPermission.value().equals(persission.getName())) &#123; return true; &#125; &#125; &#125; &#125; response.getWriter().println("权限不足"); return false; &#125;&#125; 总结基本实现就这些，其实没有很复杂的东西，只是将 RBAC 这个思想运用了起来。 那么反观我们这个权限管理有什么缺陷呢？ 我来列举几点： 对密码没有进行加密处理, 应对密码进行加盐并散列。 每次请求都会去获取所对应的权限数据和角色数据，太耗费资源，应该进行缓存。 不支持多凭证登陆，如可用邮箱也可用手机号登陆。 这些问题我会在后续的 shiro 的笔记中一一讲到。 本文所有代码下载地址：https://github.com/zhaojun1998/Premission-Study]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>权限管理</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次 IDEA 更新 Maven Index 的问题]]></title>
    <url>%2Fmaven-mirror-index%2F</url>
    <content type="text"><![CDATA[由于 maven 默认的中央仓库的速度不是很理想, 所以换成了阿里云的镜像, 但使用后发现, 无法正常更新索引了, Maven 的索引功能可以让 IDEA 自动提示一些信息, 如图所示: 废话不多说, 网上大多给出的地址都是:12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 但在更新时出现了错误 FileNotFoundException:Resource nexus-maven-repository-index.properties does not exist: 看样子是没找到文件, 经过一番查询后发现去找的是 http://repo1.maven.org/maven2/.index/nexus-maven-repository-index.properties这个地址, 即仓库目录下的隐藏文件夹 .index. 但试图去访问阿里云的镜像下的 .index 目录时, 却发现压根没有这个目录: 但其实这个目录应该是 http://maven.aliyun.com/nexus/content/repositories/central 这个仓库下的 .index 目录. 也就是说, 要配置仓库地址为 : 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt;]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黄蓉填充九宫格]]></title>
    <url>%2Falgorithm%2F</url>
    <content type="text"><![CDATA[题意 思路这道题是面试某公司时遇到的一道题，当然思维有些混乱，没有解出来。 经过分析此题要点是边界处理，即向右上移动时，超出九宫格时的处理过程，右上冲突时向下移动不需要考虑边界问题，均未超出边界。 当时面试官的要求是不论语言，30 分钟输出九宫格，不需要边框样式。 代码实现1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; int count = 1; int x = 0; int y = 1; int[][] arr = new int[3][3]; arr[0][1] = 1; while (count &lt; 9) &#123; int[] index = getIndex(arr, x, y); x = index[0]; y = index[1]; arr[x][y] = ++count; &#125; System.out.println(Arrays.toString(arr[0])); System.out.println(Arrays.toString(arr[1])); System.out.println(Arrays.toString(arr[2]));&#125;public static int[] getIndex(int[][] arr, int x, int y) &#123; int tempX = x - 1 &lt; 0 ? 2 : x - 1; int tempY = y + 1 &gt; 2 ? 0 : y + 1; if (arr[tempX][tempY] != 0) &#123; return new int[]&#123;x + 1, y&#125;; &#125; else &#123; return new int[]&#123;tempX, tempY&#125;; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 优化 --- Valine 扩展之邮件通知]]></title>
    <url>%2Fhexo-valine-admin%2F</url>
    <content type="text"><![CDATA[简介此项目是一个对 Valine 评论系统的拓展应用，可增强 Valine 的邮件通知功能。基于 Leancloud 的云引擎与云函数。可以提供邮件 通知站长 和 @ 通知 的功能，而且还支持自定义邮件通知模板。 点击查看演示 注：本项目修改于 panjunwen 的项目 : Valine-Admin，原作者博客: Valine Admin 配置手册, (部分逻辑于功能不同，还请读者不要搞混配置项.) 快速开始首先需要确保 Valine 的基础功能是正常的，参考 Valine Docs。 然后进入 Leancloud 对应的 Valine 应用中。 点击 云引擎 -&gt; 设置 填写代码库并保存：https://github.com/zhaojun1998/Valine-Admin 切换到部署标签页，分支使用 master，点击部署即可： 配置项此外，你需要设置云引擎的环境变量以提供必要的信息，点击云引擎的设置页，设置如下信息： 必选参数 SITE_NAME : 网站名称。 SITE_URL : 网站地址, 最后不要加 / 。 SMTP_USER : SMTP 服务用户名，一般为邮箱地址。 SMTP_PASS : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式 SMTP_SERVICE : 邮件服务提供商，支持 QQ、163、126、Gmail、&quot;Yahoo&quot;、...... ，全部支持请参考 : Nodemailer Supported services。 SENDER_NAME : 寄件人名称。 高级配置自定义邮件模板 自定义收件邮箱 自定义邮件服务器 Web 评论管理 Leancloud 休眠策略(必看) 更新历史 12.01 新增自助添加定时器方式。详见: LeanCloud 自带定时器[推荐方式] 7.30 修复 @ 邮件通知出错 bug (需 Valine 1.3.0 支持)，优化发件逻辑，站长发的评论不再收到邮件通知。 7.7 兼容 valine v1.2.0-beta 版本对 at 的更改 点击查看。 7.1 修复 Web 后台登录安全 bug 6.14 添加自定义邮件服务器功能. 点击查看 升级 FAQ部署最新代码 : 重启容器: 注: 更新新版本与更改环境变量均需要重启容器后生效。 LeanCloud 休眠策略免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行： 每天必须休眠 6 个小时 30 分钟内没有外部请求，则休眠。 休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。 分析了一下上方的策略，如果不想付费的话，最佳使用方案就设置定时器，每天 7 - 23 点每 20 分钟访问一次，这样可以保持每天的绝大多数时间邮件服务是正常的。 LeanCloud 自带定时器[推荐]首先需要添加环境变量，ADMIN_URL：Web 主机域名，如图所示（添加后重启容器才会生效）： 然后点击云引擎 - 定时任务，新增定时器，按照图片上填写： 添加后要记得点击启用： 启用成功后，每 20 分钟在云引擎的 - 应用日志中可以看到提示： Linux 定时器[老版本方式]附 Linux crontab 定时器代码： 1*/20 7-23 * * * curl https://你配置的域名前缀.leanapp.cn 如对本项目有意见或建议，欢迎去 Github 提 issues。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo优化</tag>
        <tag>Valine</tag>
        <tag>评论系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Docker 快速安装 HTML5-Based Speedtest，可以准确的测试本地到 VPS 的网络速度]]></title>
    <url>%2Fdocker-speedtest%2F</url>
    <content type="text"><![CDATA[前言经常会搞一些小鸡玩，但想测试速度，总是比较麻烦，而在 VPS 服务器上跑 speedtest-cli 却感觉测试结果不靠谱，因为它只跑了距离服务器最近的节点的速度。 现在，有了HTML5-Based Speedtest，这一切都迎刃而解！ 应用已经Docker化了，很简单即可部署测速环境！ 截图 说明由于Speedtest会尽可能使用最大的带宽，来反馈最真实的网络性能，所以，在部署完成项目后，请不要将你的测速地址公开！ 安装1、安装Docker 123curl -sSL https://get.docker.com/ | shsystemctl start dockersystemctl enable docker.service 2、配置镜像使用命令： 1docker run [-t/-d] -p [6688]:80 ilemonrain/html5-speedtest:alpine 参数详解： 123-t：启动后显示日志，可用Ctrl+C转入后台运行-d：后台模式启动-p 6688:80：镜像映射端口，修改6688为任意端口即可 示例命令： 1docker run -d -p 6688:80 ilemonrain/html5-speedtest:alpine 然后打开 http://ip:6688 即可。 如果是 CentOS 7 可能会打不开页面，放行防火墙端口，或者关掉即可！ 123456#打开6688端口firewall-cmd --zone=public --add-port=6688/tcp --permanent#关闭防火墙systemctl stop firewalld.servicesystemctl disable firewalld.service docker 作者博客 : https://blog.ilemonrain.com]]></content>
      <categories>
        <category>搞机</category>
      </categories>
      <tags>
        <tag>vps</tag>
        <tag>docker</tag>
        <tag>speedtest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自建 ngrok 内网穿透服务]]></title>
    <url>%2Fngrok%2F</url>
    <content type="text"><![CDATA[ngrok 和 内网穿透 是什么，有啥用处，以及为什么自建服务，这里我就不再多说了，相信点进来的人也不需要我解释这些。 准备工作 有公网 IP 的 VPS 一台 可以配置域名解析的域名一个。 系统：CentOS （也可为其他，命令稍有不同） 配置域名解析先把域名给配置了，比如我的域名是 zhaojun.im，那么建立 ngrok.zhaojun.im 和 *.ngrok.zhaojun.im 解析到 你的 VPS 的 IP 上 (A 记录)。 安装 go 语言环境ngrok 是基于 go 语言开发的，所以需要先安装 go 语言开发环境，CentOS 可以使用 yum 安装： 1yum install golang 如果没有权限，请使用 sudo 安装，安装完成之后，执行 go version 看到类似信息，证明安装成功： 1go version go1.7.3 linux/amd64 安装 git 环境有些 VPS 的系统中自带了 git 环境，有的没有带，如果你的 git 使用不正常，请卸载自带的 git，重装安装。 卸载原有 git （根据需要自选）： 1yum remove git 更新 yum 源： 1yum update 安装 git ： 1yum install git 安装完后执行 git --version，返回类似的信息，证明安装成功： 1git version 2.5.0 下载 ngrok 源码：找一个存放 ngrok 的文件夹 ，clone 一份源码： (为了方便演示，本文使用 root 用户，所以存放在 /root/ 路径下) 123cd /rootgit clone https://github.com/inconshreveable/ngrok.gitexport GOPATH=/root/ngrok 生成自签名证书使用 ngrok 官方服务时，我们使用的是官方的 SSL 证书。自己建立 ngrok 服务，需要我们生成自己的证书，并提供携带该证书的 ngrok 客户端。 证书生成过程需要有自己的一个基础域名，官网随机生成的地址，如：695a358d.ngrok.com，基础域名就是 ngrok.com。而在上文中提到的二级域名 ngrok.zhaojun.im 就是用来作为这次要提供的基础域名。如果你的域名是 abc.com，那么域名基础域名可以设置为 ngrok.abc.com。 以我的基础域名为例（注意替换成自己的域名），生成证书过程如下： 123456cd /root/ngrokopenssl genrsa -out rootCA.key 2048openssl req -x509 -new -nodes -key rootCA.key -subj "/CN=ngrok.zhaojun.im" -days 5000 -out rootCA.pemopenssl genrsa -out device.key 2048openssl req -new -key device.key -subj "/CN=ngrok.zhaojun.im" -out device.csropenssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000 执行完成以上命令后，在 ngrok 目录下，会新生成 6 个文件： 1device.crt device.csr device.key rootCA.key rootCA.pem rootCA.srl 我们在编译可执行文件之前，需要把生成的证书分别替换到 assets/client/tls 和 assets/server/tls 中，这两个目录分别存放着 ngrok 和 ngrokd 的默认证书。 123cp rootCA.pem assets/client/tls/ngrokroot.crtcp device.crt assets/server/tls/snakeoil.crtcp device.key assets/server/tls/snakeoil.key 中间会提示是否覆盖，输入 y 确认即可。这里最好一行一行复制执行，别一起复制执行。 编译 ngrokd 和 ngrokngrokd 是服务端的执行文件，进入到 ngrok 目录下，执行如下命令编译： 1make release-server ngrok 是客户端的可执行文件，进入到 ngrok 目录下，执行如下命令编译： 1GOOS=xxx GOARCH=xxx make release-client 不同平台使用不同的 GOOS 和 GOARCH，GOOS 为编译出来的操作系统 (windows,linux,darwin)，GOARCH 对应的构架 (386, amd64, arm) 12345678910Linux 平台 32 位系统：GOOS=linux GOARCH=386Linux 平台 64 位系统：GOOS=linux GOARCH=amd64Windows 平台 32 位系统：GOOS=windows GOARCH=386Windows 平台 64 位系统：GOOS=windows GOARCH=amd64MAC 平台 32 位系统：GOOS=darwin GOARCH=386MAC 平台 64 位系统：GOOS=darwin GOARCH=amd64ARM 平台：GOOS=linux GOARCH=arm 然后下载编译后的客户端，通过 ftp 或 scp 等都可以，生成的目录在 ngrok 的 bin 目录下，当前例子的路径为 /root/ngrok/bin/windows_amd64/ngrok.exe 启动 ngrokd 服务器在 ngrok 的 bin 目录下执行： 1./ngrokd -domain="ngrok.zhaojun.im" -httpAddr=":8088" -httpsAddr=":8089" 其中，-domain 为你的 ngrok 服务域名，-httpAddr 为 http 服务端口地址，访问形式为：xxx.ngrok.zhaojun.im:8088，也可设置为 80 默认端口，注意端口冲突即可，-httpsAddr 为 https 服务，同上。 ngrokd 启动后，退出命令行即关闭服务。如果想要在后台运行，则执行： 1nohup ./ngrokd -domain="ngrok.zhaojun.im" -httpAddr=":8088" -httpsAddr=":8089" &amp; 注意末尾需要有 &amp; 号，详细搜索 nohup 了解。关闭服务只需通过： 12ps -A # 找到PID，执行关闭kill xxxid 启动 ngrok 客户端上面我们编译好了客户端并下载到了本地，演示路径为 d:/ngrok/ngrok.exe 在 d:/ngrok/ 目录下，建立 ngrok 配置文件：ngrok.cfg 12server_addr: &quot;ngrok.zhaojun.im:4443&quot;trust_host_root_certs: false server_addr 端口默认 4443，还需要服务器开启 4443 端口，使用阿里云或腾讯云的需要去安全组放行 4443 外网端口，不然无法正常使用。 然后使用 cmd 到这个路径下(d:/ngrok/)，执行命令启动并转发本地的 4000 端口： 1ngrok -subdomain demo -config=./config.cfg 4000 运行完了以后会有提示域名，根据提示域名访问，我这里这里为 : http://demo.ngrok.zhaojun.im:8088，访问这个就等于访问到你的 http://127.0.0.1:4000 下的内容了。 更详细的 ngrok 配置，请参考官方文档 : https://ngrok.com/docs]]></content>
      <categories>
        <category>搞机</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 配置 HTTPS 强制跳转到 HTTP]]></title>
    <url>%2Fnginx-https-to-http%2F</url>
    <content type="text"><![CDATA[原来博客是 HTTPS 的，当时就是为了一把小绿锁，好看，但对我的博客来说，也不存在什么安全性问题，而且 HTTPS 还会拖慢访问速度以及一系列问题。 其实最重要的原因是，我的域名国内无法备案，博客放国外主机上，使用 HTTPS 部分地区无法访问，而 HTTP 却正常。真是伟大的墙~。惹不起，惹不起，就换回 HTTP 吧，但好多文章搜索引擎已经收录了，收录的连接却是 HTTPS 的，所以还需要想办法用 301 重定向到 HTTP。 啰嗦了这么多，其实就一小段 nginx 配置： 123if ($server_port = "443") &#123; return 302 http://$host$request_uri;&#125; 注意：推荐先用 302 做测试，测试好后，再改为 301，以免出现缓存引起的 bug。 最后奉劝大家一句，理性使用 HTTPS，按需所用，不盲目跟风。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>https</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从源码上分析 LinkedList（附图）]]></title>
    <url>%2FLinkedList%2F</url>
    <content type="text"><![CDATA[前言上一篇我们介绍了 ArrayList，这次，我们再看看一下它的兄弟：LinkedList 。 LinkedList 同样也实现了 List 接口，底层原理是双向链表，那么它又是如何实现的呢？继续来看吧。 源码分析成员变量LinkedList 只有三个成员变量：12345transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; size 属性不用说，肯定是表示链表的逻辑长度，first 应该是链表的第一个元素，last 表示最后一个元素。 构造方法先来看无参构造：12public LinkedList() &#123;&#125; 无参构造没有任何逻辑，那么再来看看其他的构造方法：1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 这里牵扯到要给 addAll 方法，一会在常用方法里我们会讲到，这里先放一放。 这次我们带上内存图来分析，会更直观一些，首先用无参构造来创建一个对象：1List&lt;Student&gt; list = new LinkedList&lt;&gt;(); 注：为了节省篇幅，本图省略了一些细节上东西，如常量池，方法区等内容。 常用方法add首先是 add 方法：1234public boolean add(E e) &#123; linkLast(e); return true;&#125; 1234567891011void linkLast(E e) &#123; final Node&lt;E&gt; l = last; // last 节点表示添加前最后一个节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 要添加的节点的上一个节点应该是 last 节点。 last = newNode; // 添加了节点后，添加的新节点应该为 last 节点。 if (l == null) // 如果当前元素没有上一个元素，则表示为第一次添加， first = newNode; // 那么当前节点应该也算是 first 节点。 else l.next = newNode; size++; // 逻辑长度 + 1 modCount++; // 修改次数 + 1&#125; 这里提到了 Node 类，来看看它的定义：1234567891011private static class Node&lt;E&gt; &#123; E item; // 当前节点的元素 Node&lt;E&gt; next; // 下一个结点 Node&lt;E&gt; prev; // 上一个节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 原来 Node 类是 LinkedList 的静态内部类，表示链表的一个节点。 那么当我们执行这段代码后，会发送什么呢？1list.add(new Student("张三", 20)); 那我们再添加一个元素呢? 1list.add(new Student("李四", 21)); 可能看起来有写复杂，其实也不难理解，耐下心对照源码好好看一下，应该就能理解这张图的意思了。 我们再添加两个元素看看效果。12list.add(new Student("王五", 22));list.add(new Student("赵六", 23)); remove添加了这么多，我们删除一个试试，先来看看源码：12345// 根据索引删除public E remove(int index) &#123; checkElementIndex(index); // 检查要删除的元素索引是否有效，即 0 &lt;= index &lt; size return unlink(node(index)); // node(index) 方法找到第 index 个元素&#125; 1234567private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size;&#125; 12345678910111213141516171819202122232425E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; // 要删除节点的值 final Node&lt;E&gt; next = x.next; // 当删除节点的后继节点 final Node&lt;E&gt; prev = x.prev; // 要删除元素的前驱结点 if (prev == null) &#123; // 如果没有前驱节点，表示为头节点 first = next; // 删除头节点后，更换 first 指向 &#125; else &#123; // 如果不是头节点 prev.next = next; // 将前驱节点的 next 指向要删除节点的后继节点 x.prev = null; // 将要删除的节点不再指向任何节点 &#125; if (next == null) &#123; // 如果当前节点为最后一个节点 last = prev; // 将 last 指向倒数第二个 &#125; else &#123; // 如果不是最后一个节点 next.prev = prev; // 将后继节点的 prev 指向要删除元素的前驱节点 x.next = null; // 将要删除的节点不再指向任何节点 &#125; x.item = null; // 将要删除的元素的数据清空 size--; // 逻辑长度 - 1 modCount++; // 修改次数 + 1 return element; &#125; 可能这里的这 10 和 17 行不太容易理解：12prev.next = next; // 将前驱节点的 next 指向要删除节点的后继节点next.prev = prev; // 将后继节点的 prev 指向要删除元素的前驱节点 举个简单的例子:张三 &lt;==&gt; 李四 &lt;==&gt; 王五 那么要删除李四的话，应该要将张三的 “下一个” 指向王五吧，也就是 prev.next = next;。同样，应为是双向链表，所以也应该让王五的 “上一个” 指向张三，即 next.prev = prev;。 这里讲解的是根据索引删除，还有根据元素删除，其实原理是一样的，主要是 unlink 这个方法，先根据传入的参数，找到要删除的元素，然后进行 unlink 方法的逻辑即可，这里就不再展开，如果你看懂了根据索引删除，相信你也能理解根据元素删除。 但是需要注意的是：如果删除的是引用数据类型的话，需要重写 equals 方法，不然可能会无法进行删除操作哦。其实仔细想想也能理解，既然需要 找到要删除的元素，那么如何判断传入的参数和要删除的是同一个呢？只有 equals 方法了，而默认从 Object 继承的 equals 方法可不一定能满足我们的需求，因为它只比较地址值，所以我们需要重写 equals 方法。 get 1234 public E get(int index) &#123; checkElementIndex(index); // 检查要获取的元素索引是否有效，即 0 &lt;= index &lt; size return node(index).item; // 根据索引来找到这个元素，返回它的 item 值&#125; 123456789101112131415 Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; // 如果要删除的元素在前半段, 则从 first 开始查找 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; // 如果要删除的元素在后半段, 则从 last 开始查找 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 这里用了一个很巧妙的小算法，既然我们知道链表的长度，那么当要删除的元素 索引 &lt; 长度 / 2，就从第一个开始找，反之从最后一个开始找，长度 / 2 可以改写为位运算即：size &gt;&gt; 1，效率更高一些。 先讲这么多，如果你看懂了这些，相信 LinkedList 的其他方法，你也能够轻松的理解。 总结根据上方的源码分析，我们可以总结出 LinkedList 的一些特性： LinkedList 底层数据结构是双向链表。 不能对元素进行随机访问，虽然提供了 get 方法，但这个方法是通过遍历来实现的。 删除、添加元素的效率很高，但查找元素的的效率较差。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从源码上分析 ArrayList]]></title>
    <url>%2Farraylist%2F</url>
    <content type="text"><![CDATA[前言ArrayList 是 List 接口的一个实现类，那么 ArrayList 的底层是如何实现的呢？让我们来一探究竟。 源码分析属性先来看看 ArrayList 中比较重要的两个属性：123transient Object[] elementData; private int size; elementData 用来存储 ArrayList 中的元素，其实 ArrayList 的底层是用 Object[] 数组来实现的。 size 指的是的逻辑长度，就好像一个水杯，容量是 600 毫升，但杯中只有 200 毫升的水，ArrayList 容器就是水杯， 这个 size 属性表示的就是水杯中水的容积。 构造方法无参构造方法： 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 很简单，就一行语句，elementData 在上面我们已经知道是什么了，那 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 又是什么呢？ 1private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 原来只是一个空的 Object[]。 指定容量的构造方法：12345678910public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125; 也很简单，就是为 ArrayList 指定初始容量。这里主要对传入的容量做了有效性验证，当传入的参数小于 0 时，抛出异常。当参数等于 0 时，则用一个空的数组常量 EMPTY_ELEMENTDATA 来初始化。 用一个 Collection 对象进行构造的的构造方法：1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 首先将传入的参数转为对象数组赋值给 elementData ，如果传入的 Collection 参数的长度为 0，则就将空的常量数组对象 EMPTY_ELEMENTDATA 赋给了 elementData。 常用方法add12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 调用了 ensureCapacityInternal 函数: 1234567private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; 这里判断 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 表示如果如果为没有初始化容量时，用默认容量 DEFAULT_CAPACITY 也就是 10，来开启空间，也就是上面我们说的水杯的容量。 接下来看 ensureExplicitCapacity 方法：1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 继续看 grow 方法: 12345678910111213141516171819private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 对 ArrayList 容量进行 1.5 倍扩容。 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果扩容后的容量还不够实际占用的容量，那么需要扩容到实际占用容量的大小。 // 如当前 newCapacity 为 10，扩容后为 15， // 但现在实际的元素数量为 16 个，那么至少应该先装下这 16 个。 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 防止阔中的过大，过大时，则使用 Integer.MAX_VALUE 代替。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 其实这段代码也很简单，就是动态扩容 ArrayList 的大小，每次扩容都为当前容量的 1.5 倍，当然也进行了扩容过大或过小的限制。其扩容原理就是创建一个容量为当前容量 1.5 倍的新数组，将旧数组的内容拷贝给新数组。 add(int index, E element) 1234567891011public void add(int index, E element) &#123; // 判断要插入的位置不小于 0 且不大于当前最大位置 rangeCheckForAdd(index); // 容量扩容检测，具体参见 add(E e) 方法 ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 看过了 add(E e) 的源码，这里也就很好理解了，先进行插入位置有效性判断，然后判断容量是否需要扩容，然后先将插入位置开始的所有元素向后移动一位，最后将需要插入的元素插入指定位置。 get12345public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; ArrayList 的底层是用数组实现的，那么获取元素也就很方便了，判断获取位置合法后，直接用下标获取即可。 set1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 这个方法其实就是修改指定位置的元素，先拿到要覆盖的元素，然后将新元素赋值上去，最后返回覆盖的元素即可。 remove1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 先进行有效性判断，然后从要删除的元素开始的所有元素都向前拷贝一位，并将最后一位设值为 null。 indexOf123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 如果要找的内容 null，则依次用 == 判断是否为要找的元素，如果不为 null，则用 equals 来依次判断。 总结根据上方的源码分析，我们可以得出 ArrayList 的一些特性： ArrayList 底层数据结构是对象数组，如不指定长度，则初始容量为 10。 底层的对象数组是在第一次添加元素的时候才进行初始化的。 每次扩容为原来容量的 1.5 倍，扩容原理是将原来的数据拷贝到新数组中。 所以我们在使用时要注意： 如知道大概要存多少个数据，最好指定初始化容量，这样可以提高程序性能。 ArrayList 查找元素很快，但删除元素和添加元素的效率相对较差。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何理解 Spring 的 IOC 思想?]]></title>
    <url>%2Fspring-ioc%2F</url>
    <content type="text"><![CDATA[前言一说起 Spring 大家都知道 Spring 有两个思想，即 IOC 和 AOP，AOP 比较容易理解，但 IOC 却在我学习 Spring 很长一段时间之后才算理解，故在此记录下来，供其他学习者参考。 是什么 IOC 全称是 Inversion of Control ，是一种叫做 控制反转 的设计思想。与之关联的是 DI 全称 Dependency Injection，即 依赖注入，IOC 容器通过 DI 来实现控制反转。 ps: 我知道你们也不想看这些总结性的概念，来看个例子吧。 为什么那为什么需要用到 IOC 呢？先来看看我们之前是怎么写代码的。 例如在一个 Person 类中需要一个 A 类的对象，调用 A 类的方法来完成工作。123456public class Person &#123; A a = new A(); public void work() &#123; a.xxx(); &#125;&#125; 然后有一天出现了一个 B 类，B 类可以实现同样的功能，且效率更高。于是你改起了代码：123456public class Person &#123; B b = new B(); public void work() &#123; b.xxx(); &#125;&#125; 我们来看这样的方式，是不是有些死板呢，需要改的地方很多，如果 100 个类中都调用了这个类，那修改的工作量未免也太大了。 这时其实可以将 A 和 B 之间的特型抽象出一个接口出来，叫 S。让 A 和 B 都实现 S 接口， 那么现在的代码就成这样了：123456public class Person &#123; S s = new A(); public void work() &#123; s.xxx(); &#125;&#125; 这时，如果我们如果想换成 B 类，只需要改很少的代码：123456public class Person &#123; S s = new B(); public void work() &#123; s.xxx(); &#125;&#125; 那么这样还有一个问题，就是如果 A 或 B 类需要设置一些参数，那么怎么办，再修改代码？那样耦合性还是太高了。 怎么做这是就用到了 IOC，将所有的对象，交由 Spring 容器来管理，只需要在 Spring 的配置文件里修改到底需要哪个类即可。 123456public class Person &#123; S s; public void work() &#123; s.xxx(); &#125;&#125; 1234567&lt;!--约束和一些配置略--&gt;&lt;bean id="A" class="package.A"&gt;&lt;bean id="B" class="package.B"&gt;&lt;bean id="person" class="package.Person"&gt; &lt;property name="S" ref="A"/&gt; &lt;!-- 或 &lt;property name="S" ref="B"/&gt; --&gt;&lt;/bean&gt; 如此就进行了进一步的解耦，其实完全可以把 Person 当作工作中的项目的 Service 类，而 A 和 B 是两个不同数据库的实现，或客户从 A 需求改到 B 需求，如此可以方便的维护我们的代码。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Java finally 执行顺序 -- 修改版]]></title>
    <url>%2Fjava-try-catch-finally-2%2F</url>
    <content type="text"><![CDATA[前言之前写了一篇 关于 try-catch-finally 执行顺序 的文章，但是写的有些繁琐了，这里重新写一下。 题目1234567891011121314151617181920class Test &#123; public int aaa() &#123; int x = 1; try &#123; return ++x; &#125; catch (Exception e) &#123; &#125; finally &#123; ++x; &#125; return x; &#125; public static void main(String[] args) &#123; Test t = new Test(); int y = t.aaa(); System.out.println(y); &#125;&#125; 我第一次看到这个题，得出了几个问题: 如果在 try 语句块里有 return 语句，那么 finally 还会执行吗？ 如果执行那应该是怎样的执行过程呢？ 首先这道题的运行结果是 2，可能跟你想的不一样吧，别急，下面我会慢慢解释的。 在学习 Java 基础的时候，老师就讲过，try-catch-finally 中的 finally 语句块一定会被执行，那么我们来 debug 一下： 初始状态: 此时运行到了 return ++x; 但还没执行该语句，目前 x 的值为 1. 这时发现跳到了 finally 语句块中，且 return ++x 的 ++ 操作已经执行，但没有进行 reutrn，目前 x 的值为 2: 执行完 finally 语句块中的 ++x 操作后，又回到了 return 中，此时 x 的值为 3: 但根据最后的运行结果，我们发现其实真正 reutrn 的是 2，那么如何解释这一点呢？ 其实在 官方的 JVM 规范 中对这一部分有说明： If the try clause executes a return, the compiled code does the following:Saves the return value (if any) in a local variable.Executes a jsr to the code for the finally clause.Upon return from the finally clause, returns the value saved in the local variable. 简单翻译如下： 如果 try 语句里有 return，那么代码的行为如下：如果有返回值，就把返回值保存到局部变量中执行 jsr 指令跳到 finally 语句里执行执行完 finally 语句后，返回之前保存在局部变量表里的值 看完这个应该就能理解为什么返回的是 2 了， 但要注意的是： 如果在 finally 语句块中也使用了 return 语句，那么会忽略 try 中的 return 语句，而执行 finally 中的 return。 如果 try 中 return 的是引用数据类型，那么 finally 中的操作可能会影响最终的 return 值，因为对于引用数据类型，暂存到局部变量里的是它的地址值。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 优化 --- lazyload 图片懒加载]]></title>
    <url>%2Fhexo-lazyload%2F</url>
    <content type="text"><![CDATA[前言Hexo 博客虽然功能很强大，但也越来越繁重了，访问速度上有了一些问题，这里我也考虑了许多，例如加 cdn，将国外的资源引用改为国内镜像等方式。今天又想到如果一个页面的图片很多，那么如何来提高博客的访问速度呢？。 经过一番寻找之后，找到一个方案，就是懒加载，通俗点讲就是当你翻到图片的时候再加载那张图片，而不是以下将本页面的所有图片都加载完。 配置配置过程也很简单，就是一个 npm 模块。在你的 Hexo 目录下，执行以下命令： 1npm install hexo-lazyload-image --save 然后在你的 Hexo 目录的配置文件 _config.yml 中添加配置: 1234lazyload: enable: true onlypost: false loadingImg: /images/loading.png onlypost是否仅文章中的图片做懒加载, 如果为 false, 则主题中的其他图片, 也会做懒加载, 如头像, logo 等任何图片. loadingImg - 图片未加载时的代替图 不填写使用默认加载图片, 如果需要自定义，添填入 loading 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。 Next 主题需将图片放到 \themes\next\source\images 目录下, 然后引用时: loadingImg: /images/图片文件名 效果展示]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo优化</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 优化 --- 支持邮件通知的评论 Valine 增强版]]></title>
    <url>%2Fhexo-valine-modify%2F</url>
    <content type="text"><![CDATA[简介此项目是一个对 Valine 评论系统的拓展应用，可增强 Valine 的邮件通知功能。基于 Leancloud 的云引擎与云函数。可以提供邮件 通知站长 和 @ 通知 的功能，而且还支持自定义邮件通知模板。 点击查看演示 注：本项目修改于 panjunwen 的项目 : Valine-Admin，原作者博客: Valine Admin 配置手册, (部分逻辑于功能不同，还请读者不要搞混配置项.) 快速开始首先需要确保 Valine 的基础功能是正常的，参考 Valine Docs。 然后进入 Leancloud 对应的 Valine 应用中。 点击 云引擎 -&gt; 设置 填写代码库并保存：https://github.com/zhaojun1998/Valine-Admin 切换到部署标签页，分支使用 master，点击部署即可： 配置项此外，你需要设置云引擎的环境变量以提供必要的信息，点击云引擎的设置页，设置如下信息： 必选参数 SITE_NAME : 网站名称。 SITE_URL : 网站地址, 最后不要加 / 。 SMTP_USER : SMTP 服务用户名，一般为邮箱地址。 SMTP_PASS : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式 SMTP_SERVICE : 邮件服务提供商，支持 QQ、163、126、Gmail、&quot;Yahoo&quot;、...... ，全部支持请参考 : Nodemailer Supported services。 SENDER_NAME : 寄件人名称。 高级配置自定义邮件模板 自定义收件邮箱 自定义邮件服务器 Web 评论管理 Leancloud 休眠策略(必看) 更新历史 7.7 兼容 valine v1.2.0-beta 版本对 at 的更改 点击查看。 7.1 修复 Web 后台登录安全 bug 6.14 添加自定义邮件服务器功能. 点击查看 升级 FAQ部署最新代码 : 重启容器: 注: 更新新版本与更改环境变量均需要重启容器后生效。 LeanCloud 休眠策略免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行： 每天必须休眠 6 个小时 30 分钟内没有外部请求，则休眠。 休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。 分析了一下上方的策略，如果不想付费的话，最佳使用方案就设置定时器，每天 7 - 23 点每 20 分钟访问一次，这样可以保持每天的绝大多数时间邮件服务是正常的。 附 Linux crontab 定时器代码： 1*/20 7-23 * * * curl https://你配置的域名前缀.leanapp.cn 注 : 此 crontab 不是LeanCloud 后台的定时任务，如果你没有 Linux 机器来配置此定时器，那么可以在此 issues 中回复我，我帮你加上。 如对本项目有意见或建议，欢迎去 Github 提 issues。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo优化</tag>
        <tag>Valine</tag>
        <tag>评论系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样才算一个好的技术博客？]]></title>
    <url>%2Fnice_blog%2F</url>
    <content type="text"><![CDATA[作为一个博主，我同样也看过很多其他博主的文章，也在学习，分析，怎样才算一个好的技术博客？ 先说说我的感受，我常常在遇到一个问题的时候，上网找答案，大多数找到的都是博客文章，但也发现了一些普遍问题： 抄袭严重 排版杂乱 晦涩难懂 我相信你们也会有过这种困扰，寻找问题查到的文章许多都是一模一样的，有些人竟然是直接复制的，连改都懒得改，甚至还把别人的代码块直接复制为普通文本，阅读体验极差！ 这就好像小时候听到的笑话：小明考试抄同学答案，把对方的名字也抄上了~。 我觉得一个好的技术博客起码应该满足以下几点： 尽量原创，如转载也请注明出处。 “接地气”，尽量不要弄一些晦涩的公式，可以把问题用通俗易懂的方式讲解出来，也是一种能力。 排版尽量舒适，起码代码应该写在代码块里，可参考 中文文案排版指北（简体中文版）。 尽量保证自己的博客内容是正确的，防止误人子都。 免注册，无广告，博客不是用来赚钱，而只是用来分享的。 你们对此有什么看法呢？]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>排版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建一个自己的云盘 + 离线下载站]]></title>
    <url>%2Fkodcloud-aria2%2F</url>
    <content type="text"><![CDATA[前言本次实验环境如下: VPS : Google Cloud Platform 系统 : CentOS_7.0_64 运行环境 : XAMPP 7.2 云盘服务 : kodcloud 离线下载 : 逗比根据地 - Aria2 一键安装管理脚本 获取权限国内的阿里云，腾讯云等获取 root 权限很简单，我记得这两家的 CentOS 系统一般都是默认 root 权限的，但这里还是要说一下，如何开启 root 密码登陆的方式，(如果以获得 root 权限，则可以跳过这一段)。 先使用 sudo -i 切换到 root 用户，vi /etc/ssh/sshd_config：找到 PermitRootLogin no 改成 PermitRootLogin yes找到 PasswordAuthentication no 改成 PasswordAuthentication yes按 Esc 输入:wq 保存退出 vi 根据系统重启 SSH 服务，其他系统请自行搜索。12sevice ssh restart # centos 6.xsystemctl restart sshd.service # centos 7.x 这样就开启用 root 用户密码登陆的权限了。但我们还不知道 root 用户的密码呢，所以输入 passwd 修改一下就可以用 xshell、putty 等工具登陆了。 Google Cloud Platform 缺只允许使用 ssh 登陆，虽然可以使用 sudo 来使用 root 权限，但发现最后还是有一些问题，就是 aria 下载的文件都是 root 用户，root 组的，而 kodexplorer 对这些下载的文件只有只读权限，很不方便，既然是个人的一些环境，所以这里就不那么考虑安全性了。 安装 XAMPP下载：123cd ~wget https://www.apachefriends.org/xampp-files/7.2.0/xampp-linux-x64-7.2.0-0-installer.runchmod 777 xampp-linux-x64-7.2.0-0-installer.run 如果提示 bash: wget: command not found，就先执行一下 yum install wget 安装：1./xampp-linux-x64-7.2.0-0-installer.run 安装选项全部默认即可，直接回车确认。 安装 kodcloud进入站点目录，创建网站存放目录123cd /opt/lampp/htdocsmkdir kodcloudcd kodcloud 下载1wget http://static.kodcloud.com/update/download/kodexplorer4.25.zip 安装解压工具并解压123yum install unzipunzip kodexplorer4.25.ziprm -rf kodexplorer4.25.zip 赋予权限1chmod 777 -R /opt/lampp/htdocs/kodcloud 现在访问 http://ip/kodcloud 即可访问到了，可能有人会说，我不想要这一级目录，并且还要配置域名，关于域名的配置，我们一会再说。 安装 aria2服务端aria2 安装脚本源地址：https://doub.bid/shell-jc4/ （需科学上网）12345cd ~wget -N --no-check-certificate https://softs.fun/Bash/aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; bash aria2.sh# 如果上面这个脚本无法下载，尝试使用备用下载：#wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; bash aria2.sh 执行后输入 1 即可安装。 显示端创建站点存放目录123cd /opt/lampp/htdocsmkdir ariacd /opt/lampp/htdocs/aria 下载1wget https://github.com/mayswind/AriaNg/releases/download/0.3.0/aria-ng-0.3.0.zip 解压12unzip aria-ng-0.3.0.ziprm -rf aria-ng-0.3.0.zip 配置域名及 SSL 证书阿里有提供免费的 SSL 证书，打开阿里云官网 -&gt; 管理控制台 -&gt; 左侧的安全(云盾) -&gt; CA 证书服务。 填写相应的信息，申请两个即可，我这里申请是 pan.zhaojun1998.com 和 aria.zhaojun1998.com 的证书。 申请后几分钟内会自动通过，然后下载证书。 接下来就是如何将证书上传到服务器的问题了，可以通过前面配置的 kodcloud 云打开 http://ip/kodcloud 将证书上传进去，或 ftp 等方式。（只需要上传 数字.key 和 数字.pem 即可） 最后在 /opt/lampp/apache2 目录下建立一个文件夹 cert，将证书放进来。 然后编辑 /opt/lampp/apache2/conf/httpd.conf，将域名对应上站点路径和证书。 123456789101112131415161718192021222324252627282930313233Alias /bitnami/ "/opt/lampp/apache2/htdocs/"Alias /bitnami "/opt/lampp/apache2/htdocs"&lt;Directory "/opt/lampp/apache2/htdocs"&gt; Options Indexes FollowSymLinks AllowOverride All Order allow,deny Allow from all&lt;/Directory&gt;&lt;VirtualHost *:80&gt; ## http 自动跳转 https ServerName pan.zhaojun1998.com RewriteEngine On RewriteRule ^/(.*)$ https://pan.zhaojun1998.com/$1 [R=301]&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ## http 自动跳转 https ServerName aria.zhaojun1998.com RewriteEngine On RewriteRule ^/(.*)$ https://aria.zhaojun1998.com/$1 [R=301]&lt;/VirtualHost&gt;&lt;virtualhost *:443&gt; ## https 配置 SSLEngine on SSLCertificateFile /opt/lampp/apache2/cert/214413124310384.pem SSLCertificateKeyFile /opt/lampp/apache2/cert/214413124310384.key ServerName pan.zhaojun1998.com DocumentRoot /opt/lampp/htdocs/kodcloud&lt;/virtualhost&gt;&lt;virtualhost *:443&gt; ## https 配置 SSLEngine on SSLCertificateFile /opt/lampp/apache2/cert/214298372380384.pem SSLCertificateKeyFile /opt/lampp/apache2/cert/214298372380384.key ServerName aria.zhaojun1998.com DocumentRoot /opt/lampp/htdocs/aria&lt;/virtualhost&gt; 配置完或，保存，然后重启 xampp:1/opt/lampp/lampp restart 其他aria 证书配置这样基本就完成了，但打开 aria 后发现，无法链接上 aria，原因是因为我们配置了 https 证书，但没有告诉 aria ，下面我们修改 aria 的配置:12cd ~./aria2.sh 选择主要修改的为以下几项：1234567891011121314## 下载到 kodcloud 管理员的 home 目录下dir=/opt/lampp/htdocs/kodcloud/data/User/admin/home ## 设置的RPC授权令牌，就是一个认证的密码，防止别人恶意下载rpc-secret=123456# 是否启用 RPC 服务的 SSL/TLS 加密,# 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接rpc-secure=true# 在 RPC 服务中启用 SSL/TLS 加密时的证书文件(.pem/.crt)rpc-certificate=你的 aria 证书pem路径# 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件(.key)rpc-private-key=你的 aria 证书key路径 aria + kodcloud 权限问题aria 是以 root 身份运行的，而 kodcloud 是以 apache 的 daemon 用户运行的。也就是说 aria 下载的文件， kodcloud 只有可读的权限，无法进行删除，修改等操作。 root 用户创建的文件默认是 644 权限，我们将它改为 664 权限，然后将 daemon 用户添加到 root 组即可。 修改 root 用户创建文件的默认权限，将超级用户的 uamsk 修改为 002 即可，这个计算方式有兴趣的自行查阅：12345vim /etc/bashrc 71行是普通用户的更改，73是超级用户的更改vim /etc/profile 60行是普通用户的更改，62是超级用户的更改source /etc/bashrc ##刷新bash配置source /etc/profile ##刷新系统配置 将 daemon 添加到 root 组1usermod -a -G root daemon 重启 xampp 服务1/opt/lampp/lampp restart 结果展示]]></content>
      <categories>
        <category>搞机</category>
      </categories>
      <tags>
        <tag>vps</tag>
        <tag>云盘</tag>
        <tag>离线下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令]]></title>
    <url>%2Fgit-help%2F</url>
    <content type="text"><![CDATA[安装&amp;配置install安装这里就不再多讲了，网上有许多教程，可以参考： 廖雪峰-安装Git Git 官方教程 config12git config --global user.name "Your Name"git config --global user.email "email@example.com" 注意 git config 命令的 –global 参数，用了这个参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和 Email 地址。 获取&amp;创建项目init1git init 初始化一个仓库，可以在任意目录中执行，表示对该目录使用 git 进行版本控制 clone1git clone [url] 基本的快照add1git add &lt;path&gt; 可以添加一个文件如 git add README.md 或一个目录 git add config 或使用通配符添加所有文件 git add * — 添加到暂存区。 status1git status 查看你的文件在暂存区和工作目录的状态，默认是较为详细的显示，并提示你可以用何种命令完成你接下来可能要做的事情。 1git status -s 较为简单的输出当前的状态，如：1234$ git status -sM README.md D hello.rb?? world.java 你可以看到，在简短输出中，有两栏。第一栏是暂存区的，第二栏则是工作目录的。这里表示： README.md 在暂存区中的状态是 modify hello.rd 在工作目录中的状态是 delete world.java 还未添加到版本控制。 diff1234git diff # 工作目录和暂存区git diff --cached # 暂存区和本地仓库git diff HEAD # 工作目录和本地仓库git diff --stat # 显示信息摘要 执行 git diff 来查看执行 git status 的结果的详细信息 —— 一行一行地显示这些文件是如何被修改或写入缓存的。 commit12git commit -m "commit message" ## 将暂存区中的内容提交到本地仓库git commit -am "commit message" ## 免去了 git add 进行 commit，需要 tracked 状态 执行 git commit 记录缓存区的快照到本地仓库。 reset12git reset HEAD -- file # 将本地仓库的当前版本恢复到暂存区git reset HEAD~1 -- file # 将本地仓库的上个版本恢复到暂存区 git reset HEAD -- file 也可以理解为放弃暂存区中的修改 rm, mv123git rm # 将文件从暂存区和工作目录删除，-f 为强制删除git rm --cached &lt;path&gt; # 将文件从暂存区中删除git mv &lt;old_path&gt; &lt;new_path&gt; git rm 用来删除文件、目录。git mv 命令用于移动或重命名一个文件、目录。 分支和合并branch123git branch # 列出所有分支git branch (branchname) # 创建新分支。git branch -d (branchname) # 删除分支 checkout12git checkout (branch) # 切换分支git checkout -b (branchname) # 创建新分支，并立即切换到它 merge12git merge &lt;branchname&gt; ## 将分支合并到当前分支 git merge --no-ff &lt;branchname&gt; ## 不适用 Fast-Forword 方式合并 使用 git merge 将另一个分支并入当前的分支中去。 关于 --no-ff 可参考 Git 分支管理策略 log &amp; reflog12345git log # 当前分支的 loggit log --oneline # 简要 loggit log --graph # 查看各种分支之间的日志git reflog # 查看所有分支的所有操作记录(包括 reset) 显示一个分支中提交的更改记录 tag123git tag # 查看所有标签git tag -a &lt;tagname&gt; -m "blablabla..." # 创建一个标签，并附上信息git tag -d &lt;tagname&gt; # 删除本地标签 远程仓库remote123git remote -v # 查看已关联的所有的远程仓库git remote add [alias] [url] # 添加一个新的远程仓库git remote rm [alias] # 删除远程仓库的管理 fetch, pull12345# 将 origin 仓库的 master 分支与本地的 next 分支进行合并git pull origin master:next# 将 origin 仓库的 next 分支与本地的 master 分支进行合并git pull origin next:master push1234# 推到 origin 仓库的 master 分支git push origin master# 将本地仓库的 master 与远程仓库进行关联，以后 push 就不用指定分支了。git push -u origin master 拓展git 分支合并策略在 Git 中有三种分支合并方式： git merge fast-forword： 当条件允许时，git 直接把 HEAD 指针指向合并分支的头（默认） git merge --no-ff：不适用 fast-forward 方式合并，保留分支的 commit 历史 git merge --squash：使用 squash 方式合并，将多次分支的 commit 历史记录压缩为一次]]></content>
      <categories>
        <category>速查手册</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一道 Java 综合面试题]]></title>
    <url>%2Fjava-this-override%2F</url>
    <content type="text"><![CDATA[前言昨天看了一道关于异常处理的题：由一道 Java finally 执行顺序的题引发的思考，今天又在牛客网看到一道更深的题，这次加上了一个子父类继承关系的知识点。 原题12345678910111213141516171819202122232425262728293031323334353637public class Test &#123; public static void main(String[] args) &#123; System.out.println(new B().getValue()); &#125; static class A &#123; protected int value; public A(int v) &#123; setValue(v); &#125; public void setValue(int value) &#123; this.value = value; &#125; public int getValue() &#123; try &#123; value++; return value; &#125; catch (Exception e) &#123; System.out.println(e.toString()); &#125; finally &#123; this.setValue(value); System.out.println(value); &#125; return value; &#125; &#125; static class B extends A &#123; public B() &#123; super(5); setValue(getValue() - 3); &#125; public void setValue(int value) &#123; super.setValue(2 * value); &#125; &#125;&#125; 题解这道题考的就是代码执行顺序，比较直观的方法是使用单步调试，来一起看下执行过程吧： 首先从 main 方法开始执行，new 了一个对象 B，没什么可说的。 接下来执行到了 B 类的构造方法，也没什么问题。 然后执行到了父类的有参构造。 这里要执行 setValue(v) 方法了，那么这里的 setValue() 方法应该是执行 B 类的，还是 A 类的呢？ 其实这个结果是有些出乎我意料， 怎么会执行子类 B 的 setValue() 方法呢？因为这里正在执行 B 的构造方法中，所以调用的方法就默认是 B 的，当 B 中没有，才会去找它的父类 A 中的方法。 下一步是 super.setValue() ，这里明确指明了调用父类的方法，所以应该没啥问题。 嗯，这里将 A 类的 value 属性设值为 10。 然后还回到 A 的构造方法中。 再回到 B 的构造方法中，接下来应该调用 getValue。 由于子类中没有，所以调用父类的 getValue 方法。 接下来将 A 中的 value 自增 1，然后到了 return value ，由于下面还有 finally 语句块，所以先执行 finally 语句块，再返回。 又到了一个 setValue 方法，那么这里调用的是子类 B 的，还是父类 A 的呢？ 可以看到，这里调用的是子类 B 的构造方法，还是刚才的那个结论：因为这里正在执行 B 的构造方法中，所以调用的方法就默认是 B 的，当 B 中没有，才会去找它的父类 A 中的方法。 接下来应该会执行 super.setValue() 也就是它父类 A 的 setValue() 方法。 这里会将 A 的 value 值设为 22。 然后回到刚才的方法里，准备打印 value 值，打印后一共会回到 try 里的 return 语句。 这里虽然 value 的值是 22，但是刚才执行 finally 语句块之前就已经将 reutrn 的值确定了，也就是 11，详细参见 由一道 Java finally 执行顺序的题引发的思考。 回到刚才的调用，由于上一步返回的值是 11，所以这里应该是调用的setValue(11- 3);，这里调用的是 B 的方法。 接下来又要执行 super.setValue() 了，也就是父类的 setValue() 方法。 这里会将 A 类的的 value 值从 22 改为 16. 然后 B 类的构造方法执行完了，回到 main 方法，准备调用 getValue() 方法，因为 B 类没有，所以会调用其父类 A 的。 这里将 A 的 value 值自增1，变为 17 ，然后最为 return 的最终返回结果后，执行 finally 语句中的内容。 这里又到了 setValue 的抉择，到底执行哪个类的呢？ 还是调到了 B 类中，因为 main 方法里调用的是 new B().xxx 方法，所以这里的 this 代表的是 B 类。接下来这里指定 super.setValue() ，调用父类的方法，将父类的 value * 2 ，然后回到 finally 块中。 然后调用输出语句，输出结果应为 34，输出后会返回到 try 里的 return 语句中。 那么这里的 return 值应该是刚才已经确定的值，也就是 17，然后回到 main 方法 这里返回的是 17,所以输出 17,程序结束。 总结这道题很长，不过也只是考两个知识点： 子类与父类之间的调用关系：动态分派 在调用new B()时调用A的构造器时和super.getValue()时的setValue(int value)方法是根据隐式对象的实际类型来确定的。只有实际类型未重写该方法时，才按照继承层次由下往上查找。这个可以参阅《深入理解JVM》的“分派”一节。 try-catch-finally 的执行顺序，详见： 由一道 Java finally 执行顺序的题引发的思考 理解了这两个知识点。还要脑子清醒，一步一步做，应该没什么问题。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由一道 Java finally 执行顺序的题引发的思考]]></title>
    <url>%2Fjava-try-catch-finally%2F</url>
    <content type="text"><![CDATA[前言本文讲解过于繁琐，已重新修改至 关于 Java finally 执行顺序 -- 修改版。 原题首先来看看这道题：123456789101112131415161718public class test1 &#123; static String s = "A"; public static void main(String[] args) &#123; System.out.println(test()); System.out.println(s); &#125; private static String test() &#123; try &#123; System.out.println("A"); return s = "A"; &#125; finally &#123; System.out.println("B"); s = "B"; &#125; &#125;&#125; 执行结果是 ABAB ，刚看到这个结果，我是比较诧异的，利用 IDEA 的单步调试也没弄明白，来看看我当时的思路： 首先输出 try 中的输出语句，输出 &quot;A&quot; 由于 try 下还有的 finally 语句，所以执行 finally 中的输出语句，输出 &quot;B&quot; 将 &quot;B&quot; 赋值给变量 s 回到 try 中的 return 语句，再次将 &quot;A&quot; 赋值给 s，将 &quot;A&quot; 最为返回值，返回 main 方法中。(此时 s = &quot;A&quot;) 回到 main 方法中的第一行输出语句，输出 &quot;A&quot;，然后执行 main 方法中的第二条输出语句，输出 &quot;A&quot; 所以，结果不应该是 “ABAA” 么，因为 return 中已经将 “A” 赋值给 s 了，那么 s 的值不应该是 “A” 么，这时返回值就是 “A”，再怎么第二条输出语句也不能是 “B” 呀，可看着开发工具输出的结果，我也很无奈，我当时是这个表情。。。 但我相信开发工具是不会骗我的，一定是我自己的理解有问题，然后自己又写了几个类似的例子来测试，最后得出的结论是： finally 语句块在 return 语句之后，return 返回之前执行，可能这句话不是那么容易理解，来看下面的例子吧，看完我相信你应该能明白我这句话是什么意思了。 例一证明：finally 语句块在 return 语句之后，return 返回之前执行。123456789101112131415161718192021222324252627public class FinallyTest1 &#123; public static void main(String[] args) &#123; System.out.println(test1()); &#125; public static int test1() &#123; int b = 20; try &#123; System.out.println("try block"); return b += 80; &#125; catch (Exception e) &#123; System.out.println("catch block"); &#125; finally &#123; System.out.println("finally block"); if (b &gt; 25) &#123; System.out.println("b&gt;25, b = " + b); &#125; &#125; return b; &#125;&#125; 运行结果： try block finally block b&gt;25, b = 100 100 可以根据运行结果得知，在 finally 语句块执行之前，return b += 80; 中的 b + =80; 这部分已经运行，但是没有返回，然后等 finally 执行完以后才返回结果的。 例二如果觉得这个 例 1 还不足以说明这个情况的话，下面再加个例子加强证明结论：123456789101112131415161718192021222324public class FinallyTest1 &#123; public static void main(String[] args) &#123; System.out.println(test11()); &#125; public static String test11() &#123; try &#123; System.out.println("try block"); return test12(); &#125; finally &#123; System.out.println("finally block"); &#125; &#125; public static String test12() &#123; System.out.println("return statement"); return "after return"; &#125; &#125; 运行结果： try block return statement finally block after return 这下总明白了吧，执行 finally 之前将 return 后的 test12() 方法先执行了，然后再执行的 finally 语句。 拓展问题一前面两个例子证明了原题得出的结论，但是这个结论好像还不能足矣证明原题中的结果为什么是&quot;ABAB&quot;，还有一个新问题： 如果，finally 中对 return 返回的变量进行了修改，那么 return 返回的是修改前的值还是修改后的值？ 我们在 例 1 的 finally 语句块中加上一句 b = 10;，那么结果又会是什么呢？12345678910111213141516171819202122232425262728293031public class FinallyTest2 &#123; public static void main(String[] args) &#123; System.out.println(test1()); &#125; public static int test1() &#123; int b = 20; try &#123; System.out.println("try block"); return b += 80; &#125; catch (Exception e) &#123; System.out.println("catch block"); &#125; finally &#123; System.out.println("finally block"); if (b &gt; 25) &#123; System.out.println("b&gt;25, b = " + b); &#125; b = 10; &#125; return b; &#125;&#125; 运行结果： try block finally block b&gt;25, b = 100 100 可以看到 return 的值并没有被 finally 中的语句改变，其实如果这样得出结论：finally 中对 return 返回的变量进行了修改，并不会影响 try 中 return 的值，是不负责任的，因为我们只考虑了基本数据类型，如果是引用数据类型，还会是这种结果么？ 扩展问题二接 拓展问题 1 的又一个问题，对于引用数据类型的情况：1234567891011121314151617181920212223242526272829303132333435public class FinallyTest3 &#123; public static void main(String[] args) &#123; System.out.println(test1().getName()); &#125; public static Student test1() &#123; Student stu = new Student(); try &#123; stu.setName("Try"); return stu; &#125; catch (Exception e) &#123; stu.setName("Catch"); &#125; finally &#123; stu.setName("Finally"); &#125; return stu; &#125;&#125;class Student &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 运行结果： Finally 可以看到，对于基本数据类型和引用数据类型，结论是不同的，再次总结下结论吧： 对于基本数据类型，finally 语句块中对 try 语句块的 return 的变量进行了修改，return 的则是修改前的值。 对于引用数据类型，finally 语句块中对 try 语句块的 return 的变量进行了修改，return 的则是修改后的值。 看到这里，不知道你有没有想到这个结论与 Java 的方法调用时的所谓的 值传递 和 引用传递 的结论有些类似。 既然得出了这个结论，那么这个结论是必然的情况么？一定正确么？别急，来看下一个例子。 拓展问题三对于 拓展问题 2 我再做一个增强版的，其实就是在第 17 行之下添加一条语句 stu = null ：123456789101112131415161718192021222324252627282930313233343536public class FinallyTest4 &#123; public static void main(String[] args) &#123; System.out.println(test1().getName()); &#125; public static Student test1() &#123; Student stu = new Student(); try &#123; stu.setName("Try"); return stu; &#125; catch (Exception e) &#123; stu.setName("Catch"); &#125; finally &#123; stu.setName("Finally"); stu = null; &#125; return stu; &#125;&#125;class Student &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 运行结果： Finally 这时，你可能都有骂人的冲动了，What ？咋回事，咋什么结论都不对呢，不是说好的引用数据类型会改变 return 的值么，这里都将 stu 修改为 null 了，怎么还能 return 了 &quot;Finally&quot; 呢？ 别激动，别激动，不卖关子了，我直接说了： 先说基本数据类型，由于基本数据类型是 值传递 ，所以在 try 里的 return 执行的时候，就先将变量的值隐性的作为最终返回的值。 同样的，对于引用数据类型，只是将该变量所指向的内存地址隐性的作为最终返回的值，所以即使将 stu = null，也无所谓了，因为早在执行 finally 之前，try 里的 return 就已经拿到了 stu 所指向的地址。 这里多说一句，其实 Java 里都是值传递，只不过基本数据类型的值是真正的值，而引用数据类型是地址值而已。（如果你看这句话更晕的话，就先跳过去这句话，反正本篇文章也不是为了解释这个的。） 更深的思考 问：如果 try 与 finally 中都有 return 语句，那么到底会返回哪一个呢？ 会返回 finally 中的 return 。 问：如果 try 里有 return 语句，整个 try-catch-finally 块之外也有一个 return 语句，那么哪个会执行，一定是这样么？ 在 try 里没有发生异常的情况下，是 try 里的 return 会执行，但发生了异常，则反之。 问：如果 catch 中有 return 语句呢？当然只有在异常的情况下才有可能会执行，那么是在 finally 之前就返回吗？ 当发生异常后，catch 中的 return 执行情况与未发生异常时 try 中 return 的执行情况完全一样。 最终总结finally 块的语句在 try 或 catch 中的 return 语句执行之后返回之前执行，且 finally 里的修改语句可能影响也可能不影响 try 或 catch 中 return 已经确定的返回值，若 finally 里也有 return 语句则覆盖 try 或 catch 中的 return 语句直接返回。 本文参考 Java finally语句到底是在return之前还是之后执行？ finally执行顺序面试题]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接两个字符串中的不同字符]]></title>
    <url>%2Fconcatenated-string-with-uncommon-characters-of-two-strings%2F</url>
    <content type="text"><![CDATA[题意给出两个字符串, 你需要修改第一个字符串，将所有与第二个字符串中相同的字符删除, 并且第二个字符串中不同的字符与第一个字符串的不同字符连接 样例给出 s1 = aacdb, s2 = gafd返回 cbgf给出 s1 = abcs, s2 = cxzca返回 bsxz 思路本题我采用了牺牲空间换时间的方式，空间、时间复杂度为 O(m + n)。 以 s1 = aacdb, s2 = gafd 为例 先将 s2 的每一个字符都放进 Map 集合中，将字符当作键，将值赋为 1，此时 Map 集合中应为： {&quot;g&#39;:1, &quot;a&quot;:1, &quot;f&quot;:1, &quot;d&quot;: 1}. 然后将 s1 的每一个字符依次判断是否存在与 Map 集合的 Key 中，如果相等则将 集合中该 Key 的值变为 2，如果不相等，则将结果加入到字符串缓冲区中。 进行完这一步操作后，Map 集合中应为：{&quot;g&#39;:1, &quot;a&quot;:2, &quot;f&quot;:1, &quot;d&quot;: 2}，字符串缓冲区中应为 ：cb。 最后将 s2 再遍历一次，将在 Map 集合中 Value 为 1 的 Key 依次添加到字符串缓冲区中即可。 代码实现1234567891011121314151617181920212223242526272829public class Solution &#123; /* * @param : the 1st string * @param : the 2nd string * @return: uncommon characters of given strings */ public String concatenetedString(String s1, String s2) &#123; StringBuffer sb = new StringBuffer(); Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for (char c : s2.toCharArray()) &#123; map.put(c, 1); &#125; for (char c : s1.toCharArray()) &#123; if (!map.containsKey(c)) &#123; sb.append(c); &#125; else &#123; map.put(c, 2); &#125; &#125; for (char c : s2.toCharArray()) &#123; if (map.get(c) != 2) &#123; sb.append(c); &#125; &#125; return sb.toString(); &#125;&#125; 原题地址Lintcode：连接两个字符串中的不同字符]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算最大值]]></title>
    <url>%2Fcalculate-maximum-value%2F</url>
    <content type="text"><![CDATA[题意给一个字符串类型的数字, 写一个方法去找到最大值, 你可以在任意两个数字间加 + 或 * 样例给出 str = 01231, 返回 10 ((((0 + 1) + 2) * 3) + 1) = 10 我们得到了最大值 10 思路 本题的题意千万不要误解，这道题的题意是指只考虑顺序运算的情况下，即你只知道下一位是什么，如：891，有的同学可能会认为 8 * (9 + 1) 这样运算，得出结果为 80，但其实这道题只能从左向右，一个一个运算，不能加括号什么的。所以 891 的结果应该为 8 * 9 + 1 为 73. 理解题意后，可得知：两个数之间运算，两者均不为 0 或 1，那么进行乘法运算显然可以得到最大的结果。反之，当其中一个数为 0 或 1时，进行相加运算会比乘法运算得到的值好一些。 代码实现123456789101112131415161718192021public class Solution &#123; /* * @param : the given string * @return: the maximum value */ public int calcMaxValue(String str) &#123; if (str == null || str.length() == 0) &#123; return 0; &#125; int rs = 0; for (int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); if (rs &gt; 1 &amp;&amp; c != '0' &amp;&amp; c != '1') &#123; rs *= Integer.valueOf(c + ""); &#125; else &#123; rs += Integer.valueOf(c + ""); &#125; &#125; return rs; &#125;&#125; 原题地址LintCode：计算最大值]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树层序遍历为二维数组]]></title>
    <url>%2Fbinary-tree-toarray%2F</url>
    <content type="text"><![CDATA[题意有一棵二叉树，请设计一个算法，按照层次打印这棵二叉树。给定二叉树的根结点 root，请返回打印结果，结果按照每一层一个数组进行储存，所有数组的顺序按照层数从上往下，且每一层的数组内元素按照从左往右排列。保证结点数小于等于 500。 样例 3 / \ 5 2 / \ / \ 8 3 4 1 输出结果应为 [[3], [5, 2], [8, 3, 4, 1]] 思路其实这就是一个二叉树层序遍历的一道题，只不过需要判断什么时候换层了。 可是使用队列来实现，首先声明两个变量 last 和 nlast，last 代表当前层的最右节点，nlast 表示下一行当前已知的最右节点。 先让根节点 3 入队列，然后由于已经是最右节点了，就把 3 赋值给 last，然后分别将队列中的首节点出队列，出队列的元素记作 pollNode，并将该节点的孩子依次入队列（即 5, 2），当放入每一个节点时，都将 nlast 指向这个节点，因为它始终是当前已知的该层的最右节点。当 last == pollNode 表示当前层已遍历完成， 然后将 last = nlast ，下一行的开始，直到队列为空。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.*;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class TreePrinter &#123; public int[][] printTree(TreeNode root) &#123; ArrayList&lt;ArrayList&lt;TreeNode&gt;&gt; levelList = new ArrayList&lt;ArrayList&lt;TreeNode&gt;&gt;(); ArrayList&lt;TreeNode&gt; level = new ArrayList&lt;TreeNode&gt;(); TreeNode last = root; TreeNode nlast = null; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; TreeNode pollNode = queue.poll(); level.add(pollNode); if (pollNode.left != null) &#123; queue.add(pollNode.left); nlast = pollNode.left; &#125; if (pollNode.right != null) &#123; queue.add(pollNode.right); nlast = pollNode.right; &#125; if (last == pollNode) &#123; last = nlast; levelList.add(level); level = new ArrayList&lt;TreeNode&gt;(); &#125; &#125; int[][] rs = new int[levelList.size()][]; for (int i = 0; i &lt; levelList.size(); i++) &#123; rs[i] = new int[levelList.get(i).size()]; for (int j = 0; j &lt; rs[i].length; j++) &#123; rs[i][j] = levelList.get(i).get(j).val; &#125; &#125; return rs; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 扩展 --- 优雅的备份 Hexo 博客]]></title>
    <url>%2Fhexo-backup%2F</url>
    <content type="text"><![CDATA[前言由于 Hexo 是静态博客，需要在本地配置，写文章，然后生成静态页面后上传到服务器。 这也就带来了备份的问题，我辛辛苦苦的配置了那么多主题相关的个性化配置，换电脑了怎么办？重写？ 怎么可能。！ 那么备份本地的 Hexo 文件吧，这就涉及到一个问题，先看下我的博客在本地占用的空间和文件数量：文件大小还可以接受，但…文件数量这么多，小文件复制起来那叫一个慢啊。 这里我们要考虑几个问题了： 哪些文件需要备份，哪些不需要。 如何备份，用什么工具备份。 备份到 U 盘？云盘？还是其他。 备份后如何恢复（重点）。 按照这几点，我们慢慢谈。 备份哪些文件？备份我们只需呀备份一些重要的文件即可，一些安装后就没该变化，或会自动生成的文件就没必要备份了，以下几个是我测试后的较为精简的备份方案。 根目录下的几个配置文件，主要是 _config.yml、package.json 。（必备份） source 文件夹，这个就不用说了，这里面包含了你写的文章的 markdown 源码，这个才是最重要的。（必备份） hexo/themes/themes_name 这里的 themes_name 指的是你的主题名称，可能你会对主题进行一些个性化的配置，所以这个主题全部备份了。（一般都只用一个主题，而且默认的主题也不用，所以默认主题不用备份。）。（必备份） scaffolds 文件夹，这个文件夹里是创建文章时的模板，如果你没修改过这个文件夹中的东西，可以不用备份。（根据情况备份） .ssh ，如果你使用了免密部署，那么备份下你的公钥和私钥还是有必要的，你也可以选择，当然重新生成。（根据情况备份） 备份到哪里？备份到哪里也是一个问题，备份到 U 盘的话就太麻烦了，而且也不能保证文件的实时性，万一电脑文件突然全部丢失了，还没来得及备份，那就完蛋了~。 所以直接排除掉本地备份这一项，而使用云服务备份，可以使用百度云，或 OneDriver 等服务，但还要考虑一个问题，就是能不能进行增量备份、选择性备份，方便不方便。 说先说说百度云，是大厂的，可靠性很高，但是呢，你可能备份上去简单，下载下来就难了。。。然后就是 OneDriver 等国外的服务提供商，同样也是大厂，但是毕竟由于网速的问题，选择国外的服务商不太适合。 于是就轮到今天的主角了：坚果云，不是广告，是确实挺好用。记得用 选择性备份： 备份后如何恢复? 安装 NodeJS 和 Git 这个就不多说了，并把备份的公钥私钥放到用户目录下的 .ssh 文件夹下，同时还要记得配置 Git 的邮箱和用户名： 12git config --global user.name "Your Name"git config --global user.email "email@example.com" 再将备份到坚果云的文件都先同步(下载)到本地的一个文件夹。 然后创建一个目录，用来存放 hexo，一系列命令 ： 12345npm config set registry http://registry.cnpmjs.orgnpm install hexo-cli -ghexo initnpm installnpm install hexo-util --save 现在再把第二步的拿到的之前备份的文件，依次覆盖当前目录下的文件即可（package.json 除外）。 对比备份的 package.json 和新生成的 package.json 文件的区别，可以得知自己有哪些插件没安装，安装即可。（如果不小心覆盖掉了 package 文件，也不要紧，打开 node_modules 文件夹，查看跟备份的 package.json 中的差别） 还原后，别忘了，在把现在的博客再设置下备份~~~]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 转换 Socks5 为 HTTP 代理]]></title>
    <url>%2Fwindows-socks5-http%2F</url>
    <content type="text"><![CDATA[前言由于某墙，使我们不得已使用一些工具来查阅外面的资料，我使用的是 SS/SSR 配合 Chrome 应用商店的 Proxy SwitchyOmega 来配合上网的，但是 SS/SSR 给予的本地端口是 Socks5 的，但有一些工具仅支持 HTTP 协议的代理，所以只好再借助一个工具 Privoxy 来转换一下。 下载下载地址 .zip 是便携版、.exe 是安装版，根据自己的需求下载即可 配置打开安装目录下的 config.txt 文件，然后在文件末尾加上一行 forward-socks5 / 127.0.0.1:1080 . 注意：这里的1080是指本机的 Shadowsocks 所在的端口号，默认为1080，后面那个点也不能省略。（此操作要在没有打开这个软件的情况下进行） 测试请确保此时已打开 SS/SSR、Privoxy 以及确保 Privoxy 的配置配置文件已修改并保存。 常用软件配置Chrome 浏览器打开浏览器设置点击 更改代理服务器设置，找不到就在设置里搜索。 配置后打开 http://p.p/ ，如下图所示，则代表成功 Sublime Text打开 Preferences &gt; Package Settings &gt; Package Control &gt; Settings - User 菜单编辑 Package Control.sublime-settings，添加两行:12&quot;http_proxy&quot;: &quot;http://127.0.0.1:8118&quot;,&quot;https_proxy&quot;: &quot;http://127.0.0.1:8118&quot; IDM有时使用 IDM 下载一些国外的站点的文件，会很慢，我们也配置一下带来，但毕竟 IDM 是一个下载工具，我们也不希望它下载任何东西都使用代理下载，这样会造成很大的浪费，配置如下： 第一个选项，使用自动配置脚本，就是为了防止一些不必要的下载浪费代理流量：1https://softs.fun/Other/pac.txt 下面可以选择 代理服务器 或 Socks ，使用 Socks 即是 SS/SSR 的代理端口]]></content>
      <categories>
        <category>搞机</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo优化 --- 添加复制功能]]></title>
    <url>%2Fhexo-copy%2F</url>
    <content type="text"><![CDATA[前言Hexo Next 主题自带的代码块功能，没有复制功能，很不方便。 经过一番查找后，在主题的 Issues 中找到了解决方案，这里记录下。 下载需要下载 clipboard.js 主页 Github 提供下载 clipboard.min.js 将下载的文件存到如下目录：（相对目录为工程目录，没有目录则创建）1.\themes\next\source\lib\zclip\clipboard.min.js 导入新建文件 custom.js ，目录如下：（相对目录为工程目录）1\themes\next\source\js\src\custom.js 修改 custom.js 为如下内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//此函数用于创建复制按钮function createCopyBtns() &#123; var $codeArea = $("figure table"); //查看页面是否具有代码区域，没有代码块则不创建 复制按钮 if ($codeArea.length &gt; 0) &#123; //复制成功后将要干的事情 function changeToSuccess(item) &#123; $imgOK = $("#copyBtn").find("#imgSuccess"); if ($imgOK.css("display") == "none") &#123; $imgOK.css(&#123; opacity: 0, display: "block" &#125;); $imgOK.animate(&#123; opacity: 1 &#125;, 1000); setTimeout(function() &#123; $imgOK.animate(&#123; opacity: 0 &#125;, 2000); &#125;, 2000); setTimeout(function() &#123; $imgOK.css("display", "none"); &#125;, 4000); &#125;; &#125;; //创建 全局复制按钮，仅有一组。包含：复制按钮，复制成功响应按钮 //值得注意的是：1.按钮默认隐藏，2.位置使用绝对位置 position: absolute; (position: fixed 也可以，需要修改代码) $(".post-body").before('&lt;div id="copyBtn" style="opacity: 0; position: absolute;top:0px;display: none;line-height: 1; font-size:1.5em"&gt;&lt;span id="imgCopy" &gt;&lt;i class="fa fa-paste fa-fw"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span id="imgSuccess" style="display: none;"&gt;&lt;i class="fa fa-check-circle fa-fw" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt;'); //创建 复制 插件，绑定单机时间到 指定元素，支持JQuery var clipboard = new Clipboard('#copyBtn', &#123; target: function() &#123; //返回需要复制的元素内容 return document.querySelector("[copyFlag]"); &#125;, isSupported: function() &#123; //支持复制内容 return document.querySelector("[copyFlag]"); &#125; &#125;); //复制成功事件绑定 clipboard.on('success', function(e) &#123; //清除内容被选择状态 e.clearSelection(); changeToSuccess(e); &#125;); //复制失败绑定事件 clipboard.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger); &#125;); //鼠标 在复制按钮上滑动和离开后渐变显示/隐藏效果 $("#copyBtn").hover( function() &#123; $(this).stop(); $(this).css("opacity", 1); &#125;, function() &#123; $(this).animate(&#123; opacity: 0 &#125;, 2000); &#125; ); &#125;&#125;//感应鼠标是否在代码区$("figure").hover( function() &#123; //-------鼠标活动在代码块内 //移除之前含有复制标志代码块的 copyFlag $("[copyFlag]").removeAttr("copyFlag"); //在新的（当前鼠标所在代码区）代码块插入标志：copyFlag $(this).find(".code").attr("copyFlag", 1); //获取复制按钮 $copyBtn = $("#copyBtn"); if ($copyBtn.lenght != 0) &#123; //获取到按钮的前提下进行一下操作 //停止按钮动画效果 //设置为 显示状态 //修改 复制按钮 位置到 当前代码块开始部位 //设置代码块 左侧位置 $copyBtn.stop(); $copyBtn.css("opacity", 0.8); $copyBtn.css("display", "block"); $copyBtn.css("top", parseInt($copyBtn.css("top")) + $(this).offset().top - $copyBtn.offset().top + 3); $copyBtn.css("left", -$copyBtn.width() - 3); &#125; &#125;, function() &#123; //-------鼠标离开代码块 //设置复制按钮可见度 2秒内到 0 $("#copyBtn").animate(&#123; opacity: 0 &#125;, 2000); &#125;);//页面载入完成后，创建复制按钮$(document).ready(function() &#123; createCopyBtns();&#125;); 配置新建文件 custom.swig ，目录：.\themes\next\layout\_custom\custom.swig（相对目录为工程目录） 12&lt;script type="text/javascript" src="/lib/zclip/clipboard.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/custom.js"&gt;&lt;/script&gt; 修改文件 _layout.swig ，目录：\themes\next\layout\_layout.swig（相对目录为工程目录） 1234567891011121314151617&lt;!doctype html&gt;...&lt;html class="&#123;&#123; html_class | lower &#125;&#125;" lang="&#123;&#123; config.language &#125;&#125;"&gt;&lt;head&gt; ...&lt;/head&gt;&lt;body itemscope itemtype="http://schema.org/WebPage" lang="&#123;&#123; page.lang || page.language || config.language &#125;&#125;"&gt; ... ... &#123;% include '_third-party/mathjax.swig' %&#125; &#123;% include '_third-party/scroll-cookie.swig' %&#125; &#123;% include '_third-party/exturl.swig' %&#125; &#123;% include '_custom/custom.swig' %&#125;&lt;/body&gt;&lt;/html&gt; 向文件中 &lt;/body&gt; 前一行插入文件引用，如第 15 行效果。1&#123;% include &apos;_custom/custom.swig&apos; %&#125; 本文参考 Issues #1684 代码块增加复制功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo优化 --- 一款极简的评论系统]]></title>
    <url>%2Fhexo-valine%2F</url>
    <content type="text"><![CDATA[已有更简单的方式来实现，请参考： Hexo 优化 --- Valine 扩展之邮件通知 演示之前也用多很多评论系统，包括多说，网易云跟帖，Coding Comments…，但是这些评论系统，要不就是稳定性差，要不就是需要繁琐的登录，还有的直接停止服务了。 好了，废话不多说，先看今天的主角长什么样： Valine – 一款基于 Leancloud 的极简风评论系统 使用方法获取 Leancloud Key因为是基于 Leancloud 的评论系统，所以需要先注册一个 Leancloud 账号。 点击这里注册 Leancloud 账号。 创建一个应用，应用名随意。 进入刚才创建的应用。设置 -&gt; 应用 Key，这里的 App ID 和 App Key，复制下来，下一步要用。 配置到页面上由于 Hexo 主题现在没有内置 Valine 评论系统，所以我们要手动修改 Hexo Next 主题的配置。 为了保险起见，推荐你先备份下 /themes/next/_config.yml 和 /themes/next/layout/_partials/comments.swig。以防出现不备。 修改_config.yml修改主题目录下的 /themes/next/_config.yml 中添加（如果现在使用着其他评论系统，请先去掉其他评论系统的配置）：1234valine: enable: true appId: Your_AppId ##你的 Leancloud App ID appKey: Your_AppKey ##你的 Leancloud App Key 修改 comments.swig 注：因为我没有其他的评论系统需求，所以将其他评论系统的内容的删掉了。 打开 /themes/next/layout/_partials/comments.swig，整个文件修改为： 123456789101112131415161718&#123;% if page.comments %&#125; &lt;div class="comments" id="comments"&gt;&lt;/div&gt; &#123;% if (theme.valine and theme.valine.enable)%&#125; &lt;script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"&gt;&lt;/script&gt; &lt;script src="//cdn.jsdelivr.net/npm/valine@1.1.6/dist/Valine.min.js"&gt;&lt;/script&gt; &lt;script&gt; new Valine(&#123; av: AV, el: '.comments', notify: true, // 邮件提醒 v1.1.4新增，下一步中有具体的邮箱设置 verify: true, app_id: '&#123;&#123; theme.valine.appId &#125;&#125;', app_key: '&#123;&#123; theme.valine.appKey &#125;&#125;', placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!' &#125;); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 设置邮箱提醒上一步的 notify 选项为 true 的情况下才需要这个设置，如果不需要邮件提醒，则直接跳过即可。 进入 Leancloud 选择你的评论所存放的 应用 &gt; 设置 &gt; 邮件模板，按下图设置好 用于重置密码的邮件主题 &gt; 然后 保存。 结语 好了，到此为止，重新部署后就可以看到结果了，部署之前，最好先执行以下 hexo clean 命令，防止出现缓存问题。如果出现下图所示的评论框，那么就是成功了。 本文参考：Valine – 一款极简的评论系统]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo优化</tag>
        <tag>Valine</tag>
        <tag>评论系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文链表]]></title>
    <url>%2Fpalindrome-linked-list%2F</url>
    <content type="text"><![CDATA[题意设计一种方式检查一个链表是否为回文链表。 样例1-&gt;2-&gt;1 就是一个回文链表。 思路压栈法1遍历链表，将其所有元素依次压栈。然后依次出栈与原链表进行比较。 压栈法2将链表取一半压入栈中，与另一半进行比较。(采用快慢指针法)。 代码实现压栈法1123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; /** * @param head a ListNode * @return a boolean */ public boolean isPalindrome(ListNode head) &#123; Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); ListNode p = head; while (p != null) &#123; stack.push(p); p = p.next; &#125; while (!stack.empty()) &#123; if (stack.pop().val != head.val) &#123; return false; &#125; head = head.next; &#125; return true; &#125;&#125; 压栈法2123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; /** * @param head a ListNode * @return a boolean */ public boolean isPalindrome(ListNode head) &#123; if (head == null || head.next == null) &#123; return true; &#125; Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; stack.push(slow); slow = slow.next; fast = fast.next.next; &#125; if (fast != null) &#123; slow = slow.next; &#125; while (!stack.empty()) &#123; if (stack.pop().val != slow.val) &#123; return false; &#125; slow = slow.next; &#125; return true; &#125;&#125; 原题地址LintCode：回文链表]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>栈</tag>
        <tag>两根指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转链表]]></title>
    <url>%2Frotate-list%2F</url>
    <content type="text"><![CDATA[题意给定一个链表，旋转链表，使得每个节点向右移动 k 个位置，其中 k 是一个非负数 样例给出链表 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null 和 k=2 返回 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;null 思路设链表长度为 n,当 k = n 时，链表旋转后的结果就是原链表（当 k 为 n 的倍数时，结果也是一样）。 当 k &lt; n 时，其实旋转链表就是将第 n - k 个元素后的所有元素都放在该链表的头结点之前，并把第 n - k 个元素的下一个节点指向 null 即可。 当 k &gt; n 时，则说明不止需要旋转一圈，但多旋转一圈其实跟多旋转两圈没什么区别，所以只需要将链表旋转 k % n 个位置即可。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; /** * @param head: the List * @param k: rotate to the right k places * @return: the list after rotation */ public ListNode rotateRight(ListNode head, int k) &#123; if (head == null || head.next == null) &#123; return head; &#125; //获取链表长度，并得到尾节点的指针。 int len = 1; ListNode p = head; while (p.next != null) &#123; p = p.next; len++; &#125; k = k % len; //去除需要多旋转的圈数 p.next = head; //将链表首尾相连，结成环形。 for (int i = 0; i &lt; len - k; i++) &#123; p = p.next; //旋转链表 &#125; head = p.next; //新的链表头 p.next = null; //断开环形链表。 return head; &#125;&#125; 原题地址LintCode：旋转链表]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有环链表]]></title>
    <url>%2Flinked-list-cycle%2F</url>
    <content type="text"><![CDATA[题意给定一个链表，判断它是否有环。 样例A: 1-&gt;5-&gt;10-&gt;11-&gt;18 ↑ ↓ ↑ ↓ ↑ ← ← ← ← A: 1-&gt;5-&gt;10-&gt;11-&gt;18-&gt;null 链表 A 的第五个节点 18 的 next 节点是 10，如此构成有环链表。 链表 B 则是一个无环链表。 思路如果链表有环，可以把有环部分看成一个跑道，有两个人，一个跑的快，一个跑的慢，如此一直跑下去，跑的快的一定会追上跑的慢的。 如果链表无环，那么跑的快的那个一定会先到达链表尾部，也就是 NULL。 我们可以设置两个指针来模拟那两个跑的快的人和跑的慢的人，一个指针每次向后移动一位，另一个指针每次向后移动两位，直到两者相遇或快指针到达链表尾部。 代码实现123456789101112131415161718192021222324252627282930313233/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */ public class Solution &#123; /** * @param head: The first node of linked list. * @return: True if it has a cycle, or false */ public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) &#123; return false; &#125; ListNode slow = head, fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; if (slow == fast) &#123; return true; &#125; &#125; return false; &#125;&#125; 原题地址LintCode：带环链表]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
        <tag>有环链表</tag>
        <tag>两根指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个链表的交叉]]></title>
    <url>%2Fintersection-of-two-linked-lists%2F</url>
    <content type="text"><![CDATA[题意请写一个程序，找到两个单链表最开始的交叉节点。 注意事项:如果两个链表没有交叉，返回 null。在返回结果后，两个链表仍须保持原有的结构。可假定整个链表结构中没有循环。 样例下列两个链表： A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 在节点 c1 开始交叉。 思路本题不用考虑 有环链表的情况，所以较为简单。 哈希表利用哈希表，先将 A 链表所有元素加入到哈希表中，然后遍历 B 数组，判断每一个元素是否已在哈希表中存在，如果已存在，则已存在的节点就是交叉节点。 取长度法首先将两个链表都遍历一次，取到两个的长度,记作 m 和 n，如果两个链表有交叉，那么两个链表的最后一个节点，一定是一样的。 这里用样例中的两个链表举例， A 链表的的长度：n = 5， B 链表的长度：m = 6 ，如果两者有相交节点，那么最多也只能是从长度较少节点的头结点到未节点。所以从较长链表 B 的第 m - n 位开始，从较短节点的头节点开始，依次向后，如果两个元素相同，则说明为交叉点。 代码实现哈希表123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */ public class Solution &#123; /** * @param headA: the first list * @param headB: the second list * @return: a ListNode */ public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode p1 = headA; ListNode p2 = headB; HashSet&lt;ListNode&gt; map = new HashSet&lt;ListNode&gt;(); while (p1 != null) &#123; map.add(p1); p1 = p1.next; &#125; while (p2 != null) &#123; if (map.contains(p2)) &#123; return p2; &#125; p2 = p2.next; &#125; return null; &#125; &#125; 取长度法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */ public class Solution &#123; /** * @param headA: the first list * @param headB: the second list * @return: a ListNode */ public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; int lenA = getLength(headA); int lenB = getLength(headB); ListNode n1 = headA; ListNode n2 = headB; for (int i = 0; i &lt; Math.abs(lenA - lenB); i++) &#123; if (lenA &gt; lenB) n1 = n1.next; else n2 = n2.next; &#125; while (n1 != null &amp;&amp; n2 != null) &#123; if (n1.val == n2.val &amp;&amp; n1.next == n2.next) &#123; return n1; &#125; n1 = n1.next; n2 = n2.next; &#125; return null; &#125; public int getLength(ListNode head) &#123; if (head == null) &#123; return 0; &#125; int length = 0; ListNode p = head; while (p != null) &#123; p = p.next; length++; &#125; return length; &#125;&#125; 原题地址LintCode：两个链表的交叉]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称的二叉树]]></title>
    <url>%2Fbinary-tree-symmetric%2F</url>
    <content type="text"><![CDATA[题意请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 样例A). 3 / \ 1 1 / \ / \ 6 4 4 6 B). 3 / \ 1 2 / \ / \ 7 4 5 6 A 与 B 在结构上都是对称的，但是本题的题意是指也对应，所以 A 树是一颗对称二叉树，B 树不是一颗对称的二叉树。 思路观察上方的样例可得结论： 根节点的左右节点的值是相同的 除根节点外，某节点的右子树与兄弟节点的左子树的值相同 除根节点外，某节点的左子树与兄弟节点的右子树的值相同 代码实现123456789101112131415161718192021222324252627282930313233343536/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; if (pRoot == null) &#123; return true; &#125; return fun(pRoot.left, pRoot.right); &#125; boolean fun(TreeNode n1, TreeNode n2) &#123; if (n1 == null &amp;&amp; n2 == null)&#123; return true; &#125; if (n1 != null &amp;&amp; n2 != null) &#123; return n1.val == n2.val &amp;&amp; fun(n1.left, n2.right) &amp;&amp; fun(n1.right, n2.left); &#125; return false; &#125; &#125; 原题地址牛客网：对称的二叉树]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的所有路径]]></title>
    <url>%2Fbinary-tree-paths%2F</url>
    <content type="text"><![CDATA[题意给一棵二叉树，找出从根节点到叶子节点的所有路径。 样例给出下面这棵二叉树： 1 / \ 2 3 \ 5 所有根到叶子的路径为： [ &quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot; ] 思路如某一个节点，没有子节点则将本身的值加入到集合中，如果有子节点，则将在子节点的路径之前加上当前节点。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition of TreeNode: * public class TreeNode &#123; * public int val; * public TreeNode left, right; * public TreeNode(int val) &#123; * this.val = val; * this.left = this.right = null; * &#125; * &#125; */public class Solution &#123; /** * @param root the root of the binary tree * @return all root-to-leaf paths */ public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; paths = new ArrayList&lt;String&gt;(); if (root == null) &#123; return paths; &#125; List&lt;String&gt; leftPaths = binaryTreePaths(root.left); List&lt;String&gt; rightPaths = binaryTreePaths(root.right); for (String path : leftPaths) &#123; paths.add(root.val + "-&gt;" + path); &#125; for (String path : rightPaths) &#123; paths.add(root.val + "-&gt;" + path); &#125; if (paths.size() == 0) &#123; paths.add(String.valueOf(root.val)); &#125; return paths; &#125;&#125; 原题地址LintCode：二叉树的所有路径]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2Fbalanced-binary-tree%2F</url>
    <content type="text"><![CDATA[题意给定一个二叉树,确定它是高度平衡的。对于这个问题,一棵高度平衡的二叉树的定义是：一棵二叉树中每个节点的两个子树的深度相差不会超过 1。 样例A) 3 B) 3 / \ \ 9 20 20 / \ / \ 15 7 15 7 二叉树 A 是高度平衡的二叉树，但是 B 不是。 思路这道题利用了 二叉树的最大深度 这个问题，就是求每一个左右节点的深度，如果两个深度之间的差大于 1，则说明该树不是一个平衡二叉树，该算法只会将所有元素遍历一次。 代码实现123456789101112131415161718192021222324public boolean IsBalanced_Solution(TreeNode root) &#123; return Height(root) != -1;&#125;public int Height(TreeNode node) &#123; if (node == null) &#123; return 0; &#125; int leftDepth = Height(node.left); if (leftDepth == -1) &#123; return -1; &#125; int rightDepth = Height(node.right); if (rightDepth == -1) &#123; return -1; &#125; if (Math.abs(leftDepth - rightDepth) &gt; 1) &#123; return -1; &#125; return Math.max(leftDepth, rightDepth) + 1;&#125; 原题地址牛客网：平衡二叉树]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵覆盖]]></title>
    <url>%2FRectCover%2F</url>
    <content type="text"><![CDATA[题意我们可以用 2 * 1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2 * 1 的小矩形无重叠地覆盖一个 2 * n 的大矩形，总共有多少种方法？ 样例对于一个 2 * 3 的矩阵，返回 3。 思路 当 n 为 1 时，也就是 2 * 1 的大矩阵，只有一种方法： 当 n 为 2 时，也就是 2 * 2 的大矩阵，有两种方法： 当 n 为 3 时，也就是 2 * 3 的大矩阵，有三种方法： 当 n 为 4 时，也就是 2 * 4 的大矩阵，应该有几种方法呢？4.1 根据原来 n = 3 时的内容，向右扩展一个 2 * 1 的矩阵，即：||||、=||、|=|。4.2 根据原来 n = 2 是的内容，向右扩展一个 = 形状的矩阵，即：==、||=。 你可以自己推导下 n = 5 时的情况，也是同样的规律。 规律为： f(n) = f(n-1) + f(n-2) (n &gt; 3) 代码实现12345678public class Solution &#123; public int RectCover(int target) &#123; if (target &lt; 3) &#123; return target; &#125; return RectCover(target - 1) + RectCover(target - 2); &#125;&#125; 原题地址牛客网：矩阵覆盖]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>矩阵</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[镜像二叉树]]></title>
    <url>%2Fbinary-tree-mirror%2F</url>
    <content type="text"><![CDATA[题意操作给定的二叉树，将其变换为源二叉树的镜像。 样例二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 思路递归法 递归的终止条件就是当前树为 null 或该树的左子树与右子树都为 null。 递归操作是交换当前数的左右子树。 递归条件： 当前数的左子树不为空时对左字树进行递归操作。 当前数的右子树不为空时对右子树进行递归操作。 模拟压栈法既然递归的原理是通过压栈实现的，那么我们也可以自己来创建一个栈来模拟实现。 先将根节点放入栈中，然后开始循环，循环条件是栈不为空，将栈顶元素出栈，当该节点的左子树或右子树不为空，就将左右子树进行交换，然后当左子树不为空时，将左子树压栈，当右子树不为空时，将右子树压栈。如此循环，直到栈为空。 代码实现递归法1234567891011121314151617181920212223242526272829303132/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode root) &#123; if (root == null) &#123; return; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; return; &#125; TreeNode temp = root.left; root.left = root.right; root.right = temp; if (root.left != null) Mirror(root.left); if (root.right != null) Mirror(root.right); &#125;&#125; 模拟压栈法12345678910111213141516171819202122232425262728293031323334/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/import java.util.Stack;public class Solution &#123; //模拟递归的压栈法 public void Mirror(TreeNode root) &#123; if (root == null) &#123; return; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(root); while (!stack.empty()) &#123; TreeNode node = stack.pop(); if (node.left != null || node.right != null) &#123; TreeNode temp = node.left; node.left = node.right; node.right = temp; &#125; if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); &#125; &#125;&#125; 原题地址牛客网：二叉树的镜像]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>递归</tag>
        <tag>栈</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不用加减乘除做加法]]></title>
    <url>%2FAdd%2F</url>
    <content type="text"><![CDATA[题意写一个函数，求两个整数之和，要求在函数体内不得使用 +、-、*、/ 四则运算符号。 样例对于 num1 = 15， num2 = 17，返回 32。 思路位运算首先先来看下十进制是如何计算的： 相加各位的值，不进位，结果是 22, （5 + 7 = 12，舍弃进位就是2, 1 + 1 = 2 没有进位就是 22） 计算进位值，得到 10。 然后将上述两步得到的值重复步骤 1 和 2 。直到进位置为 0，返回不进位的值即可。 那么对于二进制也可以用这种方式计算： 相加各位的值，不进位，15 (1111) + 17 (10001) = 11110，其实就是将不同的位保留，相同的位归0，那么这正是位运算中的异或运算的规则，所以 15 ^ 17 即可得到不进位的值。 计算进位置其实就是将只保留相同的位，也就是 15 (1111) + 17 (10001) = 00001，既然是进位值，还应该左移一位，也就是 00010，这两个小操作对应的就是位运算中的 &amp; 和 &lt;&lt;，即 (num1 &amp; num2) &lt;&lt; 1。 然后将上述两步得到的值重复步骤 1 和 2 。直到进位置为 0，返回不进位的值即可。 BigIntegerJava 对于高精度运算有一个类是 BigInteger，其中有一个 add() 方法，可以进行加法运算。 代码实现位运算12345678910public class Solution &#123; public int Add(int num1,int num2) &#123; while (num2 != 0) &#123; int temp = num1 ^ num2; num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = temp; &#125; return num1; &#125;&#125; BigInteger12345678import java.math.BigInteger;public class Solution &#123; public int Add(int num1,int num2) &#123; BigInteger b1 = new BigInteger(String.valueOf(num1)); BigInteger b2 = new BigInteger(String.valueOf(num2)); return b1.add(b2).intValue(); &#125;&#125; 原题地址牛客网：不用加减乘除做加法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 中 byte 的取值范围为什么是 -128 到 +127]]></title>
    <url>%2Fjava-tattle-02%2F</url>
    <content type="text"><![CDATA[首先要了解的概念是 Java 中用补码表示二进制数，补码的最高位代表符号位，最高位是 1 则表示为正数，最高位是 0 则表示为负数。 正数的补码是本身，负数的补码其绝对值的二进制位按位取反后 +1。 例如： +60：二进制表示形式为 0011 1100，补码为本身，也就还是 0011 1100-60：已知 +60 的二进制表现形式为 0011 1100，按位取反后是 1100 0011，在加 1，就是1100 0100。即表示 -60 的二进制表现形式 1100 0100。 回到正题，那么 byte 表示一个字节，一个字节是 8 位，最高位是符号位。 那么 8 位能表示的最大值就是 0111 1111，换算成十进制就是 127。 最小的负数就是1000 0000，（最大的负数是 1111 1111 是负数-1的补码），换算成十进制就是 -128，1000 0000 是最小负数的补码表示形式，我们把补码计算步骤倒过来就即可。1000 0000 减 1 得 0111 1111 然后取反 1000 0000因为负数的补码是其绝对值取反，即 1000 0000 为最小负数的绝对值，而 1000 0000 的十进制表示是 128，所以最小负数是 -128]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equals 和 == 到底有什么区别？]]></title>
    <url>%2Fjava-tattle-01%2F</url>
    <content type="text"><![CDATA[Java 中的 equals 和 == 对于不同的数据类型有不同的表现，话不多少，看演示。 对于基本数据类型对于基本数据类型来说，只能用 ==，所以毫无疑问，这里是用来判断两个基本数据类型的值是否一致。 对于基本数据类型包装类先来看看这种创建对象的方式：12345678public class Demo &#123; public static void main(String[] args) &#123; Integer i1 = new Integer(100); Integer i2 = new Integer(100); System.out.println(i1 == i2); System.out.println(i1.equals(i2)); &#125;&#125; 运行结果： false true 这里可能会有人疑问，== 不是判断两者是否相等么，那为什么结果为 false 呢？因为这里的 Integer 是一个对象，也就是引用数据类型，里面存放的是对象在堆内存中的引用值，所以这里的 == 只是判断两者的引用值是否相同，两者创建了两个对象，在堆内存中分别是不同的引用，由而引用值也不同，才会返回 false。 那么我们再看一下简化版的 Integer 的创建方式：12345678910111213141516package other;public class Demo &#123; public static void main(String[] args) &#123; Integer i1 = 100; Integer i2 = 100; System.out.println(i1 == i2); System.out.println(i1.equals(i2)); Integer i3 = 1000; Integer i4 = 1000; System.out.println(i3 == i4); System.out.println(i3.equals(i4)); &#125;&#125; 运行结果： true true false true equals 毫无疑问是判断值是否相同，所以结果为 true，但是为什么第一个 == 又为 true 了呢，而第二个 == 还是 false。 因为在 Java 5 中，为 Integer 的操作引入了一个新的特性，用来节省内存和提高性能。整型对象在内部实现中通过使用相同的对象引用实现了缓存和重用。但适用范围只有 -128 到 +127 也就是说当自动装箱时，不会再分配内存空间，而是使用缓存中已存在的对象。 最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改 这种缓存行为不仅适用于 Integer 对象。我们针对所有整数类型的类都有类似的缓存机制。Byte、Short、Long、Character 都支持缓存。 其中 Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。 对于基本数据类型包装类而言，不论是使用哪种方式创建的，判断两者的值是否相同，务必要使用 equals ，而不要使用 ==。 对于自定义数据类型首先有 Person 类：123456789101112131415161718public class Person &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 然后示例： 1234567891011121314public class Demo &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.setId(1); p1.setName("张三"); Person p2 = new Person(); p2.setId(1); p2.setName("张三"); System.out.println(p1 == p2); System.out.println(p1.equals(p2)); &#125;&#125; 这里使用 == 的结果为 true 很容易理解，毕竟两个对象的引用不同，但是 equals 不是判断值是否相同么，我的两个id 和 name 都是一样的，为什么这里还会返回 false 呢？ Person 中我们没有写 equals 方法，根据 Java 继承的特点，Person 类继承的是 Object，所以使用的是 Object 的 equals 方法，那我们来看看 Object 的 equals 方法是怎么写的。 ![image_1bo22o7qv1e801ivjhqftge18d1m.png-24.9kB][1] 原来这里的 equals 方法里用的也是 ==，那么刚才我们用基本数据类型包装类时，为什么能判断呢，同样，我们找到 Integer 的 equals 方法。 ![image_1bo22v5je88n1d611g3la3e1a1m13.png-33kB][2]![image_1bo2315q517g21glb14ni11c9hdp2n.png-18.8kB][3] 可以看 Integer 的 equals 方法，会先判断该对象是否是一个 Integer 类的一个实例，如果不是则直接返回 false，是的话就比较他们的 value 值是否相等。 所以在我们自定义数据类型时，比较两个对象是否相同，一定要重写 equals 方法。 12345678910111213@Overridepublic boolean equals(Object obj) &#123; if (obj instanceof Person) &#123; Person p = (Person)obj; if (this.id == p.id &amp;&amp; this.name == p.name) &#123; return true; &#125; &#125; return false;&#125; 重写 equals 方法后的运行结果： false true 对于 StringString 也有两种创建方式，一种是 String str = new String(&quot;java&quot;);，另一种是 String str = &quot;java&quot;。 Java 为 String 类型提供了缓冲机制，当使用第二种双引号的形式创建对象时，Java 会先去字符串缓冲池中寻找内容相同的字符串，如果存在就直接拿来应用，如果不存在就创建一个新的字符串放到缓冲池中。对于第一种 new 对象的形式而言，每次都会创建一个新的对象，不会访问字符串缓冲池。 既然如此，对于 String 的 equals 和 == 你也自然应该明白是什么结果了。 一般情况下，建议使用 String s = &quot;abc&quot; 方式，因为该方式采用的是字符串缓冲池机制，效率更高。 结论在引用类型中，”==” 是比较两个引用是否指向堆内存里的同一个地址（同一个对象），而 equals 是一个普通的方法，该方法返回的结果依赖于自身的实现。 对于引用类型而言，判断两者是否相同要用 equals 方法，而不是 ==。当然对于自定义数据类型，记得要重写 equals 方法，不然效果就等同于 == 了。 [1]: https://cdn.jun6.net/image_1bo22o7qv1e801ivjhqftge18d1m.png [2]: https://cdn.jun6.net/image_1bo22v5je88n1d611g3la3e1a1m13.png [3]: https://cdn.jun6.net/image_1bo2315q517g21glb14ni11c9hdp2n.png]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的最大深度]]></title>
    <url>%2Fmaximum-depth-of-binary-tree%2F</url>
    <content type="text"><![CDATA[题意给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的距离。 样例给出一棵如下的二叉树: 1 / \ 2 3 / \ 4 5 这个二叉树的最大深度为 3. 思路递归法用递归分别遍历每个节点 ，返回相对于当前节点的最大深度（记得加上根节点）。 循环法非递归写法可以用一个队列来存储，先将根节点存入，并记录当前节点的兄弟节点个数（指来自同一个父节点），当兄弟节点都出队列完毕，就对子节点进行与根节点同样的操作。 代码实现递归法12345678910111213141516171819202122232425262728/** * Definition of TreeNode: * public class TreeNode &#123; * public int val; * public TreeNode left, right; * public TreeNode(int val) &#123; * this.val = val; * this.left = this.right = null; * &#125; * &#125; */public class Solution &#123; /** * @param root: The root of binary tree. * @return: An integer. */ public int maxDepth(TreeNode root) &#123; if (root == null) return 0; int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left, right) + 1; &#125; //简化写法的话，其实可以一行代码解决： // return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;&#125; 循环法12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition of TreeNode: * public class TreeNode &#123; * public int val; * public TreeNode left, right; * public TreeNode(int val) &#123; * this.val = val; * this.left = this.right = null; * &#125; * &#125; */public class Solution &#123; /** * @param root: The root of binary tree. * @return: An integer. */ public int maxDepth(TreeNode root) &#123; if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); int depth = 0; //表示二叉树的深度 int count = 0; //表示已从队列中取出当前层的个数 int amount = 1; //表示当前节点的兄弟节点个数 while (queue.size() != 0) &#123; TreeNode top = queue.poll(); count++; if (top.left != null) &#123; queue.add(top.left); &#125; if (top.right != null) &#123; queue.add(top.right); &#125; if (count == amount) &#123; amount = queue.size(); count = 0; depth++; &#125; &#125; return depth; &#125;&#125; 原题地址LintCode：二叉树的最大深度]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超级丑数]]></title>
    <url>%2Fsuper-ugly-number%2F</url>
    <content type="text"><![CDATA[题意写一个程序来找第 n 个超级丑数。 超级丑数的定义是正整数并且所有的质数因子都在所给定的一个大小为 k 的质数集合内。 比如给你 4 个质数的集合 [2, 7, 13, 19], 那么 [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] 是前 12 个超级丑数。 注意事项1 永远都是超级丑数不管给的质数集合是什么。给你的质数集合已经按照升序排列。0 &lt; k ≤ 100, 0 &lt; n ≤ 10^6, 0 &lt; primes[i] &lt; 1000 样例给出 n = 6 和质数集合 [2, 7, 13, 19]。第 6 个超级丑数为 13，所以返回 13 作为结果。 思路这道题其实就是丑数II 的加强版，只是原来的丑数定义质因子是固定的 3 个，现在是自定义的质因子。 只需要将 丑数II 中的 lastUgly 用数组存放起来即可，其他思路还是一样的。 代码实现12345678910111213141516171819202122232425262728public class Solution &#123; /** * @param n a positive integer * @param primes the given prime list * @return the nth super ugly number */ public int nthSuperUglyNumber(int n, int[] primes) &#123; int[] uglys = new int[n]; int[] idxPrimes = new int[primes.length]; uglys[0] = 1; for (int i = 1; i &lt; n; i++) &#123; int min = Integer.MAX_VALUE; for (int j = 0; j &lt; primes.length; j++) &#123; min = Math.min(min, primes[j] * uglys[idxPrimes[j]]); &#125; uglys[i] = min; for (int j = 0; j &lt; primes.length; j++) &#123; if (primes[j] * uglys[idxPrimes[j]] == min) &#123; idxPrimes[j]++; &#125; &#125; &#125; return uglys[n - 1]; &#125;&#125; 原题地址LintCode：超级丑数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丑数II]]></title>
    <url>%2Fugly-number-ii%2F</url>
    <content type="text"><![CDATA[题意设计一个算法，找出只含素因子2，3，5 的第 n 大的数。 符合条件的数如：1, 2, 3, 4, 5, 6, 8, 9, 10, 12... 注意事项：我们可以认为 1 也是一个丑数 样例如果n = 9， 返回 10 思路其实改题的题意就是在所有 丑数 列表中，找到第 n 个丑数。 最简单的做法是从 1 开始，判断每一个数是否是一个丑数，是的话则加到丑数列表中，直到丑数列表的大小等于 n，但是这种方法效率较低，我们可以根据规律而尝试只创造出有效的丑数。 1*2=2 2*2=4 3*2=6 4*2=8 5*2=10 ... 1*3=3 2*3=6 3*3=9 4*3=12 5*3=15 ... 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 ... 观察规律可得，丑数是取已有的丑数乘以 2 或 3 或 5 得到的，那么我们可以先将特殊的丑数 1 放进丑数列表中。 因为已存在的丑数肯定在列表中是按照顺序存放的，所以对于乘以 2 而言，肯定存在一个丑数 p2，在它之前的每一个丑数乘以 2 都是当前列表中最后一个丑数的，通用，在它之后的每一个丑数乘以 2 的结果都是大于当前列表中最后一个丑数的，我们只需要记住 p2 的这个位置，同样存在的还有 p3 和 p5，记住这 3 个数的位置，就可以一些避免不必要的比较。 我们只需要取出 p2, p3, p5 位置的那个数，分别乘以 2, 3, 5 将结果最小的存入到丑数列表中即可。直到丑数列表的个数达到 n。 代码实现12345678910111213141516171819202122232425262728public class Solution &#123; /* * @param n: An integer * @return: the nth prime number as description. */ public int nthUglyNumber(int n) &#123; if (n == 1) &#123; return 1; &#125; List&lt;Integer&gt; uglys = new ArrayList&lt;Integer&gt;(); uglys.add(1); int p2 = 0, p3 = 0, p5 = 0; for (int i = 1; i &lt; n; i++) &#123; int lastUgly = uglys.get(i - 1); while (uglys.get(p2) * 2 &lt;= lastUgly) p2++; while (uglys.get(p3) * 3 &lt;= lastUgly) p3++; while (uglys.get(p5) * 5 &lt;= lastUgly) p5++; uglys.add(Math.min( Math.min(uglys.get(p2) * 2, uglys.get(p3) * 3), uglys.get(p5) * 5) ); &#125; return uglys.get(n -1); &#125;&#125;; 原题地址LintCode：丑数II]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丑数]]></title>
    <url>%2Fugly-number%2F</url>
    <content type="text"><![CDATA[题意写一个程序来检测一个整数是不是丑数。 丑数的定义是，只包含质因子 2, 3, 5 的正整数。比如 6, 8 就是丑数，但是 14 不是丑数以为他包含了质因子 7。 注意事项 可以认为 1 是一个特殊的丑数。 样例给出 num = 8，返回 true。给出 num = 14，返回 false。 思路使 sum 依次对 2, 3, 5 相除，直到与 2, 3, 5 的余数不为 0，最终 sum 为 1，则代表该数只能被 2, 3, 5整除，返回 true，反之返回 false。 代码实现12345678910111213141516public class Solution &#123; /* * @param num: An integer * @return: true if num is an ugly number or false */ public boolean isUgly(int num) &#123; if (num == 1) return true; while (num &gt;= 2 &amp;&amp; num % 2 == 0) num /= 2; while (num &gt;= 3 &amp;&amp; num % 3 == 0) num /= 3; while (num &gt;= 5 &amp;&amp; num % 5 == 0) num /= 5; return num == 1; &#125;&#125; 原题地址LintCode：丑数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快乐数]]></title>
    <url>%2Fhappy-number%2F</url>
    <content type="text"><![CDATA[题意写一个算法来判断一个数是不是”快乐数”。 一个数是不是快乐是这么定义的：对于一个正整数，每一次将该数替换为他每个位置上的数字的平方和，然后重复这个过程直到这个数变为1，或是无限循环但始终变不到1。如果可以变为1，那么这个数就是快乐数。 样例19 就是一个快乐数。 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1 思路依次取每一位的平方来计算当前数的快乐数，并将计算出的快乐数存到一个不重复集合中，一旦快乐数与集合中的元素存在重复，则说明会无限循环，该数就不是一个快乐数、 代码实现12345678910111213141516171819202122232425262728public class Solution &#123; /* * @param n: An integer * @return: true if this is a happy number or false */ public int getNextHappy(int n) &#123; int sum = 0; while (n != 0) &#123; sum += (n % 10) * (n % 10); n /= 10; &#125; return sum; &#125; public boolean isHappy(int n) &#123; HashSet&lt;Integer&gt; hash = new HashSet&lt;Integer&gt;(); while (n != 1) &#123; if (hash.contains(n)) &#123; return false; &#125; hash.add(n); n = getNextHappy(n); &#125; return true; &#125;&#125; 原题地址LintCode：快乐数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[报数]]></title>
    <url>%2Fcount-and-say%2F</url>
    <content type="text"><![CDATA[题意报数指的是，按照其中的整数的顺序进行报数，然后得到下一个数。如下所示： 1, 11, 21, 1211, 111221, ... 1 读作 &quot;one 1&quot; -&gt; 11. 11 读作 &quot;two 1s&quot; -&gt; 21. 21 读作 &quot;one 2, then one 1&quot; -&gt; 1211. 给定一个整数 n, 返回 第 n 个顺序。 样例给定 n = 5, 返回 &quot;111221&quot;. 思路这道题的题意不太容易理解，提示是： n = 1 时输出字符串 1，n = 2 时由于上次字符串为 1，所以记作一个 1，也就是输出 11，n = 3 时，由于上一个输出是 11，记作两个 1，输出 21。以此类推……，有点类似于 斐波那契数列。 题意理解后就容易做了，可以用递归法或循环即可。 代码实现123456789101112131415161718192021222324252627public class Solution &#123; /* * @param n: the nth * @return: the nth sequence */ //递归法 public String countAndSay(int n) &#123; String str = "1"; while (--n &gt; 0) &#123; StringBuilder sb = new StringBuilder(); char[] c = str.toCharArray(); for (int i = 0; i &lt; c.length; i++) &#123; int count = 1; while ((i + 1) &lt; c.length &amp;&amp; c[i] == c[i + 1]) &#123; count++; i++; &#125; sb.append(String.valueOf(count) + String.valueOf(c[i])); &#125; str = sb.toString(); &#125; return str; &#125;&#125;; 原题地址LintCode：报数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入区间]]></title>
    <url>%2Finsert-interval%2F</url>
    <content type="text"><![CDATA[题意给出一个无重叠的按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 样例插入区间 [2, 5] 到 [[1,2], [5,9]]，我们得到 [[1,9]]。 插入区间 [3, 4] 到 [[1,2], [5,9]]，我们得到 [[1,2], [3,4], [5,9]]。 思路这是一个有序的区间列表，只要依次遍历，判断当前元素与插入元素的关系。 如当前元素的右端点小于插入元素的左端点，则说明当前元素与插入元素无交并。 如当前元素的左端点大于插入元素的右端点，也说明当前元素与插入元素无交并。 否者，则代表当前元素与插入元素有交并，将其合并区间。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition of Interval: * public classs Interval &#123; * int start, end; * Interval(int start, int end) &#123; * this.start = start; * this.end = end; * &#125; * &#125; */public class Solution &#123; /* * @param intervals: Sorted interval list. * @param newInterval: new interval. * @return: A new interval list. */ public ArrayList&lt;Interval&gt; insert(ArrayList&lt;Interval&gt; intervals, Interval newInterval) &#123; if (newInterval == null || intervals == null) &#123; return intervals; &#125; ArrayList&lt;Interval&gt; results = new ArrayList&lt;Interval&gt;(); int insertPos = 0; for (Interval interval : intervals) &#123; if (interval.end &lt; newInterval.start) &#123; results.add(interval); insertPos++; &#125; else if (interval.start &gt; newInterval.end) &#123; results.add(interval); &#125; else &#123; newInterval.start = Math.min(interval.start, newInterval.start); newInterval.end = Math.max(interval.end, newInterval.end); &#125; &#125; results.add(insertPos, newInterval); return results; &#125;&#125; 原题地址LintCode：插入区间]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[合并区间]]></title>
    <url>%2Fmerge-intervals%2F</url>
    <content type="text"><![CDATA[题意给出若干闭合区间，合并所有重叠的部分。 样例给出若干闭合区间，合并所有重叠的部分。 [ [ [1, 3], [1, 6], [2, 6], =&gt; [8, 10], [8, 10], [15, 18] [15, 18] ] ] 思路题目没有说是有序的集合，所以我们要进行先根据左端点进行排序，排序后，判断右端点与下一个节点的左端点的大小来决定是否合并区间。 代码实现1234567891011121314151617181920212223242526272829303132333435363738/** * Definition of Interval: * public class Interval &#123; * int start, end; * Interval(int start, int end) &#123; * this.start = start; * this.end = end; * &#125; */class Solution &#123; /** * @param intervals, a collection of intervals * @return: A new sorted interval list. */ public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; ans = new ArrayList&lt;Interval&gt;(); Collections.sort(intervals, new Comparator&lt;Interval&gt;()&#123; @Override public int compare(Interval obj1, Interval obj2)&#123; return obj1.start - obj2.start; &#125; &#125;); Interval last = null; for (Interval item : intervals) &#123; if (last == null || last.end &lt; item.start) &#123; ans.add(item); last = item; &#125; else &#123; last.end = Math.max(last.end, item.end); &#125; &#125; return ans; &#125;&#125; 原题地址LintCode：合并区间]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[落单的数Ⅲ]]></title>
    <url>%2Fsingle-number-iii%2F</url>
    <content type="text"><![CDATA[题意给出2*n + 2个的数字，除其中两个数字之外其他每个数字均出现两次，找到这两个数字。 样例给出 [1,2,2,3,4,4,5,3]，返回 1 和 5 思路这道题用到了很多位运算的小技巧。 首先将数组中所有的数进行异或，最终的结果就是两个落单的数的异或值。 根据异或的规律：两值相同则为 0，不同则为 1。两者又是两个不同的数，所以最后异或的结果肯定不为 0. 然后取出异或值的二进制位中最低一个值为 1 的数。例如对于异或值：60（111100），取最低一个值为 1 的数，也就是：4 (100)。 然后将数组所有数与这个数进行与运算，将结果为 0 的数分为一组，非 0 的数分为另一组。由于上方异或得到的规律可得，两个落单的数，肯定在两个不同的组里。 在对这两组进行 落单的数 中的操作即可分别得到两个落单的数。 代码实现123456789101112131415161718192021222324252627282930public class Solution &#123; /** * @param A : An integer array * @return : Two integers */ public List&lt;Integer&gt; singleNumberIII(int[] A) &#123; int xor = 0; // xor 代表的是落单的两个数的异或值 for (int i = 0; i &lt; A.length; i++) &#123; xor ^= A[i]; &#125; //lastBit 代表的是 xor 的二进制位中最低一个值为 1 的数。 int lastBit = xor - (xor &amp; (xor - 1)); int r1 = 0, r2 = 0; for (int i = 0 ; i &lt; A.length; i++) &#123; if ((lastBit &amp; A[i]) == 0) &#123; r1 ^= A[i]; &#125; else &#123; r2 ^= A[i]; &#125; &#125; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(r1); list.add(r2); return list; &#125;&#125; 原题地址LintCode：落单的数Ⅲ]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[落单的数Ⅱ]]></title>
    <url>%2Fsingle-number-ii%2F</url>
    <content type="text"><![CDATA[题意给出 3*n + 1 个的数字，除其中一个数字之外其他每个数字均出现三次，找到这个数字。 样例给出 [1,1,2,3,3,3,2,2,4,1] ，返回 4 思路这道题跟 落单的数 很类似，只不过这里就不能简单的使用异或运算来得出结果了。 可以记录 32 位二进制中 1 出现的个数，当个数达到 3，则将个数归零。最终剩下的就是落单的数。 如一个数组 [2, 2, 2, 3] : 2 的二进制是 0000 0000 0000 0000 0000 0000 0000 00103 的二进制是 0000 0000 0000 0000 0000 0000 0000 0011 将数组中所有元素的二进制位 1 的数量加在一起就是 0000 0000 0000 0000 0000 0000 0000 0041 当个数达到3，则将个数归零，最终结果就是 0000 0000 0000 0000 0000 0000 0000 0011 在实际计算中每次是取一位，也就是第一次取到的是 1，第二次取到的是 4，4 满 3 对三取模即可（4 % 3），所以第二次取到的数应该算为 1。将这些单独位的二进制数再拼凑到一次。只需要进行 或运算 。 1234 0000 0000 0000 0000 0000 0000 0000 0001| 0000 0000 0000 0000 0000 0000 0000 0010----------------------------------------- 0000 0000 0000 0000 0000 0000 0000 0011 如此即可将每一位的 1 拼凑到一起。 代码实现12345678910111213141516171819public class Solution &#123; /** * @param A : An integer array * @return : An integer */ public int singleNumberII(int[] A) &#123; int count = 0; int result = 0; for (int i = 0; i &lt; 32; i++) &#123; for (int j = 0; j &lt; A.length; j++) &#123; count += A[j] &gt;&gt; i &amp; 1; count %= 3; &#125; result |= count &lt;&lt; i; count = 0; &#125; return result; &#125;&#125; 原题地址LintCode：落单的数Ⅱ]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[落单的数]]></title>
    <url>%2Fsingle-number%2F</url>
    <content type="text"><![CDATA[题意给出 2*n + 1 个的数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。 样例给出[1,2,2,1,3,4,3]，返回 4 思路在位运算中，异或（^）是将该数的二进制每一位进行异或运算，当前位的两个二进制表示不同则为 1 ，相同则为 0。 根据此特性，可以得出结论：两个相同的数进行异或运算的结果为 0。 即：5 ^ 5 = 0,那么 5 ^ 5 ^ 6 的结果就是 6，这样就符合本题的要求了，6 就是那个 2n + 1 中的 1，即落单的数。 代码实现1234567891011121314public class Solution &#123; /** *@param A : an integer array *return : a integer */ public int singleNumber(int[] A) &#123; int r = 0; for (int i = 0; i &lt; A.length; i++) &#123; r ^= A[i]; &#125; return r; &#125;&#125; 原题地址LintCode：落单的数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>数组</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小差]]></title>
    <url>%2Fthe-smallest-difference%2F</url>
    <content type="text"><![CDATA[题意给定两个整数数组（第一个是数组 A，第二个是数组 B），在数组 A 中取 A[i]，数组 B 中取 B[j]，A[i] 和 B[j]两者的差越小越好(|A[i] - B[j]|)。返回最小差。 样例给定数组 A = [3,4,6,7]， B = [2,3,8,9]，返回 0。 思路首先对两个数组进行排序，然后设 2 个指针 i, j 分别指向 A 和 B 的第一个元素，依次向后遍历，取 A[i] - A[j] 的绝对值，就是差值，将遍历过程中最小的差值记录下来，若遍历过程中 A[i] == A[j] ，那么就直接返回 0。 代码实现1234567891011121314151617181920212223242526272829public class Solution &#123; /** * @param A, B: Two integer arrays. * @return: Their smallest difference. */ public int smallestDifference(int[] A, int[] B) &#123; if (A == null || A.length == 0 || B == null || B.length == 0) &#123; return 0; &#125; Arrays.sort(A); Arrays.sort(B); int i = 0; int j = 0; int min = Integer.MAX_VALUE; while (i &lt; A.length &amp;&amp; j &lt; B.length) &#123; min = Math.min(min, Math.abs(A[i] - B[j])); if (A[i] &gt; B[j]) &#123; j++; &#125; else if (A[i] &lt; B[j]) &#123; i++; &#125; else &#123; return 0; &#125; &#125; return min; &#125;&#125; 原题地址LintCode：最小差]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>两根指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长上升子序列]]></title>
    <url>%2Flongest-increasing-subsequence%2F</url>
    <content type="text"><![CDATA[题意给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。 最长上升子序列问题是在一个无序的给定序列中找到一个尽可能长的由低到高排列的子序列，这种子序列不一定是连续的或者唯一的。 样例给出 [5,4,1,2,3]，LIS 是 [1,2,3]，返回 3给出 [4,2,4,5,3,7]，LIS 是 [2,4,5,7]，返回 4 思路如 1, 3, 5, 2, 8, 4, 6，对于 6 来说，它的 LIS 是它的前一个数，也就是 4 小于它（4 &lt; 6）的情况下，将 4 的（LIS + 1）就是 6 个 LIS，以此类推。 代码实现1234567891011121314151617181920212223242526public class Solution &#123; /** * @param nums: The integer array * @return: The length of LIS (longest increasing subsequence) */ public int longestIncreasingSubsequence(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int[] lis = new int[nums.length]; int max = 0; for (int i = 0; i &lt; nums.length; i++) &#123; int tempMax = 0; for (int j = 0; j &lt; i; j++) &#123; if (lis[j] &gt; tempMax &amp;&amp; nums[j] &lt; nums[i]) tempMax = lis[j]; &#125; lis[i] = tempMax + 1; max = lis[i] &gt; max ? lis[i] : max; &#125; return max; &#125;&#125; 原题地址LintCode：最长上升子序列]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动零]]></title>
    <url>%2Fmove-zeroes%2F</url>
    <content type="text"><![CDATA[题意给一个数组 nums 写一个函数将 0 移动到数组的最后面，非零元素保持原数组的顺序 注意事项：必须在原数组上操作最小化操作数 样例给出 nums = [0, 1, 0, 3, 12], 调用函数之后, nums = [1, 3, 12, 0, 0]. 思路设两个指针，先都指向数组头元素，一个依次向后找不为零的数，然后与另一个指向的数进行交换，直到找到最后一个元素为止。 代码实现12345678910111213141516171819public class Solution &#123; /** * @param nums an integer array * @return nothing, do this in-place */ public void moveZeroes(int[] nums) &#123; int left = 0; int right = 0; while (right &lt; nums.length) &#123; if (nums[right] != 0) &#123; int temp = nums[right]; nums[right] = nums[left]; nums[left] = temp; left++; &#125; right++; &#125; &#125;&#125; 原题地址LintCode：移动零]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>两根指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断字符串是否没有重复元素]]></title>
    <url>%2Funique-characters%2F</url>
    <content type="text"><![CDATA[题意实现一个算法确定字符串中的字符是否均唯一出现 样例给出 &quot;abc&quot;，返回 true 给出 &quot;aab&quot;，返回 false 思路解法一：可以利用查表法，首先建立一个大小为 256 位的布尔类型的数组，因为 ASCII 表中一共就有 256 的字符，依次取字符串中的每一个位，将其在 ASCII 表中的位置放到数组中，True 表示该字符已存在，Flase 则表示该字符不存在。 解法二：不利用额外空间的话，就将当前位与剩余位依次进行比较才能实现，比较消耗时间。 代码实现解法一1234567891011121314151617181920public class Solution &#123; /** * @param str: a string * @return: a boolean */ public boolean isUnique(String str) &#123; if (str == null) return false; boolean[] char_set = new boolean[256]; for (int i = 0; i &lt; str.length(); i++) &#123; int var = str.charAt(i); if (char_set[var]) return false; char_set[var] = true; &#125; return true; &#125;&#125; 解法二：12345678910111213141516171819public class Solution &#123; /** * @param str: a string * @return: a boolean */ public boolean isUnique(String str) &#123; if (str == null || str.length() == 0) return false; for (int i = 0; i &lt; str.length(); i++) &#123; for (int j = i + 1; j &lt; str.length(); j++) &#123; if (str.charAt(i) == str.charAt(j)) return false; &#125; &#125; return true; &#125;&#125; 原题地址LintCode：判断字符串是否没有重复字符]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2Ftwo-sum%2F</url>
    <content type="text"><![CDATA[题意给一个整数数组，找到两个数使得他们的和等于一个给定的数 target。 你需要实现的函数 twoSum 需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是 1 到 n，不是以 0 开头。 样例给出 numbers = [2, 7, 11, 15], target = 9, 返回 [1, 2]。 思路可以用一个 Map 集合，遍历数组，先记录下当前数与目标数的差值与角标，然后寻找与这个差值相同的数，找到后，将这两个数的角标加 1 后返回即可。 代码实现123456789101112131415161718192021public class Solution &#123; /* * @param numbers : An array of Integer * @param target : target = numbers[index1] + numbers[index2] * @return : [index1 + 1, index2 + 1] (index1 &lt; index2) */ public int[] twoSum(int[] numbers, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) &#123; if (map.get(numbers[i]) != null) &#123; int[] result = &#123;map.get(numbers[i]) + 1, i + 1&#125;; return result; &#125; map.put(target - numbers[i], i); &#125; int[] nums = &#123;&#125;; return nums; &#125;&#125; 原题地址LintCode：两数之和]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>两根指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索插入位置]]></title>
    <url>%2Fsearch-insert-position%2F</url>
    <content type="text"><![CDATA[题意给定一个排序数组和一个目标值，如果在数组中找到目标值则返回索引。如果没有，返回到它将会被按顺序插入的位置。 你可以假设在数组中无重复元素。 样例[1,3,5,6]，5 → 2 [1,3,5,6]，2 → 1 [1,3,5,6]，7 → 4 [1,3,5,6]，0 → 0 思路跟普通的二分查找类似，循环的条件是 min &lt;= max，如果 target 和 mid 指向的值相等，则返回 mid，否则根据情况 min = mid + 1 或者max = mid - 1。这样如果找不到该数，max 是比该数小的那个数的下标，而 min 是比该数大的那个数的下标。这题中，我们返回 min 就行了，如果返回 max，要注意 -1 的情况。 代码实现1234567891011121314151617181920212223242526272829public class Solution &#123; /** * param A : an integer sorted array * param target : an integer to be inserted * return : an integer */ public int searchInsert(int[] A, int target) &#123; int min = 0; int max = A.length - 1; if (A == null || A.length == 0) &#123; return 0; &#125; while (min &lt;= max) &#123; int mid = min + (max - min) / 2; if (A[mid] == target) &#123; return mid; &#125; else if (A[mid] &gt; target) &#123; max = mid - 1; &#125; else &#123; min = mid + 1; &#125; &#125; return min; &#125;&#125; 原题地址LintCode：搜索插入位置]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除元素]]></title>
    <url>%2Fremove-element%2F</url>
    <content type="text"><![CDATA[题意给定一个数组和一个值，在原地删除与值相同的数字，返回新数组的长度。 元素的顺序可以改变，并且对新的数组不会有影响。 样例给出一个数组 [0,4,4,0,0,2,4,4]，和值 4 返回 4 并且数组前4个元素为 [0,0,0,2] 思路设两个指针，一个指向当数组头，一个指向数组尾，将头指针依次想尾指针靠近，如果过程中有值等于要删除的值，则将尾指针的值与头指针的值交换，知道两个指针碰头。 代码实现1234567891011121314151617181920public class Solution &#123; /** *@param A: A list of integers *@param elem: An integer *@return: The new length after remove */ public int removeElement(int[] A, int elem) &#123; int i = 0; int j = A.length - 1; while (i &lt;= j) &#123; if (A[i] == elem) &#123; A[i] = A[j]; j--; &#125; else &#123; i++; &#125; &#125; return i; &#125;&#125; 原题地址LintCode：删除元素]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>两根指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除排序数组中的重复数字Ⅱ]]></title>
    <url>%2Fremove-duplicates-from-sorted-array-ii%2F</url>
    <content type="text"><![CDATA[题意根据 删除排序数组中的重复数字 中的题意，跟进 ”删除重复数字“，如果可以允许出现两次重复将如何处理？ 样例给出数组 A = [1,1,2,2,2,3]，你的函数应该返回长度 5，此时 A = [1,1,2,2,3]。 思路这道题跟 删除排序数组中的重复数字 差不多，无非就是多判断一次，判断是否有两个连续的重复元素即可。 代码实现12345678910111213141516171819202122232425262728public class Solution &#123; /** * @param A: a array of integers * @return : return an integer */ public int removeDuplicates(int[] nums) &#123; if (nums == null) &#123; return 0; &#125; int index = 0; int i, j; for (i = 0; i &lt; nums.length;) &#123; int now = nums[i]; for (j = i; j &lt; nums.length; j++) &#123; if (nums[j] != now) break; if (j - i &lt; 2) &#123; nums[index++] = now; &#125; &#125; i = j; &#125; return index; &#125;&#125; 原题地址LintCode：删除排序数组中的重复数组Ⅱ]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文文案排版指北「转载」]]></title>
    <url>%2Fchinese-copywriting-guidelines%2F</url>
    <content type="text"><![CDATA[前言作为一个博主，我认为文章的排版还是很重要的，一份好的排版的文章也是对读者的一份尊重，就好像在博客中代码要用代码块高亮起来一样。 我也经常遇到问题时去看别人的博客，但是好多博主的排版甚是难看，有些甚至连最基本的代码块都没有，看起来很是不舒服，所以今天发布一篇关于排版的文章，希望其他的博主看到以后，可以重视起来，养成一个良好的排版习惯，方便自己也方便他人。 本文摘自 GitHub 上的 中文文案排版指北。 空格「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」——vinta/paranoid-auto-spacing 中英文之间需要增加空格正确： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。 错误： 在LeanCloud上，数据存储是围绕AVObject进行的。在 LeanCloud上，数据存储是围绕AVObject 进行的。 完整的正确用法： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。 例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。 中文与数字之间需要增加空格正确： 今天出去买菜花了 5000 元。 错误： 今天出去买菜花了 5000元。今天出去买菜花了5000元。 数字与单位之间需要增加空格正确： 我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。 错误： 我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。 例外：度／百分比与数字之间不需要增加空格： 正确： 今天是 233° 的高温。新 MacBook Pro 有 15% 的 CPU 性能提升。 错误： 今天是 233 ° 的高温。新 MacBook Pro 有 15 % 的 CPU 性能提升。 全角标点与其他字符之间不加空格正确： 刚刚买了一部 iPhone，好开心！ 错误： 刚刚买了一部 iPhone ，好开心！ -ms-text-autospace to the rescue?Microsoft 有个 -ms-text-autospace.aspx) 的 CSS 属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 OS X、iOS 的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。 标点符号不重复使用标点符号正确： 德国队竟然战胜了巴西队！她竟然对你说「喵」？！ 错误： 德国队竟然战胜了巴西队！！德国队竟然战胜了巴西队！！！！！！！！她竟然对你说「喵」？？！！她竟然对你说「喵」？！？！？？！！ 全角和半角不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』。 使用全角中文标点正确： 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！核磁共振成像（NMRI）是什么原理都不知道？JFGI！ 错误： 嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎!嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎!核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!核磁共振成像(NMRI)是什么原理都不知道?JFGI! 数字使用半角字符正确： 这件蛋糕只卖 1000 元。 错误： 这件蛋糕只卖 １０００ 元。 例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。 遇到完整的英文整句、特殊名词，其內容使用半角标点正确： 乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。 错误： 乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。 名词专有名词使用正确的大小写大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。 正确： 使用 GitHub 登录我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。 错误： 使用 github 登录使用 GITHUB 登录使用 Github 登录使用 gitHub 登录使用 gｲんĤЦ8 登录我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。 注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标准的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。 不要使用不地道的缩写正确： 我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。 错误： 我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。 争议以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。 链接之间增加空格用法： 请 提交一个 issue 并分配给相关同事。访问我们网站的最新动态，请 点击这里 进行订阅！ 对比用法： 请提交一个 issue 并分配给相关同事。访问我们网站的最新动态，请点击这里进行订阅！ 简体中文使用直角引号用法： 「老师，『有条不紊』的『紊』是什么意思？」 对比用法： “老师，‘有条不紊’的‘紊’是什么意思？” 工具 仓库 语言 vinta/paranoid-auto-spacing JavaScript huei90/pangu.node Node.js huacnlee/auto-correct Ruby sparanoid/space-lover PHP (WordPress) nauxliu/auto-correct PHP ricoa/copywriting-correct PHP hotoo/pangu.vim Vim sparanoid/grunt-auto-spacing Node.js (Grunt) hjiang/scripts/add-space-between-latin-and-cjk Python 谁在这样做？ 网站 文案 UGC Apple 中国 Yes N/A Apple 香港 Yes N/A Apple 台湾 Yes N/A Microsoft 中国 Yes N/A Microsoft 香港 Yes N/A Microsoft 台湾 Yes N/A LeanCloud Yes N/A 知乎 Yes 部分用户达成 V2EX Yes Yes SegmentFault Yes 部分用户达成 Apple4us Yes N/A 豌豆荚 Yes N/A Ruby China Yes 标题达成 PHPHub Yes 标题达成 少数派 Yes N/A 参考文献 Guidelines for Using Capital Letters Letter case - Wikipedia Punctuation - Oxford Dictionaries Punctuation - The Purdue OWL How to Use English Punctuation Corrently - wikiHow 格式 - openSUSE 全角和半角 - 维基百科 引号 - 维基百科 疑问惊叹号 - 维基百科]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>排版</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除排序数组中的重复数字]]></title>
    <url>%2Fremove-duplicates-from-sorted-array%2F</url>
    <content type="text"><![CDATA[题意给定一个排序数组，在原数组中删除重复出现的数字，使得每个元素只出现一次，并且返回新的数组的长度。 不要使用额外的数组空间，必须在原地没有额外空间的条件下完成。 样例给出数组nums =[5,6,8,9,9,10]，你的函数应该返回长度5，此时nums = [5,6,8,9,10]。 思路用 2 个指针，一个指有效元素的长度，一个从前向后扫，跳过重复的元素，将不重复的元素依次放到数组前方，最后返回有效元素的长度即可。 代码实现123456789101112131415161718public class Solution &#123; /** * @param A: a array of integers * @return : return an integer */ public int removeDuplicates(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int size = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[size] != nums[i]) &#123; nums[++size] = nums[i]; &#125; &#125; return size + 1; &#125;&#125; 原题地址LintCode：删除排序数组中的重复数字]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恢复旋转排序数组]]></title>
    <url>%2Frecover-rotated-sorted-array%2F</url>
    <content type="text"><![CDATA[题意给定一个旋转排序数组，在原地恢复其排序。 什么是旋转数组？ 比如，原始数组为[1,2,3,4], 则其旋转数组可以是[1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3] 样例[4, 5, 1, 2, 3] -&gt; [1, 2, 3, 4, 5] 思路遍历数组，首先找到当前数大于下一个数的位置，也就是样例中的 5，然后将数组开头的元素到 5 进行翻转，结果是 [5, 4, 1, 2, 3]，然后将后面的元素进行翻转，结果是 [5, 4, 3, 2, 1]，再将整个数组翻转，就得到了最终结果。 代码实现123456789101112131415161718192021222324public class Solution &#123; /** * @param nums: The rotated sorted array * @return: The recovered sorted array */ public void recoverRotatedSortedArray(List&lt;Integer&gt; nums) &#123; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; if (nums.get(i) &gt; nums.get(i + 1)) &#123; reverse(nums, 0, i); reverse(nums, i + 1, nums.size() - 1); reverse(nums, 0, nums.size() - 1); return; &#125; &#125; &#125; public void reverse(List&lt;Integer&gt; list, int start, int end) &#123; for (int i = start, j = end; i &lt; j; i++, j--) &#123; int temp = list.get(i); list.set(i, list.get(j)); list.set(j, temp); &#125; &#125;&#125;; 原题地址LintCode：恢复旋转排序数组]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加一]]></title>
    <url>%2Fplus-one%2F</url>
    <content type="text"><![CDATA[题意给定一个非负数，表示一个数字数组，在该数的基础上+1，返回一个新的数组。 该数字按照大小进行排列，最大的数在列表的最前面。 样例给定 [1,2,3] 表示 123, 返回 [1,2,4]. 给定 [9,9,9] 表示 999, 返回 [1,0,0,0]. 思路定义一个变量存储进位数，默认值为 1，然后倒序取数组中的每个元素，依次加上进位数，加上后的值对 10 整除则是新的进位数，对 10 取模则是保留数。 当计算完数组中所有元素，如果进位数还大于0，则创建一个新的数组，在原数组的首元素之前加上进位数即可。 代码实现123456789101112131415161718192021222324public class Solution &#123; /** * @param digits a number represented as an array of digits * @return the result */ public int[] plusOne(int[] digits) &#123; int carry = 1; for (int i = digits.length - 1; i &gt;= 0; i--) &#123; int sum = digits[i] + carry; carry = sum / 10; digits[i] = sum % 10; &#125; if (carry != 0) &#123; int[] temp = new int[digits.length + 1]; temp[0] = carry; for (int i = 0; i &lt; digits.length - 1; i++) &#123; temp[i + 1] = digits[i]; &#125; return temp; &#125; return digits; &#125;&#125; 原题地址LintCode：加一]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小子数组]]></title>
    <url>%2Fminimum-subarray%2F</url>
    <content type="text"><![CDATA[题意给定一个整数数组，找到一个具有最小和的子数组。返回其最小和。 注意事项：子数组最少包含一个数字 样例给出数组[1, -1, -2, 1]，返回 -3 思路该题与 最大子数组 这道题，思路相似，只不过这里是 ArrayList 而已，差距不大。 代码实现12345678910111213141516public class Solution &#123; /** * @param nums: a list of integers * @return: A integer indicate the sum of minimum subarray */ public int minSubArray(ArrayList&lt;Integer&gt; nums) &#123; int min = Integer.MAX_VALUE; int sum = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; sum += nums.get(i); min = sum &lt; min ? sum : min; sum = sum &lt; 0 ? sum : 0; &#125; return min; &#125;&#125; 原题地址LintCode：最小子数组]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>数组</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合并排序数组 Ⅱ]]></title>
    <url>%2Fmerge-sorted-array%2F</url>
    <content type="text"><![CDATA[题意合并两个排序的整数数组 A 和 B 变成一个新的数组。 注意事项：你可以假设A具有足够的空间（A数组的大小大于或等于 m + n）去添加B中的元素。 ps：m 表示 A 数组的有效元素个数，n 代表 B 数组的有效元素个数。 样例给出 A = [1, 2, 3, empty, empty], B = [4, 5] 合并之后 A 将变成 [1,2,3,4,5] 思路可以正序比较 A 数组与 B 数组的每一位，小的放前，其他的元素依次向后移动，但是依次向后移动这个成本太高了。 所以可以考虑倒序比较，根据数组 A 与数组 B 的最后一个有效位，进行倒序的比较，将大的添加到 A 的最后放即可。 这里要搞清楚的是 A 的最后一个有效位与 A 的最后一位的区别，A 的最后一个有效位是指 A[m-1]，而 A 的最后一位是指 A[A.length-1]。 代码实现1234567891011121314151617181920212223242526272829class Solution &#123; /** * @param A: sorted integer array A which has m elements, * but size of A is m+n * @param B: sorted integer array B which has n elements * @return: void */ public void mergeSortedArray(int[] A, int m, int[] B, int n) &#123; int i = m - 1; int j = n - 1; int index = m + n -1; while (i &gt;= 0 &amp;&amp; j &gt;=0) &#123; if (A[i] &gt; B[j]) &#123; A[index--] = A[i--]; &#125; else &#123; A[index--] = B[j--]; &#125; &#125; while (i &gt;= 0) &#123; A[index--] = A[i--]; &#125; while (j &gt;= 0) &#123; A[index--] = B[j--]; &#125; &#125;&#125; 原题地址LintCode：合并排序数组Ⅱ]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合并排序数组]]></title>
    <url>%2Fmerge-two-sorted-arrays%2F</url>
    <content type="text"><![CDATA[题意合并两个排序的整数数组A和B变成一个新的数组。 样例给出A = [1,2,3,4]，B = [2,4,5,6]，返回 [1,2,2,3,4,4,5,6] 思路创建一个新的数组，长度是 A 和 B 长度之合，再设三个指针，分别指向 A，B 和新数组的第一个元素，然后遍历两个数组，依次比较每一个元素，较小的数存入新数组中，并将较小值的指针与新数组的指针向后移动一位。最后当遍历完 A 或 B 以后，就将剩余数组的数据依次添加到新数组。 代码实现1234567891011121314151617181920212223242526272829303132333435class Solution &#123; /** * @param A and B: sorted integer array A and B. * @return: A new sorted integer array */ public int[] mergeSortedArray(int[] A, int[] B) &#123; if (A == null || B == null) &#123; return null; &#125; int[] result = new int[A.length + B.length]; int i = 0; int j = 0; int index = 0; while (i &lt; A.length &amp;&amp; j &lt; B.length) &#123; if (A[i] &lt; B[j])&#123; result[index++] = A[i++]; &#125; else &#123; result[index++] = B[j++]; &#125; &#125; while (i &lt; A.length) &#123; result[index++] = A[i++]; &#125; while (j &lt; B.length) &#123; result[index++] = B[j++]; &#125; return result; &#125;&#125; 原题地址LintCode：合并排序数组]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子数组]]></title>
    <url>%2Fmaximum-subarray%2F</url>
    <content type="text"><![CDATA[题意给定一个整数数组，找到一个具有最大和的子数组，返回其最大和。 样例给出数组[−2,2,−3,4,−1,2,1,−5,3]，符合要求的子数组为[4,−1,2,1]，其最大和为 6 思路对数组进行遍历，每次取当前角标的数，加上 sum 值，如果 sum 值大于现存的最大值，那么则将 sum 赋值给 max，如果 sum 小于 0，则将 sum 重置为 0，直到循环结束。 代码实现123456789101112131415161718192021public class Solution &#123; /** * @param nums: A list of integers * @return: A integer indicate the sum of max subarray */ public int maxSubArray(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int max = Integer.MIN_VALUE; int sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; max = sum &gt; max ? sum : max; sum = sum &gt; 0 ? sum : 0; &#125; return max; &#125;&#125; 原题地址LintCode：最大子数组]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>数组</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长上升连续子序列]]></title>
    <url>%2Flongest-increasing-continuous-subsequence%2F</url>
    <content type="text"><![CDATA[题意给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列。（最长上升连续子序列可以定义为从右到左或从左到右的序列。） 样例给定 [5, 4, 2, 1, 3], 其最长上升连续子序列（LICS）为 [5, 4, 2, 1], 返回 4. 给定 [5, 1, 2, 3, 4], 其最长上升连续子序列（LICS）为 [1, 2, 3, 4], 返回 4. 思路max 存储最大的上升连续子序列count 记录可能为最大循环子序列的统计先从左侧开始循环，若当前数大于下一个数，那么 count++，如果 count &gt; max，则将 count 赋值给 max。然后从右侧向左开始循环，同理。 代码实现1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; /* * @param : An array of Integer * @return: an integer */ public int longestIncreasingContinuousSubsequence(int[] A) &#123; if (A == null || A.length == 0) &#123; return 0; &#125; int max = 1; int count = 1; for (int i = 0; i &lt; A.length - 1; i++) &#123; if (A[i] &lt; A[i + 1]) &#123; count++; &#125; else &#123; count = 1; &#125; max = count &gt; max ? count : max; &#125; count = 1; for (int i = A.length-1; i &gt; 0; i--) &#123; if (A[i] &lt; A[i - 1]) &#123; count++; &#125; else &#123; count = 1; &#125; max = count &gt; max ? count : max; &#125; return max; &#125;&#125; 原题地址LintCode：最长上升连续子序列]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2Ffirst-position-of-target%2F</url>
    <content type="text"><![CDATA[题意给定一个排序的整数数组（升序）和一个要查找的整数 target，用 O(logn) 的时间查找到 target 第一次出现的下标（从 0 开始），如果 target 不存在于数组中，返回 -1。 样例在数组 [1, 2, 3, 3, 4, 5, 10] 中二分查找 3，返回 2。 思路本题的要点是查找第一次出现的位置，所以当 nums[mid] == target 时，应该将这个 mid 值赋值给 end，这样才能保证查找到的是第一个。 代码实现12345678910111213141516171819202122232425262728class Solution &#123; /** * @param nums: The integer array. * @param target: Target to find. * @return: The first position of target. Position starts from 0. */ public int binarySearch(int[] nums, int target) &#123; int start = 0; int end = nums.length - 1; while (start &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[mid] == target) &#123; end = mid; &#125; else if(nums[mid] &lt; target) &#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; if (nums[end] == target) &#123; return end; &#125; return -1; &#125;&#125; 原题地址LintCode：二分查找]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序链表转换为二分查找树]]></title>
    <url>%2Fconvert-sorted-list-to-balanced-bst%2F</url>
    <content type="text"><![CDATA[题意给出一个所有元素以升序排序的单链表，将它转换成一棵高度平衡的二分查找树 样例 2 1-&gt;2-&gt;3 =&gt; / \ 1 3 3 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 =&gt; / \ 1 5 / \ / \ # 2 4 6 思路本题要求是高度平衡的二叉树，那就看作是标准的平衡二叉树。首先平衡二叉树要求左右子树的高度差不超过 1，我们把有序列表的中间节点作为根，即可保证左右子树的元素个数相差不超过1，只需要把每一个节点都看作是一棵树，递归取中间节点即可。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; * Definition of TreeNode: * public class TreeNode &#123; * public int val; * public TreeNode left, right; * public TreeNode(int val) &#123; * this.val = val; * this.left = this.right = null; * &#125; * &#125; */ public class Solution &#123; /** * @param head: The first node of linked list. * @return: a tree node */ public TreeNode sortedListToBST(ListNode head) &#123; if (head == null) &#123; return null; &#125; //先将链表转化为List，方便获取长度，并随机读取。 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); while (head != null) &#123; list.add(head.val); head = head.next; &#125; return toTreeNode(list, 0, list.size()-1); &#125; public TreeNode toTreeNode (List&lt;Integer&gt; list, int s, int e) &#123; //返回条件 if (s &gt; e) return null; int mid = (s + e) / 2; //把中间节点作为根 TreeNode root = new TreeNode(list.get(mid)); //分别递归左右子树 root.left = toTreeNode(list, s, mid - 1); root.right = toTreeNode(list, mid + 1, e); return root; &#125;&#125; 原题地址LintCode：排序列表转换为二分查找树]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>二叉树</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表求和 Ⅱ]]></title>
    <url>%2Fadd-two-numbers-ii%2F</url>
    <content type="text"><![CDATA[题意假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。 样例给出 6-&gt;1-&gt;7 + 2-&gt;9-&gt;5。即，617 + 295。 返回 9-&gt;1-&gt;2。即，912 。 思路本题类似于: 链表求和 只需要将链表以压栈的形式存入栈中，然后依次同栈顶取出每一个元素，进行上述 链表求和 的操作即可。 也可以进行 翻转链表 后在进行 链表求和 的操作即可。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; /** * @param l1: the first list * @param l2: the second list * @return: the sum list of l1 and l2 */ public ListNode addLists2(ListNode l1, ListNode l2) &#123; if (l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; Stack&lt;Integer&gt; stack1 = reverseNode(l1); Stack&lt;Integer&gt; stack2 = reverseNode(l2); ListNode point = new ListNode(0); int carry = 0; while (!stack1.isEmpty() &amp;&amp; !stack2.isEmpty()) &#123; int val = stack1.pop() + stack2.pop() + carry; carry = val / 10; val = val % 10; ListNode temp = new ListNode(val); temp.next = point.next; point.next = temp; &#125; while (!stack1.isEmpty()) &#123; int val = stack1.pop() + carry; carry = val / 10; val = val % 10; ListNode temp = new ListNode(val); temp.next = point.next; point.next = temp; &#125; while (!stack2.isEmpty()) &#123; int val = stack2.pop() + carry; carry = val / 10; val = val % 10; ListNode temp = new ListNode(val); temp.next = point.next; point.next = temp; &#125; if (carry == 1) &#123; ListNode temp = new ListNode(1); temp.next = point.next; point.next = temp; &#125; return point.next; &#125; public Stack&lt;Integer&gt; reverseNode(ListNode temp)&#123; Stack&lt;Integer&gt; record = new Stack&lt;Integer&gt;(); while(temp != null)&#123; record.push(temp.val); temp = temp.next; &#125; return record; &#125; &#125; 原题地址LintCode：链表求和 Ⅱ]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>高精度</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两两交换链表中的节点]]></title>
    <url>%2Fswap-nodes-in-pairs%2F</url>
    <content type="text"><![CDATA[题意给一个链表，两两交换其中的节点，然后返回交换后的链表。 样例给出 1-&gt;2-&gt;3-&gt;4, 你应该返回的链表是 2-&gt;1-&gt;4-&gt;3。 思路本题只要循环判断后两个节点不为空的情况下，将后面这两个元素进行交换即可，最重要的是，交换的时候，要记得保留原数据，以便拼接起来链表，谨防数据丢失。 代码实现1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; /** * @param head a ListNode * @return a ListNode */ public ListNode swapPairs(ListNode head) &#123; ListNode dummy = new ListNode(0); dummy.next = head; head = dummy; while (head.next != null &amp;&amp; head.next.next != null) &#123; ListNode n1 = head.next; ListNode n2 = head.next.next; head.next = n2; n1.next = n2.next; n2.next = n1; head = n1; &#125; return dummy.next; &#125;&#125; 原题地址LintCode：两两交换链表中的节点]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除链表中倒数第n个节点]]></title>
    <url>%2Fremove-nth-node-from-end-of-list%2F</url>
    <content type="text"><![CDATA[题意给定一个链表，删除链表中倒数第n个节点，返回链表的头节点。 样例给出链表 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null 和 n = 2. 删除倒数第二个节点之后，这个链表将变成 1-&gt;2-&gt;3-&gt;5-&gt;null. 思路类似于 链表倒数第n个节点，先找到被删除节点的前节点，然后将前节点的 next 指向被删除节点的的 next 即可。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */ public class Solution &#123; /** * @param head: The first node of linked list. * @param n: An integer. * @return: The head of linked list. */ ListNode removeNthFromEnd(ListNode head, int n) &#123; if (n &lt;= 0) &#123; return null; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode preDelete = dummy; for (int i = 0; i &lt; n; i++) &#123; if (head == null) &#123; return null; &#125; head = head.next; &#125; while (head != null) &#123; head = head.next; preDelete = preDelete.next; &#125; preDelete.next = preDelete.next.next; return dummy.next; &#125;&#125; 原题地址LintCode：删除链表中倒数第n个节点]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除排序链表中的重复元素]]></title>
    <url>%2Fremove-duplicates-from-sorted-list%2F</url>
    <content type="text"><![CDATA[题意给定一个排序链表，删除所有重复的元素每个元素只留下一个。 样例给出 1-&gt;1-&gt;2-&gt;null，返回 1-&gt;2-&gt;null 给出 1-&gt;1-&gt;2-&gt;3-&gt;3-&gt;null，返回 1-&gt;2-&gt;3-&gt;null 思路设置一个指针指向排序链表的头结点，遍历链表，若当前元素与下一个元素相同，直接将下一个元素的 next 指向下下个即可。 代码实现123456789101112131415161718192021222324252627282930313233/** * Definition for ListNode * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; /** * @param ListNode head is the head of the linked list * @return: ListNode head of linked list */ public static ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode node = head; while (node.next != null) &#123; if (node.val == node.next.val) &#123; node.next = node.next.next; &#125; else &#123; node = node.next; &#125; &#125; return head; &#125; &#125; 原题地址LintCode：删除排序链表中的重复元素]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表倒数第n个节点]]></title>
    <url>%2Fnth-to-last-node-in-list%2F</url>
    <content type="text"><![CDATA[题意找到单链表倒数第 n 个节点，保证链表中节点的最少数量为 n 。 样例给出链表 3-&gt;2-&gt;1-&gt;5-&gt;null 和 n = 2，返回倒数第二个节点的值 1 思路1一个简单的思路就是先将链表进行反转，然后在反转后的链表中，顺着找第 n 个元素即可。 代码实现112345678910111213141516171819202122232425262728293031323334/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */ public class Solution &#123; /** * @param head: The first node of linked list. * @param n: An integer. * @return: Nth to last node of a singly linked list. */ ListNode nthToLast(ListNode head, int n) &#123; ListNode node = null; while (head != null) &#123; ListNode temp = head.next; head.next = node; node = head; head = temp; &#125; for (int i = 1; i &lt; n; i++) &#123; node = node.next; &#125; return node; &#125;&#125; 思路2考虑一下思路1会出现的问题：当链表很长时，效率会大大降低。例如对于 100 个元素的链表，查找倒数第 100 个，那么就等于将链表遍历了 2 次，效率很低。 改进思路： 设 2 个指针 p1, p2 先让指针 p2 指向顺数第 n 个元素，p1 指向原链表的头指针。 然后 p1 和 p2 一起向后移动，直到 p2 指向 NULL，此时 p1 就会指向倒数第 n 个元素上。 代码实现212345678910111213141516171819202122232425262728293031323334353637/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */ public class Solution &#123; /** * @param head: The first node of linked list. * @param n: An integer. * @return: Nth to last node of a singly linked list. */ ListNode nthToLast(ListNode head, int n) &#123; if (head == null || n &lt; 1) &#123; return null; &#125; ListNode p1 = head; ListNode p2 = head; for (int j = 0; j &lt; n - 1; ++j) &#123; if (p2 == null) &#123; return null; &#125; p2 = p2.next; &#125; while (p2.next != null) &#123; p1 = p1.next; p2 = p2.next; &#125; return p1; &#125;&#125; 原题地址LintCode：链表倒数第n个节点]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表插入排序]]></title>
    <url>%2Finsertion-sort-list%2F</url>
    <content type="text"><![CDATA[题意用插入排序对链表排序 样例给予 1-&gt;3-&gt;2-&gt;0-&gt;null, 返回 0-&gt;1-&gt;2-&gt;3-&gt;null 思路将接受到的链表当做未排序链表，再创建一个链表存放已排序链表，并创建一个已排序链表的指针。 依次将未排序链表的元素与已排序链表中的每一个元素进行比较(也就是先用未排序链表的第一个与已排序链表的每一个进行比较，然后用未排序链表的第二个，第三个….依次进行比较，直到最后一个元素) 由于题意是升序排序，所以只要未排序链表中的元素大于已排序链表中的元素，那么就将未排序链表的这个元素放到第一个比它大的已排序链表的后面。 要注意的是，将未排序链表的元素放到已排序链表时，不要覆盖掉原数据(先挪动其他数据再进行插入操作)。 代码实现12345678910111213141516171819202122232425262728293031/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */public class Solution &#123; /** * @param head: The first node of linked list. * @return: The head of linked list. */ public ListNode insertionSortList(ListNode head) &#123; ListNode dummy = new ListNode(0); while (head != null) &#123; ListNode node = dummy; while (node.next != null &amp;&amp; node.next.val &lt; head.val) &#123; node = node.next; &#125; ListNode temp = head.next; head.next = node.next; node.next = head; head = temp; &#125; return dummy.next; &#125;&#125; 原题地址LintCode：链表插入排序]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在O(1)时间复杂度删除链表节点]]></title>
    <url>%2Fdelete-node-in-the-middle-of-singly-linked-list%2F</url>
    <content type="text"><![CDATA[题意给定一个单链表中的一个等待被删除的节点(非表头或表尾)。请在在 O(1) 时间复杂度删除该链表节点。 样例Linked list is 1-&gt;2-&gt;3-&gt;4, and given node 3, delete the node in place 1-&gt;2-&gt;4 思路删除一个节点，只需要将该节点的下一个节点的值赋值给该该节点，并且让该节点的下一个指向它下一个的下一个即可。 代码实现123456789101112131415161718192021222324/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */ public class Solution &#123; /** * @param node: the node in the list should be deleted * @return: nothing */ public void deleteNode(ListNode node) &#123;// write your code here if (node == null || node.next == null) return; ListNode next = node.next; node.val = next.val; node.next = next.next; &#125;&#125; 原题地址LintCode：在O(1)时间复杂度删除链表节点]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表求和]]></title>
    <url>%2Fadd-two-numbers%2F</url>
    <content type="text"><![CDATA[题意你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。 样例给出两个链表 3-&gt;1-&gt;4-&gt;null 和 5-&gt;9-&gt;2-&gt;null，返回 8-&gt;0-&gt;7-&gt;null。 其实就是 413 + 295 = 708 数字全部以相反的顺序存储。 思路首先依次取链表的元素，第一次取的就是最低位，个位，第二次就是十位，以此类推。正好此顺序是正常加法运算的顺序，所以将每一位计算完后的数对10取余，就是 保留数 ，对10整除就是 进位数 。如：5 + 9 = 14 那么， 14 % 10 = 4 14 / 10 = 1。所以每次将 保留数 存储下来，然后下一位的运算加上 进位数 即可，依次类推。最终计算出结果。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; /** * @param l1: the first list * @param l2: the second list * @return: the sum list of l1 and l2 */ public ListNode addLists(ListNode l1, ListNode l2) &#123; if(l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; ListNode head = new ListNode(0); ListNode point = head; int carry = 0; while(l1 != null &amp;&amp; l2!=null)&#123; int sum = carry + l1.val + l2.val; point.next = new ListNode(sum % 10); carry = sum / 10; l1 = l1.next; l2 = l2.next; point = point.next; &#125; while(l1 != null) &#123; int sum = carry + l1.val; point.next = new ListNode(sum % 10); carry = sum /10; l1 = l1.next; point = point.next; &#125; while(l2 != null) &#123; int sum = carry + l2.val; point.next = new ListNode(sum % 10); carry = sum /10; l2 = l2.next; point = point.next; &#125; if (carry != 0) &#123; point.next = new ListNode(carry); &#125; return head.next; &#125;&#125; 图解 原题地址LintCode：链表求和]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除链表中的元素]]></title>
    <url>%2Fremove-linked-list-elements%2F</url>
    <content type="text"><![CDATA[题意删除链表中等于给定值 val 的所有节点。 样例给出链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;5-&gt;3, 和 val = 3, 你需要返回删除3之后的链表：1-&gt;2-&gt;4-&gt;5。 思路只需要将一个指针，遍历链表，当链表中有元素与 val 值相同时，让当前节点的 next 节点直接指向 当前节点的 next.next 节点即可。 代码实现1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; /** * @param head a ListNode * @param val an integer * @return a ListNode */ public ListNode removeElements(ListNode head, int val) &#123; ListNode dummy = new ListNode(0); dummy.next = head; head = dummy; while (head.next != null) &#123; if (head.next.val == val) &#123; head.next = head.next.next; &#125; else &#123; head = head.next; &#125; &#125; return dummy.next; &#125;&#125; 原题地址LintCode：删除链表中的元素]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合并两个排序链表]]></title>
    <url>%2Fmerge-two-sorted-lists%2F</url>
    <content type="text"><![CDATA[题意将两个排序链表合并为一个新的排序链表 样例给出 1-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null，2-&gt;null， 返回 1-&gt;2-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null。 思路这道题很简单，属于链表的基本操作。只需要创建一个新的链表与一个指向新链表最后一个节点的指针即可。当 l1 与 l2 均不为空的情况下，判断 l1 和 l2的大小，把较小值放进新链表的最后一个节点，然后将较小值所处的链表向后移一位，以判断下一个数。依次循环，直到 l1 或 l2 中有一方为空时，将为空的一方，直接加到新链表后即可。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */ public class Solution &#123; /** * @param ListNode l1 is the head of the linked list * @param ListNode l2 is the head of the linked list * @return: ListNode head of linked list */ public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode listNode = new ListNode(0); ListNode lastNode = listNode; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &gt; l2.val) &#123; lastNode.next = l2; l2 = l2.next; &#125; else &#123; lastNode.next = l1; l1 = l1.next; &#125; lastNode = lastNode.next; &#125; if (l1 == null) lastNode.next = l2; if (l2 == null) &#123; lastNode.next = l1; &#125; return listNode.next; &#125;&#125; 原题地址LintCode：合并两个排序链表]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo优化 --- 利用 Markdown 语法画流程图]]></title>
    <url>%2Fhexo-flowchart%2F</url>
    <content type="text"><![CDATA[添加支持Hexo 默认是不支持流程图的 Markdown 语法的，需要添加支持：1npm install --save hexo-filter-flowchart 演示一个最简单的流程图12345678910···flow #由于渲染问题，请自行将 · 替换为 `st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op··· 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 一个复杂的流程图12345678910111213···flow #由于渲染问题，请自行将 · 替换为 `st=&gt;start: Start:&gt;http://www.google.com[blank]e=&gt;end:&gt;http://www.google.comop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yesor No?:&gt;http://www.google.comio=&gt;inputoutput: catch something...st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1··· 1234567891011st=&gt;start: Start:&gt;http://www.google.com[blank]e=&gt;end:&gt;http://www.google.comop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yesor No?:&gt;http://www.google.comio=&gt;inputoutput: catch something...st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1 语法详解Hexo 中的流程图是依赖于 flowchart.js 实现的。 以上面那个复杂的流程图为例:1234567891011121314···flow #由于渲染问题，请自行将 · 替换为 `//定义部分st=&gt;start: Start:&gt;http://www.google.com[blank]e=&gt;end:&gt;http://www.google.comop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yes or No?:&gt;http://www.google.comio=&gt;inputoutput: catch something...//判断和位置控制st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1··· 例如这一句：1st=&gt;start: Start|past:&gt;http://www.google.com[blank] 其中，st 是变量名， start 是指操作模块名，冒号后面就是内容了。需要注意的是，冒号后要加空格才能识别 操作模块语法 操作模块 说明 start 开始 end 结束 opration 普通操作块 condition 判断块 subroutine 子任务块 inputoutput 输入输出块 判断和位置控制1234567891011121314151617####流程控制st-&gt;op1-&gt;e# -&gt; 作为控制流程的操作符，就是指向下一步要操作的。# 每一条都算是一条流程# 你也可以断开写，怎么方便怎么来，如：下面两个是一样的。#分着写st-&gt;op1op1-&gt;e#合着写st-&gt;op1-&gt;e####判断cond(yes)-&gt;io-&gt;e #yes的时候到io，再到e 123#位置指定cond(no)-&gt;sub1(right)-&gt;op1 #no的时候到到 sub1，再从sub1的右侧到op1 #还可以这样 cond1(no,right)]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>markdown</tag>
        <tag>流程图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻转链表 II]]></title>
    <url>%2Freverse-linked-list-ii%2F</url>
    <content type="text"><![CDATA[题意翻转链表中第m个节点到第n个节点的部分 注意事项：m，n满足 1 ≤ m ≤ n ≤ 链表长度 样例给出链表 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null， m = 2 和 n = 4，返回 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;null 思路本题类似于 翻转链表，只不过是限定了翻转的个数而已。可以先记录下 m 节点的前一个节点，与 n 节点的后一个节点，然后将 m - n 进行翻转(参考：翻转链表 )，最后利用 m 的前节点和 n 的后节点，将链表再次链接起来即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for ListNode * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; /** * @param ListNode head is the head of the linked list * @oaram m and n * @return: The head of the reversed ListNode */ public ListNode reverseBetween(ListNode head, int m , int n) &#123; //非空判断 if (m &gt;= n || head == null) &#123; return head; &#125; ListNode dummy = new ListNode(0); // 插入头节点 dummy.next = head; head = dummy; for (int i = 1; i &lt; m; i++) &#123; // 找到m节点前面一个节点 if (head == null) &#123; return null; &#125; head = head.next; &#125; ListNode premNode = head; // m 之前的那个节点 ListNode mNode = premNode.next; // m 节点 ListNode nNode = mNode;// n节点 ListNode postnNode = mNode.next; // n 之后那个节点 // n 后节点 插入到n 节点之前 for (int i = m; i &lt; n; i++) &#123; if (postnNode == null) &#123; return null; &#125; ListNode temp = postnNode.next; // 下一个节点 postnNode.next = nNode; nNode = postnNode; postnNode = temp; &#125; mNode.next = postnNode;// m next 指向 n 后 premNode.next = nNode; // m 前节点 指向 n return dummy.next; &#125;&#125; 原题地址LintCode：翻转链表 II]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索二维矩阵Ⅰ]]></title>
    <url>%2Fsearch-a-2d-matrix%2F</url>
    <content type="text"><![CDATA[题意写出一个高效的算法来搜索 m * n 矩阵中的值。 这个矩阵具有以下特性： 每行中的整数从左到右是排序的。 每行的第一个数大于上一行的最后一个整数。 样例考虑下列矩阵： [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] 给出 target = 3，返回 true 思路可以先对每一行的第一列进行纵向二分查找，确定目标数大概在哪一行，然后再对那一行进行二分查找。 代码123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; /** * @param matrix, a list of lists of integers * @param target, an integer * @return a boolean, indicate whether matrix contains target */ public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0) return false; int high = matrix.length - 1; int low = 0; int mid = 0; while (low &lt;= high) &#123; mid = (low + high) / 2; if (matrix[mid][0] == target) return true; else if (matrix[mid][0] &gt; target) high = mid - 1; else low = mid + 1; &#125; int row = mid; if (matrix[mid][0] &gt; target) &#123; if (mid &gt; 0) row = mid - 1; else return false; &#125; low = 1; high = matrix[0].length - 1; while (low &lt;= high) &#123; mid = (low + high) / 2; if (matrix[row][mid] == target) return true; else if (matrix[row][mid] &gt; target) high = mid - 1; else low = mid + 1; &#125; return false; &#125;&#125; 原题地址LintCode：搜索二维矩阵Ⅰ]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇偶分割数组]]></title>
    <url>%2Fpartition-array-by-odd-and-even%2F</url>
    <content type="text"><![CDATA[题意分割一个整数数组，使得奇数在前偶数在后。 样例给定 [1, 2, 3, 4]，返回 [1, 3, 2, 4]。 思路两个指针分别从数组两端开始查找，左侧指针依次向右找直到遇到一个偶数为止，右侧指针依次向左找直到遇到一个奇数为止。然后将这两个数置换，然后左右两个指针继续向中间查找，直到两个指针碰头为止。 代码12345678910111213141516171819202122232425public class Solution &#123; /** * @param nums: an array of integers * @return: nothing */ public void partitionArray(int[] nums) &#123; int start = 0; int end = nums.length - 1; while (start &lt; end) &#123; while (start &lt; end &amp;&amp; nums[start] % 2 == 1) &#123; start++; &#125; while (start &lt; end &amp;&amp; nums[end] % 2 == 0) &#123; end--; &#125; if (start &lt; end) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125; &#125; &#125;&#125; 原题地址LintCode：奇偶分割数组]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>两根指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索二维矩阵Ⅱ]]></title>
    <url>%2Fsearch-a-2d-matrix-ii%2F</url>
    <content type="text"><![CDATA[题意写出一个高效的算法来搜索 m * n 矩阵中的值，返回这个值出现的次数。 这个矩阵具有以下特性： 每行中的整数从左到右是排序的。 每一列的整数从上到下是排序的。 在每一行或每一列中没有重复的整数。 样例考虑下列矩阵： [ [1, 3, 5, 7], [2, 4, 7, 8], [3, 5, 9, 10] ] 给出 target = 3，返回 2 思路首先根据该矩阵的特性可得以下的规律： 左下角的右侧均比其右侧的数字大 左下角的下侧均比其左侧的数字大 所以根据此规律可得搜索思路： 从左下角开始搜索 如果此数比目标数大，则向上移动一位 如果此数比目标数小，则向右移动一位 如果此数等于目标数，则向上移动一位，再向右移动一位。 直至到最右侧或者最上侧为止。 从右上角搜索思路类似，只是方向不同。 代码12345678910111213141516171819202122232425262728293031public class Solution &#123; /** * @param matrix: A list of lists of integers * @param: A number you want to search in the matrix * @return: An integer indicate the occurrence of target in the given matrix */ public int searchMatrix(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0) &#123; return 0; &#125; int count = 0; int n = matrix.length; int m = matrix[0].length; int x = n - 1; while (x &gt;= 0 &amp;&amp; y &lt; m) &#123; if (matrix[x][y] &gt; target) &#123; x--; &#125; else if (matrix[x][y] &lt; target) &#123; y++; &#125; else &#123; x--; y++; count++; &#125; &#125; return count; &#125;&#125; 原题地址LintCode：搜索二维矩阵Ⅱ]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻转字符串]]></title>
    <url>%2Freverse-words-in-a-string%2F</url>
    <content type="text"><![CDATA[题意给定一个字符串，逐个翻转字符串中的每个单词。 单词的构成：无空格字母构成一个单词 输入字符串是否包括前导或者尾随空格？可以包括，但是反转后的字符不能包括 如何处理两个单词间的多个空格？在反转字符串中间空格减少到只含一个 样例传入一个字符串 &quot; Hello World! &quot;,返回 &quot;World! Hello&quot; 思路 首先 目标字符串 为 null 或者长度为 0，则直接返回空字符串； 先去除两端的空格之后，再找到 目标字符串 的第一个空格的位置 然后用 subString() 将第一个空格之前的子字符串压入栈中 将目标字符串剩下的另一半子字符串继续进行第二步操作，直至 目标字符串 的长度变为0 将栈中的所有元素以此出栈，除最后一个元素外，其他元素尾部都加上一个空格: &quot; &quot; 注意当目标字符串没有空格时，取第一个空格的位置会返回 -1 ，此时用这个位置去取字符串会出现下标越界！ 代码123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; /** * @param s : A string * @return : A string */ public String reverseWords(String s) &#123; if (s == null || s.length() == 0) &#123; return ""; &#125; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); while (s.length() != 0) &#123; s = s.trim(); int i = s.indexOf(" "); if ( i== -1) &#123; stack.push(s); break; &#125; stack.push( s.substring(0, i) ); s = s.substring(i, s.length()); &#125; String str = ""; while (!stack.isEmpty()) &#123; if(stack.size()==1) str = str + stack.pop(); else str = str + stack.pop() + " "; &#125; return str; &#125;&#125; 原题地址LintCode：翻转字符串]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用栈实现队列]]></title>
    <url>%2Fimplement-queue-by-two-stacks%2F</url>
    <content type="text"><![CDATA[描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路 代码实现12345678910111213141516171819202122232425262728293031323334public class MyQueue &#123; private Stack&lt;Integer&gt; stack1; private Stack&lt;Integer&gt; stack2; public MyQueue() &#123; stack1 = new Stack&lt;Integer&gt;(); stack2 = new Stack&lt;Integer&gt;(); &#125; public void stack2ToStack1() &#123; while (! stack2.empty()) &#123; stack1.push(stack2.pop()); &#125; &#125; public void push(int element) &#123; stack2.push(element); &#125; public int pop() &#123; if (stack1.empty() == true) &#123; this.stack2ToStack1(); &#125; return stack1.pop(); &#125; public int top() &#123; if (stack1.empty() == true) &#123; this.stack2ToStack1(); &#125; return stack1.peek(); &#125;&#125; 原题地址牛客网：用两个栈实现队列]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬楼梯]]></title>
    <url>%2Fclimbing-stairs%2F</url>
    <content type="text"><![CDATA[题意假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？ 样例 n=1 方法只有一种就是1 n=2 1+1 或者 2 两种方法 n=3 1+1+1 或者 1+2 或者 2+1 三种方法 ….. 思路逆向思维，例如 n = 4 ，那么他走的最后一步就只能是 1步 或者 2步，如果最后走的是1级台阶，那么之前走的就是3级台阶， 如果之前走的是2级台阶，那么之前走的就是2级台阶，于是得到4阶台阶的走法就是3阶台阶的走法加上2阶台阶的走法。也就是3 + 2 = 5种。如果还不明白的话 我这样看： n=1: n=2: 1+1 2 n=3: 1+1+1 1+2 2+1 n=4: 1+1+1+1 1+2+1 2+1+1 1+1+2 2+2 在原来的 n=3 的基础上，所有方法都加1步，变成了 1+1+1+1 1+2+1 2+1+1 。然后再在 n=2 的基础上，所有方法都加2步，变成了 1+1+2 2+2然后在看看 n=2 和 n=3 的时候，分别加上2步和1步 就变成了 n=4 的所有方法 代码实现：递归1234567891011121314public class Solution &#123; /** * @param n: An integer * @return: An integer */ public int climbStairs(int n) &#123; if (n == 1 || n == 2) return n; int now = climbStairs(n-2) + climbStairs(n-1); return now; &#125;&#125; 递归方式虽然能实现这种，但是当n越大，程序运行时间就越长，最后还会导致栈溢出的情况，所以对算法进行了改进。 代码实现： 循环12345678910111213141516171819public class Solution &#123; /** * @param n: An integer * @return: An integer */ public int climbStairs(int n) &#123; if (n == 0) &#123; //这里判断n == 0 是因为题目测试程序给的测试数据中有n = 0 时期望答案为1的设定。 return 1; &#125; if (n == 1 || n == 2) return n; int[] array = new int[n + 1]; array[1] = 1; array[2] = 2; for (int i = 3; i &lt;= n; i++) array[i] = array[i - 1] + array[i - 2]; return array[n]; &#125;&#125; 这样就不会出现栈溢出的情况了，但是可以看到使用数组还是占用了一定的空间，不够简洁，于是再次改进。 代码实现： 循环优化版12345678910111213141516171819202122public class Solution &#123; /** * @param n: An integer * @return: An integer */ public int climbStairs(int n) &#123; if (n == 0) &#123;//这里判断n == 0 是因为题目测试程序给的测试数据中有n = 0 时期望答案为1的设定。 return 1; &#125; if (n == 1 || n == 2) return n; int f1 = 1; int f2 = 2; int fn = 0; for (int i = 3; i &lt;= n; i++) &#123; fn = f1 + f2; f1 = f2; f2 = fn; &#125; return fn; &#125;&#125; 此方法就是每次将 f1 和 f2 向后移动一次，以记录数据。避免浪费资源. 如下： 123456781， 2， 3， 5， 8， 13 ......f1, f2, fn,1， 2， 3， 5， 8， 13 ...... f1, f2, fn1， 2， 3， 5， 8， 13 ...... f1, f2, fn 原题地址：LintCode：爬楼梯]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前序遍历和中序遍历树构造二叉树]]></title>
    <url>%2Fconstruct-binary-tree-from-preorder-and-inorder-traversal%2F</url>
    <content type="text"><![CDATA[题意根据前序遍历和中序遍历树构造二叉树. 注意事项： 你可以假设树中不存在相同数值的节点 样例给出中序遍历：[1,2,3]和前序遍历：[2,1,3]. 返回如下的树: 2 / \ 1 3 思路根据前序遍历和中序遍历的规律可得： 前序遍历的第一个就是整个树的根节点 这个根节点在中序遍历的左侧是其左子树，右侧是右子树。 将每一个节点都看作是一个单独的树，根据此 规律1 和 规律2 依次递归获取其左右子树的前序与中序遍历，直到前序遍历或中序遍历的长度仅剩1，则说明该节点为叶子节点，从而构造整棵树。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Definition of TreeNode: * public class TreeNode &#123; * public int val; * public TreeNode left, right; * public TreeNode(int val) &#123; * this.val = val; * this.left = this.right = null; * &#125; * &#125; */ public class Solution &#123; /** *@param preorder : A list of integers that preorder traversal of a tree *@param inorder : A list of integers that inorder traversal of a tree *@return : Root of a tree */ public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if (preorder.length == 0 || inorder.length == 0) &#123; return null; &#125; int root = preorder[0]; // 根据前序遍历的规律取第一个最为根节点 TreeNode treeRoot = new TreeNode(root); int flag = -1; // flag用于存放根节点root在中序遍历中的位置 for (int i = 0; i &lt; inorder.length; i++) &#123; if (inorder[i] == root) &#123; flag = i; &#125; &#125; //前序或中序遍历等于1，则说明已经是叶子节点，直接return即可，避免多余运算 if (preorder.length == 1 || inorder.length == 1) &#123; return treeRoot; &#125; int[] child_InorderLeft = new int[flag]; //左侧子节点的中序遍历 int[] child_InorderRight = new int[(inorder.length - 1) - flag]; //右侧子节点的中序遍历 int[] child_PreorderLeft = new int[flag]; //左侧子节点的前序遍历 int[] child_PreorderRight = new int[child_InorderRight.length]; //右侧子节点的前序遍历 //从现有的中序遍历中拿到 左右子节点的中序遍历 for (int i = 0; i &lt; inorder.length; i++) &#123; if (i &lt; flag) &#123; child_InorderLeft[i] = inorder[i]; &#125; else if ((i &gt; flag) )&#123; child_InorderRight[i - flag - 1] = inorder[i]; &#125; &#125; //从现有的前序遍历中拿到 左右子节点的前序遍历 for (int i = 1; i &lt; preorder.length ; i++) &#123; //这里i从1开始，是因为i的preorder[0]为根节点 if(i &lt;= flag) child_PreorderLeft[i-1] = preorder[i]; //preorderSeed[i-1] 是因为要新左子树要从0存放，不然preorderSeed[0]就是空的，而且长度会不够 else &#123; child_PreorderRight[i - flag - 1] = preorder[i]; &#125; &#125; //递归调用获取左右子树 treeRoot.left = buildTree(child_PreorderLeft,child_InorderLeft); treeRoot.right = buildTree(child_PreorderRight,child_InorderRight); return treeRoot; &#125;&#125; 原题地址LintCode：前序遍历和中序遍历树构造二叉树]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找旋转排序数组中的最小值]]></title>
    <url>%2Ffind-minimum-in-rotated-sorted-array%2F</url>
    <content type="text"><![CDATA[题意假设一个旋转排序的数组其起始位置是未知的（比如 0 1 2 4 5 6 7 可能变成是 4 5 6 7 0 1 2）。 你需要找到其中最小的元素。 你可以假设数组中不存在重复的元素。 样例给出 [4,5,6,7,0,1,2] 返回 0。 代码实现： 顺序查找1234567891011121314public class Solution &#123; /** * @param nums: a rotated sorted array * @return: the minimum number in the array */ public int findMin(int[] nums) &#123; int i = nums[0]; for(int j = 1; j &lt; nums.length; j++ ) &#123; if(nums[j] &lt; i) i = nums[j]; &#125; return i; &#125;&#125; 这种方式非常简单，就是依次顺序查找，但是题目推荐的是用二分法进行查找，故下方又用二分法实现了功能。 代码实现： 二分法12345678910111213141516171819202122public class Solution &#123; /** * @param nums: a rotated sorted array * @return: the minimum number in the array */ public int findMin(int[] nums) &#123; int l = 0; int r = nums.length-1; if (nums[l] &lt; nums[r]) return nums[l]; while (l &lt; r) &#123; int mid = (l + r) / 2; if (nums[mid] &gt; nums[r]) l = mid + 1; else r = mid; &#125; return nums[r]; &#125;&#125; 该题的主要思路就是 中位数 与 右侧数 的比较。根据该类型数据的规律可得结论： 中位数 &gt; 右侧数 则说明 最小数 在右侧，反之在左侧。 原题地址LintCode：寻找旋转排序数组中的最小值]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻转链表]]></title>
    <url>%2Freverse-linked-list%2F</url>
    <content type="text"><![CDATA[题意翻转一个链表 样例给出一个链表 1-&gt;2-&gt;3-&gt;null，这个翻转后的链表为 3-&gt;2-&gt;1-&gt;null 代码实现12345678910111213141516171819202122232425262728/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */ public class Solution &#123; /** * @param head: The head of linked list. * @return: The new head of reversed linked list. */ public ListNode reverse(ListNode head) &#123; ListNode prev = null; while (head != null) &#123; ListNode temp = head.next; head.next = prev; prev = head; head = temp; &#125; return prev; &#125;&#125; 图解 原题地址LintCode：翻转链表]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空格替换]]></title>
    <url>%2Fspace-replacement%2F</url>
    <content type="text"><![CDATA[描述设计一种方法，将一个字符串中的所有空格替换成 %20 。你可以假设该字符串有足够的空间来加入新的字符，且你得到的是“真实的”字符长度。 你的程序还需要返回被替换后的字符串的长度。 注意事项：如果使用 Java 或 Python, 程序中请用字符数组表示字符串。 样例对于字符串 &quot;Hello World&quot; , 长度为 11替换空格之后，参数中的字符串需要变为 &quot;Hello%20World&quot;，并且把新长度 17 作为结果返回。 思路 循环遍历字符数组 碰到空字符则将空字符后所有的字符向后移动两位（假设字符数组有足够长度），防止添加 %20 时，造成覆盖而导致数据丢失. 将空字符以及后两位共 3 个位置 替换成 %20 将字符数组的长度 +2 代码123456789101112131415public int replaceBlank(char[] string, int length) &#123; for (int i = 0; i &lt; length; i++) &#123; if (string[i] == &apos; &apos;) &#123; for (int j = length + 2; j != i + 2; j--) &#123; string[j] = string[j - 2]; &#125; string[i + 2] = &apos;0&apos;; string[i + 1] = &apos;2&apos;; string[i] = &apos;%&apos;; length += 2; &#125; &#125; return length; &#125; 图解 要点 本题要求是将参数中的字符数组改变，而不能通过创建一个新字符数组进行操作，然后将新字符数组赋值给原字符数组。 碰到空格要将字符数组的所有字符整体向后移动两位。 LintCode：空格替换]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：网络编程]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络通讯要素IP地址(InetAddress) 网络中设备的标识 不易记忆，可用主机名代替 本地地址：127.0.0.1 主机名：localhost 端口号 用于标识进程的逻辑地址，不同进程的标识 有效端口为 2 个字节(0-65535)，其中 0-1024 一般为系统使用或保留端口 传输协议 UDP(User Datagram Protocol)：用户数据报协议 将数据及源和目的封装成数据包中，不需要建立连接。 每个数据报的大小限制在 64K 。 因无连接，是不可靠协议。 不需要建立连接，速度快。 TCP(Transmission Control Protocol)：传输控制协议 建立连接，然后形成传输数据的通道。 在连接中可以进行大数据量传输。 通过三次握手完成连接，是可靠协议。 必须建立连接，效率会稍低。 Socket Socket就是为网络服务提供的一种机制 通信等两端都有 Socket 网络通信其实就是 Socket 间的通信 数据在两 个Socket 间通过 IO 传输。 IP概述 IP 地址是 IP 使用的 32 位或 128 位无符号数字，它是一种低级协议，UDP 和 TCP 协议都是在它的基础上构建的。 InetAddress 类是表示互联网协议(IP)地址。 InetAddress 类没有提供构造方法，所以不能 new 创建对象，要通过静态方法来初始化。12345static InetAddress[] getAllByName(String host): 根据系统上配置的名称服务返回其 IP 地址所组成的数组。static InetAddress getByAddress(byte[] addr): 在给定原始 IP 地址的情况下，返回 InetAddress 对象。static InetAddress getByAddress(String host, byte[] addr): 根据提供的主机名和 IP 地址创建 InetAddress。static InetAddress getByName(String host): 在给定主机名的情况下确定主机的 IP 地址。static InetAddress getLocalHost(): 返回本地主机。 常用方法演示123456789101112131415import java.net.InetAddress;import java.net.UnknownHostException;public class InetAddressDemo &#123; public static void main(String[] args) throws UnknownHostException &#123; //获取本地主机 InetAddress ip = InetAddress.getLocalHost(); System.out.println("本地主机ip：" + ip.getHostAddress() + ",名称：" + ip.getHostName()); InetAddress ip2 = InetAddress.getByName("www.baidu.com"); System.out.println("百度主机ip：" + ip2.getHostAddress() + ",名称：" + ip2.getHostName()); &#125;&#125; UDP概述UDP 协议中有 DatagramSocket 和 DatagramPacket 对象，两者分别为，UDP 服务与 数据包。 UDP 发送端1234567891011121314151617181920import java.net.InetAddress;import java.net.DatagramSocket;import java.net.DatagramPacket;public class UDPSendDemo &#123; public static void main(String[] args) throws Exception &#123; //建立一个 UDP 服务 DatagramSocket ds = new DatagramSocket(); byte[] buf = "Hello!".getBytes(); //创建一个数据包，这里的参数分别代表字节数据，字节数据的长度，目标IP，目标端口 DatagramPacket dp = new DatagramPacket(buf, buf.length, InetAddress.getByName("127.0.0.1"), 10001); //发送数据 ds.send(dp); //关闭资源 ds.close(); &#125;&#125; 因为这里是数据发送端，所以创建的数据包中要指定目标IP与端口。 UDP 接收端12345678910111213141516171819202122232425import java.net.InetAddress;import java.net.DatagramSocket;import java.net.DatagramPacket;public class UDPReceiveDemo &#123; public static void main (String[] args) throws Exception &#123; //建立一个UDP服务，并监听发送端发送数据的端口。 DatagramSocket ds = new DatagramSocket(10001); //创建接收数据的数据包 byte[] buf = new byte[1024]; DatagramPacket dp = new DatagramPacket(buf, buf.length); //将接收到的数据放到指定数据包中。 ds.receive(dp); //解析并打印接收到的数据 String message = new String(dp.getData(), 0, dp.getLength()); String ip = dp.getAddress().getHostAddress(); int port = dp.getPort(); System.out.println(ip + "::" + port + "---" + message); ds.close(); &#125;&#125; 接收端需要注意的是：服务端要监听发送端发送的数据包中的那个端口，才能收到数据。DatagramSocket 的 receive 方法是阻塞式方法，当未接收到数据包时，会一直在等待接收状态。 模拟自动聊天功能需求：模拟出一个与机器人自动聊天的功能，给机器人发送字符数据，机器人将字符数据的大写反馈给用户，要求用户使用键盘录入数据，并可循环发送数据，直到用户发送 over。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;class Send implements Runnable &#123; @Override public void run() &#123; DatagramSocket ds = null; System.out.println("客户端已开启"); try &#123; ds = new DatagramSocket(); //输入流是键盘录入 BufferedReader bur = new BufferedReader(new InputStreamReader(System.in)); String line = null; while ((line = bur.readLine()) != null) &#123; if ("over".equals(line)) &#123; System.out.println("本客户端已退出"); break; &#125; DatagramPacket dp = new DatagramPacket(line.getBytes(), line.length(), InetAddress.getByName("127.0.0.1"), 10005); ds.send(dp); &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ds != null) ds.close(); &#125; &#125;&#125;class Receive implements Runnable &#123; @Override public void run() &#123; System.out.println("服务端已开启"); DatagramSocket ds = null; try &#123; ds = new DatagramSocket(10005); while (true) &#123; byte[] buf = new byte[1024]; DatagramPacket dp = new DatagramPacket(buf, buf.length); ds.receive(dp); String message = new String(dp.getData(), 0, dp.getLength()); String ip = dp.getAddress().getHostAddress(); int port = dp.getPort(); System.out.println(ip + "::" + port + "---" + message.toUpperCase()); &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ds != null) ds.close(); &#125; &#125;&#125;public class ThreadUDP &#123; public static void main(String[] args) &#123; Thread send = new Thread(new Send()); Thread receive = new Thread(new Receive()); receive.start(); send.start(); &#125;&#125; TCP概述在 TCP 协议中的客户端为：Socket，服务端为：ServerSocket，传输时使用的是字节数据。 TCP 客户端1234567891011121314151617import java.net.Socket;import java.io.OutputStream;public class TCPClient &#123; public static void main(String[] args) throws Exception &#123; //创建客户端的 Socket 服务，指定目的和端口 Socket s = new Socket("127.0.0.1", 10030); //为了发送数据，获取 Socket 流中的输出流 OutputStream out = s.getOutputStream(); byte[] buf = "Hello,TCP".getBytes(); out.write(buf); s.close(); &#125;&#125; 因为 TCP 是面向连接的，所以不能单独运行客户端，需要先启动服务端在启动客户端，然后发送数据过去。 TCP 服务端1234567891011121314151617181920212223import java.net.Socket;import java.net.ServerSocket;import java.io.InputStream;public class TCPServer &#123; public static void main(String[] args) throws Exception &#123; //创建服务端的 Socket 服务，并监听一个用来接收数据的端口。 ServerSocket ss = new ServerSocket(10030); Socket s = ss.accept(); InputStream is = s.getInputStream(); byte[] buf = new byte[1024]; int len = 0; String message = ""; while ((len = is.read(buf)) != -1) &#123; message += new String(buf, 0, len); &#125; System.out.println("message:" + message); ss.close(); &#125;&#125; appept 方法也是一个阻塞式方法，在连接传入前会一直阻塞。使用 appept 方法的返回值可以得到发送端的 Socket 对象，用这个对象获取输入流，再用其读取数据。 模拟自动聊天功能这里的功能与 UDP 的方式不同，因为是面向连接的，所以会更加复杂一些。 Socket 对象只能获取字节流，而不能获取字符流，所以我们需要使用转换流将字节流转化为字符流在进行操作。 客户端：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;import java.net.UnknownHostException;public class TCPSocketClient &#123; public static void main(String[] args) throws UnknownHostException, IOException &#123; System.out.println("客户端已开启"); //定义目标客户端的 IP 和端口 Socket s = new Socket("127.0.0.1", 10080); //用来从键盘读取用户要发送的数据 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); //用来将用户数据写入出去 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); //用来读取服务端的反馈信息 BufferedReader read = new BufferedReader(new InputStreamReader(s.getInputStream())); //从键盘读取数据，直到用户输入 over String line = null; while ((line = br.readLine()) != null) &#123; if ("over".equals(line)) &#123; break; &#125; //将数据通过 Socket 流写出到服务端，由于是字符流， //要给出结束标志"回车符",并刷新缓存，不然数据只会存储在内存中。 bw.write(line); bw.newLine(); bw.flush(); //readLine 是阻塞式方法，等待服务端的反馈信息。 String message = read.readLine(); System.out.println("从服务器接收到的反馈数据：" + message); &#125; br.close(); //客户端关闭之前，会给服务端发送一个结束标志，这样不会导致链接直接中断 s.close(); &#125;&#125; 服务端：12345678910111213141516171819202122232425262728293031323334import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;public class TCPSocketServer2 &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务端已开启"); ServerSocket ss = new ServerSocket(10080); Socket s = ss.accept(); String ip = s.getInetAddress().getHostAddress(); System.out.println(ip + "已连接"); //用来接收客户端发送的数据 BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream())); //用来反馈给客户端 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); String line = null; while ((line = br.readLine()) != null) &#123; //这里反馈数据也要加回车标记，并刷新。 bw.write(line.toUpperCase()); bw.newLine(); bw.flush(); &#125; ss.close(); &#125;&#125; 这里要注意的是，使用转换流后，两端互发数据，务必要加回车符，并刷新缓存。 模拟上传文件需求：模拟客户端向服务端上传一个文件，要求使用 TCP 协议，上传完成后，服务端给予反馈信息。客户端：12345678910111213141516171819202122232425262728import java.net.*;import java.io.*;public class UploadClient &#123; public static void main(String[] args) throws Exception&#123; Socket s = new Socket("127.0.0.1", 10030); FileInputStream fis = new FileInputStream("E:\\demo.jpg"); OutputStream os = s.getOutputStream(); byte[] buf = new byte[1024]; int len = 0; while ((len = fis.read(buf)) != -1) &#123; os.write(buf, 0, len); &#125; s.shutdownOutput(); InputStream is = s.getInputStream(); byte[] bufIn = new byte[1024]; int lenIn = is.read(bufIn); System.out.println(new String(bufIn, 0, lenIn)); fis.close(); s.close(); &#125;&#125; 注意：客户端发送完文件后，要执行 s.shutdownOutput() 方法给予服务端发送结束标志，不然服务端会一直等待接收数据。 服务端：1234567891011121314151617181920212223242526272829import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class UploadServer &#123; public static void main(String[] args) throws Exception &#123; ServerSocket ss = new ServerSocket(10030); Socket s = ss.accept(); InputStream is = s.getInputStream(); FileOutputStream fos = new FileOutputStream("F:\\server.jpg"); byte[] buf = new byte[1024]; int len = 0; while ((len = is.read(buf)) != -1) &#123; fos.write(buf, 0, len); &#125; OutputStream os = s.getOutputStream(); os.write("上传成功!".getBytes()); fos.close(); s.close(); ss.close(); &#125;&#125; 模拟并发上传图片在上一个例子中，客户端一次只能给服务器发送一次文件，服务器也之只能接收一次文件后就关闭了，如果给服务器的 接收文件的代码块 加上 while 循环，虽然能解决问题，但是出现的新问题就是当一个客户端未上传完数据时，其他客户端只能处于等待状态。 所以要用多线程处理，每有一个新的客户端发送请求，服务端就创建一个新线程来处理该客户端的上传任务。 假定客户端上传的都是 jpg 格式的图片，服务端接收文件后的命名规则是 客户端ip(n).jpg，n 代表客户端上传文件的次数。 客户端代码不变！！！ 多线程部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class UploadThread implements Runnable &#123; private Socket s; public UploadThread(Socket s) &#123; this.s = s; &#125; @Override public void run() &#123; String ip = s.getInetAddress().getHostAddress(); int count = 1; try &#123; System.out.println(ip + "..connected"); InputStream is = s.getInputStream(); File file = new File(ip + "(" + count++ + ").jpg"); while (file.exists()) file = new File(ip + "(" + count++ + ").jpg"); FileOutputStream fos = new FileOutputStream(file); byte[] buf = new byte[1024]; int len = 0; while ((len = is.read(buf)) != -1) &#123; fos.write(buf, 0, len); &#125; OutputStream os = s.getOutputStream(); os.write("上传成功!".getBytes()); System.out.println("成功接收一张图片，存储位置" + file.getAbsolutePath()); fos.close(); s.close(); &#125; catch (IOException e) &#123; new RuntimeException(ip + ":文件上传失败！"); &#125; &#125;&#125; 客户端：12345678910111213import java.net.ServerSocket;import java.net.Socket;public class UploadServer &#123; public static void main(String[] args) throws Exception &#123; System.out.println("服务器已开启！"); ServerSocket ss = new ServerSocket(10030); while (true) &#123; Socket s = ss.accept(); new Thread(new UploadThread(s)).start(); &#125; &#125;&#125; 这里的命名规则是为了防止覆盖原文件，也可以用时间戳或其他不会出现重复的形式。 URLURL 代表一个统一资源定位符，它是指向互联网“资源”的指针。 例如我们经常使用的百度：http://www.baidu.com 由于 URL 中包含了协议、主机地址、主机端口、请求路径、请求资源等信息。所以在 Java 中也是有相应的对象来表示的。 常用方法演示：1234567891011121314import java.net.MalformedURLException;import java.net.URL;public class URLDemo &#123; public static void main(String[] args) throws MalformedURLException &#123; URL url = new URL("https://www.baidu.com/search/error.html?name=zhangsan&amp;age=13"); System.out.println("getProtocol：" + url.getProtocol()); System.out.println("getHost：" + url.getHost()); System.out.println("getPort：" + url.getPort()); System.out.println("getPath：" + url.getPath()); System.out.println("getFile：" + url.getFile()); System.out.println("getQuery：" + url.getQuery()); &#125;&#125; 运行结果 getProtocol：https getHost：www.baidu.com getPort：-1 getPath：/search/error.html getFile：/search/error.html?name=zhangsan&amp;age=13 getQuery：name=zhangsan&amp;age=13 根据运行结果可以看到根据 URL 对象的方法可以很方便的获取到 URL 的各种信息，不用再手动的进行切割信息了。如 URL 中未指定端口，那么返回的是 -1 获取响应信息URL 对象的内部还对 Socket 对象进行封装，可以直接对某个 URL 地址发送请求，并获取服务器响应的信息。123456789101112131415161718192021222324252627282930313233import java.io.InputStream;import java.net.URL;import java.net.URLConnection;import java.text.SimpleDateFormat;import java.util.Date;public class URLDemo2 &#123; public static void main(String[] args) throws Exception &#123; URL url = new URL("https://www.baidu.com/search/error.html"); //连接指定 URL 地址 URLConnection conn = url.openConnection(); //获取响应头信息 System.out.println("getContentEncoding：" + conn.getContentEncoding()); System.out.println("getContentLength：" + conn.getContentLength()); System.out.println("getContentType：" + conn.getContentType()); System.out.println("getDate：" + new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"). format(new Date(conn.getDate()))); //获取响应的数据 InputStream is = conn.getInputStream(); byte[] buf = new byte[1024]; int len = 0; int size = 0; while ((len = is.read(buf)) != -1) &#123; size += len; System.out.println(new String(buf, 0, len,"utf-8")); &#125; is.close(); &#125;&#125; Java 对网络编程这一块，封装的还是很好用的，需要使用更多的方法，可以去 API 文档上查看。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础：IO流之合并流]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-IO%E6%B5%81%E4%B9%8B%E5%90%88%E5%B9%B6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[简介合并流就是 java.io.SequenceInputStream，它可以将多个输入流对象，当做一个流来处理。 方法摘要构造方法12SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) //将一个枚举对象中的所有输如流当做一个流SequenceInputStream(InputStream s1, InputStream s2) //将两个输入流当做一个流。 普通方法1234int available() //返回合并后的所有流的总可操作字节数void close() //关闭此输入流并释放与此流关联的所有系统资源int read() //从输入流中读取下一个数组字节int read(byte[] b, int off, int len) //将最多 len 个字节从此输入流读入 byte 数组 综合练习合并三个文本文件1234567891011121314151617181920212223242526272829import java.io.*;import java.util.*;public class SequenceInputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; Vector&lt;FileInputStream&gt; v = new Vector&lt;FileInputStream&gt;(); v.add(new FileInputStream("E:\\1.txt")); v.add(new FileInputStream("E:\\2.txt")); v.add(new FileInputStream("E:\\3.txt")); Enumeration&lt;FileInputStream&gt; en = v.elements(); SequenceInputStream sis = new SequenceInputStream(en); byte[] b = new byte[1024]; int size = 0; FileOutputStream fos = new FileOutputStream("E:\\4.txt"); while ((size = sis.read(b)) != -1) &#123; fos.write(b, 0, size); &#125; fos.close(); sis.close(); &#125;&#125; 将一个文件切割成多个文件这里演示的是将一个 MP3 文件切割成 n 个 1M 的碎片文件。 12345678910111213141516public static void splitFile() throws IOException&#123; FileInputStream fis = new FileInputStream("E:\\music.mp3"); FileOutputStream fos = null; byte[] b = new byte[1024 * 1024]; int size = 0; int count = 1; while ((size = fis.read(b)) != -1) &#123; fos = new FileOutputStream("E:\\split\\music" + count++ + ".part"); fos.write(b, 0, size); &#125; fis.close(); fos.close();&#125; 将切割的文件合并回源文件1234567891011121314151617181920212223public static void merge () throws IOException &#123; Vector&lt;FileInputStream&gt; v = new Vector&lt;FileInputStream&gt;(); //这里 i &lt; 12 是因为刚才我把一个文件切割成了 12 份 for (int i = 1; i &lt;= 12; i++) &#123; v.add(new FileInputStream("E:\\split\\music" + i + "part")); &#125; Enumeration&lt;FileInputStream&gt; en = v.elements(); SequenceInputStream sis = new SequenceInputStream(en); FileOutputStream fos = new FileOutputStream("E:\\split\\music.mp3"); byte[] b = new byte[1024]; int size = 0; while ((size = sis.read(b)) != -1) &#123; fos.write(b, 0, size); &#125; fos.close(); sis.close();&#125; 注意：切割文件那里定义临时的字节数组，不要过大，如你要将文件分割成 10M 的等份，可以创建一个 1M 的数组： byte[] b = new byte[1024 * 1024]; ，然后循环 10 次即可，因为创建过大的输入容易造成内存溢出。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：IO流之File]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-IO%E6%B5%81%E4%B9%8BFile%2F</url>
    <content type="text"><![CDATA[File对象简介File 对象是文件和目录路径名的抽象表示形式。 构造方法摘要123File(File parent, String child) //根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。 File(String pathname) //通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。 File(String parent, String child) //根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。 12345678910//File(File parent, String child) 演示File parent = new File("D:\\java");File file = new File(parent, "hello.java");//File(String pathname) //演示File file = new File("D:\\java\\hello.java");File dir = new File("D:\\java");//File(String parent, String child) 演示File file = new File("D:\\java", "hello.java"); 文件或者文件夹都可以被封装成文件对象。 方法摘要创建123boolean createNewFile() //在指定位置创建文件，如果文件已存在，则不创建，返回falseboolean mkdir() //创建文件夹，只能创建一层目录boolean mkdirs() //创建文件夹，可以创建多级目录 删除1234//如果此路径名表示一个目录，则该目录必须为空才能删除。 boolean delete() //删除失败返回false。如若文件正在被占用，则删除不了会返回 false,void deleteOnExit() //在虚拟机退出时删除文件。 判断12345boolean exists() //文件是否存在boolean isFile() //是否是一个文件boolean isDirectory //是否是一个文件夹boolean isHidden() //是否是一个隐藏文件boolean isAbsolute()//判断是否是一个绝对路径 注意：对文件对象进行判断操作时，除了 isAbsolute 方法，其他都需先判断文件是否存在，如文件不存在一律返回 false 。 获取信息1234567String getName() //获取文件名称String getPath() //获取文件的路径，创建对象是填的路径是什么就返回什么String getParent() //获取父路径 返回的是创建对象时填写路径的父路径String getAbsolutePath() //返回文件的绝对路径File getAbsoluteFile() //返回文件的绝对路径的对象表现形式long lastModified() //返回文件的最后修改时间，如文件不存在，则返回0long length() //返回文件的大小，单位：字节数，如是一个文件夹，则返回 0 对于 getParent 方法，如果创建对象时写的是 F:\\java\hello.java，则返回值为 &quot;java&quot;，如果创建对象时写的是相对路径 hello.java，则返回 null 其他操作12345678910boolean renameTo(File dest) //重名名一个文件或文件夹，也可以当做剪贴功能来看static File[] listRoots(); //列出可用的文件系统根。 在 Windows 环境下即为盘符String[] list() //返回一个字符串数组，数组中存放了指定目录下的所有子文件及文件夹， //包括隐藏文件，如果该目录不存在或者是一个文件，那么会返回 nullFile[] listFiles() //与上方的 list 方法功能类似，这里返回的是文件对象String[] list(FilenameFilter filter) //返回文件夹下过滤后的文件名称File[] listFiles(FilenameFilter filter) //返回文件夹下过滤后的文件对象File[] listFiles(FileFilter filter) //返回文件夹下过滤后的文件对象 方法演示FilenameFilter获取一个文件夹下所有的后缀名为 .java 的文件 12345678910111213141516171819202122import java.io.File;import java.io.FilenameFilter;class MyFilenameFilter implements FilenameFilter &#123; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(".java"); &#125;&#125;public class FilenameFilterDemo &#123; public static void main(String[] args) &#123; File file = new File("F:\\java"); String[] names = file.list(new MyFilenameFilter()); for (String name : names) &#123; System.out.println(name); &#125; &#125;&#125; FileFilter获取一个文件夹下所有的大小大于 1024 个字节的文件 1234567891011121314151617181920212223import java.io.File;import java.io.FileFilter;class MyFileFilter implements FileFilter &#123; @Override public boolean accept(File pathname) &#123; return pathname.length() &gt; 1024; &#125; &#125;public class FileFilterDemo &#123; public static void main(String[] args) &#123; File file = new File("F:\\java"); File[] files = file.listFiles(new MyFileFilter()); for (File f : files) &#123; System.out.println(f.getName()); &#125; &#125;&#125; 递归获取文件目录1234567891011121314151617181920212223242526272829303132import java.io.File;public class GetFilesDemo &#123; public static void main(String[] args) &#123; getFile(new File("E:\\hexo\\public"), 0); &#125; public static void getFile (File file, int i) &#123; if (!file.exists()) return; File[] files = file.listFiles(); String str = ""; for (int x = 0; x &lt; i; x++) &#123; str+="\t"; &#125; for (File f : files) &#123; if (f.isDirectory()) &#123; System.err.println(str + f.getName()); getFile(f, i+1); &#125; if (f.isFile()) &#123; System.out.println(str + f.getName()); &#125; &#125; &#125;&#125; 上述代码中为了以便区分，文件夹使用的是红色的错误输出颜色，文件使用的是普通颜色。 删除带有文件的文件夹1234567891011121314151617181920212223242526import java.io.File;public class DeleteFilesDemo &#123; public static void main(String[] args) &#123; deleteAll(new File("E:\\java")); &#125; public static void deleteAll (File file) &#123; if (!file.exists()) return; File[] files = file.listFiles(); for (File f : files) &#123; if (f.isDirectory()) &#123; deleteAll(f); &#125; if (f.isFile()) &#123; if (!f.delete()) System.out.println(f.getAbsolutePath() + "正在被占用，无法删除"); &#125; &#125; if (!file.delete()) System.out.println(file.getAbsolutePath() + "正在被占用，无法删除"); &#125;&#125; File 默认的 delete 方法无法删除非空的文件夹，所以这里要先将要被删除的文件夹以及其字文件夹和文件先删除，再删除其要删除的文件夹即可。但要注意的是，如果文件正在被占用的话，是无法删除的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：IO流之Properties]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-IO%E6%B5%81%E4%B9%8BProperties%2F</url>
    <content type="text"><![CDATA[Properties 简介Properties 是 Hashtable 的子类，具有 Map 集合的特点，存储的是键值对的数据，且都是 String 类型的。 其实此类严格意义上将不属于 IO 流部分因为它是 java.util 包中的而非 java.io 包，但是它却是集合与 IO 技术的集合容器。 常用方法存取和读取123456789101112131415161718public static void setAndGet() &#123; Properties prop = new Properties(); //存取一个配置 prop.setProperty("name", "Join"); prop.setProperty("age", "18"); //读取一个配置 String age = prop.getProperty("age"); System.out.println("age:" + age); Set&lt;String&gt; propSet = prop.stringPropertyNames(); for (String s : propSet) &#123; System.out.println(s + "=" + prop.getProperty(s)); &#125; &#125; 从文件中读取配置信息有文件 e:\info.ini ，文件内容是： name=Join age=16 Phone=13800000000 123456789101112131415public static void loadDemo() throws IOException &#123; FileInputStream fis = new FileInputStream("e:\\info.ini"); Properties prop = new Properties(); prop.load(fis); //读取配置中所有的键的 Set 集合表现形式 Set&lt;String&gt; propSet = prop.stringPropertyNames(); for (String s : propSet) &#123; System.out.println(s + ":" + prop.getProperty(s)); &#125; fis.close();&#125; 将配置信息写入到文件中1234567891011121314public static void storeDemo() throws IOException &#123; Properties prop = new Properties(); //存取一个配置 prop.setProperty("name", "Join"); prop.setProperty("age", "18"); FileOutputStream fos = new FileOutputStream("E:\\storeDemo.ini"); //第一个参数是输出流，第二个是注释信息。 prop.store(fos, "storeDemo"); fos.close();&#125; load 方法和 store 方法中可以写字符流 Reader 也可以写字节流 InputStream，传入字节流的方法是 JDK 1.6 才出现的。 综合练习用配置文件记录一个程序运行的次数，当运行次数达到 10 次，则提示用户”试用次数已到”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package io;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.util.Properties;public class PropertiesDemo &#123; public static void main(String[] args) throws IOException &#123; Properties prop = new Properties(); File file = new File("count.ini"); System.out.println(file.getAbsolutePath()); if (!file.exists()) &#123; file.createNewFile(); &#125; FileInputStream fis = new FileInputStream(file); int count = 0; prop.load(fis); String value = prop.getProperty("count"); if (value != null) &#123; count = Integer.parseInt(value); if (count &gt;= 10) &#123; System.out.println("试用次数已到！"); return; &#125; &#125; count++; prop.setProperty("count", count + ""); FileOutputStream fos = new FileOutputStream(file); prop.store(fos, ""); fos.close(); fis.close(); &#125;&#125; 思路很简单，只需要先判断文件存在不存在，不存在则创建，存在则读取信息，如果没有这个信息，则写入一个初始值为 1 的次数，有的话则取出值，并增加一次，再存储起来。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>Properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：IO流之字节流缓冲区]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-IO%E6%B5%81%E4%B9%8B%E5%AD%97%E8%8A%82%E6%B5%81%E7%BC%93%E5%86%B2%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[字节流缓冲区字节流的缓冲区与字符流的缓冲区也是大同小异的，本文不做重复叙述，如需了解，请查看 Java基础：IO流之字符流缓冲区。 综合练习使用字节流缓冲区拷贝图片1234567891011121314151617181920212223242526272829303132import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class BufferedCopyPictureFile &#123; public static void main(String[] args) &#123; BufferedInputStream bufis; BufferedOutputStream bufos; try &#123; bufis = new BufferedInputStream(new FileInputStream("F:\\demo.jpg")); bufos = new BufferedOutputStream(new FileOutputStream("F:\\demoCopy.jpg")); byte[] b = new byte[1024]; int len = 0; while ((len = bufis.read(b)) != -1) &#123; bufos.write(b, 0, len); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException("文件拷贝出错"); &#125; try &#123; if (bufos != null) bufos.close(); if (bufis != null) bufis.close(); &#125; catch (Exception e) &#123; throw new RuntimeException("文件拷贝出错"); &#125; &#125;&#125; 测试基本字节流与缓冲区的效率既然使用了字节流缓冲区，那么测试一下加缓冲区与不加缓冲区的区别，演示中复制的是同一个文件。 测试类123456public static void main(String[] args) throws IOException &#123; long startTime = System.currentTimeMillis(); //此处调用复制方法。 long endTime = System.currentTimeMillis(); System.out.println("耗时： " + (endTime - startTime) + " 毫秒。");&#125; 使用基本字节流一次读写一个字节 123456789101112public static void copy1() throws IOException &#123; FileInputStream fis = new FileInputStream("F:\\demo.jpg"); FileOutputStream fos = new FileOutputStream("F:\\demoCopy.jpg"); int len = 0; while ((len = fis.read()) != -1) &#123; fos.write(len); &#125; fos.close(); fis.close();&#125; 使用基本字节流一次读取一个字节数组12345678910111213public static void copy2() throws IOException &#123; FileInputStream fis = new FileInputStream("F:\\demo.jpg"); FileOutputStream fos = new FileOutputStream("F:\\demoCopy.jpg"); byte[] b = new byte[1024]; int len = 0; while ((len = fis.read(b)) != -1) &#123; fos.write(b, 0, len); &#125; fos.close(); fis.close();&#125; 加上缓冲区一次读取一个字节123456789101112public static void copy3() throws IOException&#123; BufferedInputStream bufis = new BufferedInputStream(new FileInputStream("F:\\demo.jpg")); BufferedOutputStream bufos = new BufferedOutputStream(new FileOutputStream("F:\\demoCopy.jpg")); int len = 0; while ((len = bufis.read()) != -1) &#123; bufos.write(len); &#125; bufos.close(); bufis.close();&#125; 加上缓冲区一次读取一个字节数组12345678910111213public static void copy4() throws IOException &#123; BufferedInputStream bufis = new BufferedInputStream(new FileInputStream("F:\\demo.jpg")); BufferedOutputStream bufos = new BufferedOutputStream(new FileOutputStream("F:\\demoCopy.jpg")); byte[] b = new byte[1024]; int len = 0; while ((len = bufis.read(b)) != -1) &#123; bufos.write(b, 0, len); &#125; bufos.close(); bufis.close();&#125; 测试文件大小为 11,720,762 字节。使用四种复制方法，耗时分别为：38944 毫秒、57毫秒、370毫秒、23毫秒。虽然测试会受测试环境等很多的因素，但是大致上的时间差距比还是很大的，所以还是可以反应问题的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：IO流之字节流]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-IO%E6%B5%81%E4%B9%8B%E5%AD%97%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[字节流Java 中的 IO 流按操作数据可以分为字节流与字符流，字节流主要用于对图片，视频等数据进行操作。而字符流是可以直接读写字符的 IO 流，对文本文件可以进行较为方便的操作。 字节输出流OutputStream 常用方法1234void close() //关闭此输出流并释放与此流有关的所有系统资源。 void flush() //刷新此输出流并强制写出所有缓冲的输出字节, OutputStream 的 flush 方法不执行任何操作。 void write(byte[] b) //将 b.length 个字节从指定的 byte 数组写入此输出流。 void write(byte[] b, int off, int len) //将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 使用字节流来写入数据到文本文件中字节流中的输出流的基类是 OutputStream，但是该方法是抽象的，只能使用创建其子类对象。 由于最常用的操作是文件，所以这里我们选择 FileOutputStream 来演示。 1234567891011121314151617181920212223242526import java.io.FileOutputStream;import java.io.IOException;public class FileOutputStreamDemo &#123; public static void main(String[] args) &#123; FileOutputStream fos = null; try &#123; fos = new FileOutputStream("F:\\demo.txt"); fos.write("ABCDEF".getBytes()); &#125; catch (IOException e) &#123; throw new RuntimeException("写入数据失败"); &#125; finally &#123; try &#123; if (fos != null) fos.close(); &#125; catch (Exception e) &#123; throw new RuntimeException("关闭流失败"); &#125; &#125; &#125;&#125; 这里与字符流操作文本数据的方式差不多，只不过这里是字节数组。字节流没有用到缓冲区时不需要 flush 操作，因为它会直接写入到文件中。 字节输入流InputStream 常用方法123456int available() //返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。 void close() //关闭此文件输入流并释放与此流有关的所有系统资源。 protected void finalize() //确保在不再引用文件输入流时调用其 close 方法。 int read() //从此输入流中读取一个数据字节。 int read(byte[] b) //从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 int read(byte[] b, int off, int len) // 从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。 使用字节流来读取文本内容字节流中的输出流的基类是 InputStream，但是该方法是抽象的，只能使用创建其子类对象。 由于最常用的操作是文件，所以这里我们选择 FileInputStream 来演示。 12345678910111213141516171819202122232425import java.io.FileInputStream;import java.io.IOException;public class FileInputStreamDemo &#123; public static void main(String[] args) &#123; FileInputStream fis = null; try &#123; fis = new FileInputStream("F:\\demo.txt"); byte[] b = new byte[fis.available()]; fis.read(b); System.out.println(new String(b)); &#125; catch (IOException e) &#123; throw new RuntimeException("文件读取失败"); &#125; finally &#123; try &#123; if (fis != null) fis.close(); &#125; catch (Exception e2) &#123; throw new RuntimeException("文件读取失败"); &#125; &#125; &#125;&#125; 上述代码中使用了 available ，这个方法其实就是返回要操作的文件中剩余的可被操作的字节数，这里虽然定义了一个 byte 类型的数组，使用了这个方法，创建了一个与文件字节大小一致的数组，但是当文件过大时，数组也会很大，会造成内存溢出，所以还是谨慎使用这种方法，推荐使用固定大小的数组，循环进行读取。 综合练习拷贝图片字节流不仅限于操作文本文件，也是可以操作媒体文件的，用字节流读取文件字节后，写入到一个新的文件中即可。 1234567891011121314151617181920212223242526272829303132333435import java.io.FileInputStream;import java.io.FileOutputStream;public class CopyPictureFile &#123; public static void main(String[] args) &#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream("F:\\demo.jpg"); fos = new FileOutputStream("F:\\demoCopy.jpg"); byte[] b = new byte[1024]; int len = 0; while ((len = fis.read(b)) != -1) &#123; fos.write(b, 0, len); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException("文件拷贝出错"); &#125; finally &#123; try &#123; if (fis != null) &#123; fis.close(); &#125; if (fos != null) &#123; fos.close(); &#125; &#125; catch (Exception e2) &#123; throw new RuntimeException("文件拷贝出错"); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：IO流之字符流缓冲区]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-IO%E6%B5%81%E4%B9%8B%E5%AD%97%E7%AC%A6%E6%B5%81%E7%BC%93%E5%86%B2%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[字符流缓冲区字符流的缓冲区：BufferedWriter 和 BufferedReader 缓冲区的出现时为了提高流的操作效率而出现的. 需要被提高效率的流作为参数传递给缓冲区的构造函数 缓冲区的原理就是在缓冲区中封装了一个数组，存入数据后一次取出 BufferedWriter构造方法摘要12BufferedWriter(Writer out) //创建一个使用默认大小输出缓冲区的缓冲字符输出流。 BufferedWriter(Writer out, int sz) // 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。 常用方法123456void close() //关闭此流，但要先刷新它。 void flush() //刷新该流的缓冲。 void newLine() //写入一个行分隔符。 void write(char[] cbuf, int off, int len) //写入字符数组的某一部分。 void write(int c) //写入单个字符。 void write(String s, int off, int len) //写入字符串的某一部分。 使用演示123456789101112131415161718import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class BufferedWriterDemo &#123; public static void main(String[] args) throws IOException &#123; FileWriter fw = new FileWriter("F:\\demo.txt"); BufferedWriter buffWriter = new BufferedWriter(fw); for (int i = 1; i &lt; 5; i++) &#123; buffWriter.write("java" + i); buffWriter.newLine(); buffWriter.flush(); &#125; buffWriter.close(); &#125;&#125; BufferedWriter 中的 newLine 方法可以实现跨平台的换行符BufferedWriter 中的 close 方法也会将缓冲区中的流对象关闭 BufferedReader构造方法摘要12BufferedReader(Reader in) //创建一个使用默认大小输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz) //创建一个使用指定大小输入缓冲区的缓冲字符输入流。 常用方法1234void close() //关闭该流并释放与之关联的所有资源。 int read() //读取单个字符。 int read(char[] cbuf, int off, int len) //将字符读入数组的某一部分。 String readLine() //读取一个文本行。 使用演示123456789101112131415161718import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class BufferedReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader("F:\\demo.txt"); BufferedReader buffReader = new BufferedReader(fr); String line = null; while ((line = buffReader.readLine()) != null) &#123; System.out.println(line); &#125; buffReader.close(); &#125;&#125; BufferedReader 的 readLine 方法会读取一整行文本，如果已到达流末尾，则返回 null BufferedReader 的 close 方法也会将缓冲区中的流对象关闭 综合练习通过缓冲区拷贝文本文件1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class BufferedCopyDemo &#123; public static void main(String[] args) &#123; BufferedReader buffReader = null; BufferedWriter buffWriter = null; try &#123; buffReader = new BufferedReader(new FileReader("F:\\demo.txt")); buffWriter = new BufferedWriter(new FileWriter("F:\\demoCopy.txt")); String line = null; while ((line = buffReader.readLine()) != null) &#123; buffWriter.write(line); buffWriter.newLine(); buffWriter.flush(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException("文件拷贝失败"); &#125; finally &#123; try &#123; if (buffReader != null) buffReader.close(); if (buffWriter != null) buffWriter.close(); &#125; catch (IOException e) &#123; throw new RuntimeException("文件拷贝失败"); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：IO流之字符流]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-IO%E6%B5%81%E4%B9%8B%E5%AD%97%E7%AC%A6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[字节流Java 中的 IO 流按操作数据可以分为字节流与字符流，字节流主要用于对图片，视频等数据进行操作。而字符流是可以直接读写字符的 IO 流，对文本文件可以进行较为方便的操作。 字节输出流字符流中的输出流的基类是 Writer，但是该方法是抽象的，只能使用创建其子类对象。 由于最常用的操作是文件，所以这里我们选择 FileWrite 来演示。 写入字符到指定文本文件中12345678910111213141516171819202122232425import java.io.*;public class FileWriteDemo &#123; public static void main(String[] args) throws IOException &#123; //这里会抛出异常，因为创建文件输出流对象时，可能指定了一个不存在的路径，那么就无法继续操作了，这里我们直接将异常抛出。 //如若该文件不存在，则会创建，已存在则会将其覆盖。 FileWriter fw = new FileWriter("F:\\demo.txt"); //调用 write 方法，会将数据存入到流中，而不是直接写入到文件。 fw.write("abc"); //刷新流对象中的缓冲中的数据，将数据存入到文件中。 fw.flush(); //再次写入数据到流中 fw.write("xyz"); //关闭输出流，关闭前会将缓冲中的数据写入到文件中，也就是再 flush 一次 fw.close(); //注意：当调用 close 方法关闭流之后，将无法再向流中写入数据。 fw.write("qwer"); &#125;&#125; 要点：new FileWrite(&quot;F:\\demo.txt&quot;); 会将文件覆盖，如想对文件进行追加操作，则使用另一个构造方法 new FileWrite(&quot;F:\\demo.txt&quot;, true) 即可将数据写入文件末尾处，而不是写入文件开始处。 write 方法是将数据写入到流中，而不是文件中。flush 方法会将流中的数据写入到文件close 方法会将流中的数据写入到文件中，然后会关闭流，不可在对流进行操作。Windows 环境下写入回车符的方法：fw.write(&quot;\r\n&quot;); 字符流异常的处理方式在上述的例子中，我们直接将 IO 异常抛出了，这里我们演示下如何正确处理 IO 异常。 12345678910111213141516171819202122232425262728import java.io.*;public class FileWriteDemo &#123; public static void main(String[] args) &#123; FileWriter fw = null; try &#123; //如果文件已存在，则在文件最后进行追加，不存在，则创建文件 fw = new FileWriter("F:\\demo.txt", true); fw.write("abc"); fw.flush(); fw.write("xyz"); &#125; catch (IOException e) &#123; throw new RuntimeException("读写失败"); &#125; finally &#123; try &#123; if (fw != null) fw.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125;&#125; 这里要注意的是：在 finally 中对流资源进行关闭时，要注意关闭动作本身也会抛出异常，要记得处理。 字节输入流字符流中的输出流的基类是 Reader，但是该方法是抽象的，只能使用创建其子类对象。 由于最常用的操作是文件，所以这里我们选择 FileReader 来演示。 从一个文件中读取文本内容1234567891011121314151617181920212223242526import java.io.FileReader;import java.io.IOException;public class FileReadDemo2 &#123; public static void main(String[] args) throws IOException &#123; //创建一个文件输入流，同样这里也会抛出异常，为了代码简洁这里就直接抛出了 //有关异常的处理请参照上方的输出流中的异常处理方式。 FileReader fr = new FileReader("F:\\demo.txt"); //读取一个字符，返回值是字符对于的 ASCII 编码中的数值。所以查看时要将其转为 char 类型。 int ch1 = fr.read(); System.out.println((char)ch1); char[] ch = new char[1024]; int num = 0; //将读取到的内容存储到字符数组中，返回值是读取的有效字符的个数。 //当读取到文件末尾，会返回 -1 while ((num = fr.read(ch)) != -1) &#123; //为了避免资源的浪费，所以只取有效数据，num 即为有效数据的个数。 System.out.print(new String(ch, 0, num)); &#125; &#125;&#125; 要点：fr.read() 返回的是一个字符在 ASCII 编码中的数值fr.read(char[] ch) 返回的是存入指定数组中有效数据的个数 综合练习拷贝文本文件拷贝文本文件其实就是将一个文件读取后，在将其内容写入到另一个文件中。所以将上方我们的示例综合起来即可。 123456789101112131415161718192021222324252627282930313233343536import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class CopyTextFile &#123; public static void main(String[] args) &#123; FileReader fr = null; FileWriter fw = null; try &#123; fr = new FileReader("F:\\demo.txt"); fw = new FileWriter("F:\\demoCopy.txt"); char[] ch = new char[1024]; int num = 0; while ((num = fr.read(ch)) != -1) &#123; fw.write(ch, 0, num); fw.flush(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException("拷贝失败"); &#125; finally &#123; try &#123; if (fw != null) fw.close(); if (fr != null) fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：静态导入]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[JDK 1.5 版本有一个新特性：静态导入。 该特性的作用是将某个类中的所有静态成员导入进来。 例如我们经常用的工具类 Collections、Arrays 等包含很多静态方法的类，调用时有些麻烦，这时就可以用新特性：静态导入。 使用演示12345678910111213import static java.util.Arrays.*;import java.util.Arrays;public class demo &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,5,8,54,6,8,5&#125;; System.out.println("排序前：" + Arrays.toString(arr)); sort(arr); System.out.println("排序后：" + Arrays.toString(arr)); &#125;&#125; 运行结果： 排序前：[1, 2, 3, 5, 8, 54, 6, 8, 5] 排序后：[1, 2, 3, 5, 5, 6, 8, 8, 54] 在该演示中，可以看到 sort 方法直接写就可以了，不用再写成 Arrays.sort() 了。但是看到 Arrays.toString() 方法却加上了类名，因为 demo 类本身也有一个继承自 Object 的 toString 的同名方法，Arrays 中也有 toString 方法，这时就要用 类名.方法 来区分了。 静态导入的优缺点：优点：减少了代码的输入，提高效率缺点：过度的使用静态导入，在一定程度上会影响代码的可读性。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>静态导入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：可变参数]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[JDK 1.5 版本出现一个新特性：可变参数。 该特性可以解决某个方法参数数量不确定，但参数类型确定的情况 例如：当需要定义一个方法，该方法的功能是计算传入 int 类型的 n 个参数的和，由于计算的数量不确定，所以不便使用方法重载的方式，因为过于麻烦。 传统做法，利用数组：123456789101112131415public class demo &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,5,6,8,7,5,1,5,69,81,8165,7&#125;; int sum = sum(arr); System.out.println(sum); &#125; public static int sum(int[] num) &#123; int sum = 0; for (int i : num) &#123; sum += i; &#125; return sum; &#125;&#125; 这种方式虽然可以完成需求，但是还要预先将数据存储到数组中。 新做法，可变参数：1234567891011121314public class demo &#123; public static void main(String[] args) &#123; int sum = sum(1,5,6,8,7,5,1,5,69,81,8165,7); System.out.println(sum); &#125; public static int sum(int... num) &#123; int sum = 0; for (int i : num) &#123; sum += i; &#125; return sum; &#125;&#125; 使用这种方式呢，其实就是 Java 内部帮我们将 n 个参数封装成数组了。 但是可变参数有一个注意事项就是，只能放到参数的最后一个，不然无法确认参数的对应性。例如 public static int sum(int... num, int x)，这样的话就无法确认哪一个是 x 了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>可变参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：泛型]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型简介泛型规范在 JDK 1.5 版本中被添加，使用泛型机制编写的代码比起随意使用 Object 变量然后再进行强制类型转换的代码具有更高的安全性和可读性，同时也更为简洁。 泛型的好处 泛型将将运行时期的问题ClassCastException转到了编译时期。 避免了强制转换的麻烦。 泛型技术是给编译器使用的技术,用于编译时期。确保了类型的安全。 什么时候使用泛型当操作的引用数据类型不确定的时候，就使用泛型，将要操作的引用数据类型传入即可。其实&lt;&gt;就是一个用于接收具体引用数据类型的参数范围。 泛型演示泛型在 ArrayList 与 Iterator 中的使用。123456789101112131415161718import java.util.ArrayList;import java.util.Iterator;public class GenrticDemo &#123; public static void main(String[] args)&#123; //明确传入的具体引用数据类型 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add("haha"); arrayList.add("xixi"); arrayList.add("hello"); ////明确传入的具体引用数据类型 Iterator&lt;String&gt; it = arrayList.iterator(); while (it.hasNext()) &#123; String str = it.next(); System.out.println(str); &#125; &#125;&#125; 自定义泛型泛型类12345678910public class Utils&lt;T&gt; &#123; public void print (T t) &#123; System.out.println(t); &#125; public void show (T t) &#123; System.out.println(t); &#125;&#125; 如此即可定义一个泛型类，这样 Utils 的所有方法就可以操作创建 Utils 类时指定的数据类型了。 泛型方法1234567891011public class Utils &#123; public&lt;T&gt; void print (T t) &#123; System.out.println(t); &#125; public&lt;T&gt; void show (T t) &#123; System.out.println(t); &#125; &#125; 泛型类有一个弊端，就是当该类中有不同的方法，来接收不同的参数时，就不行了，因为它之接收创建类时指定的数据类型 所以就有了泛型方法，这样方法 print 与 show 方法就可以分别接收不同类型的数据类型了，而不必受类的泛型的限制 泛型类与泛型方法混合使用12345678910public class Utils&lt;T&gt; &#123; public void print (T t) &#123; System.out.println(t); &#125; public&lt;E&gt; void show (E e) &#123; System.out.println(e); &#125;&#125; 这样就是混合使用了， print 会使用类的泛型 T ，而 show 方法则会使用自身的泛型 E，两者互不冲突。 泛型静态方法12345678910public class Utils&lt;T&gt; &#123; public void print (T t) &#123; System.out.println(t); &#125; public static&lt;E&gt; void show (E e) &#123; System.out.println(e); &#125;&#125; 由于静态的特性，所以静态方法不可以访问类上定义的泛型，如果静态方法操作的数据类型不确定，那么就将泛型定义上方法上。 泛型接口12345678910111213141516interface Inter&lt;T&gt; &#123; void show(T t);&#125;class InterImpl implements Inter&lt;String&gt; &#123; public void show (String str) &#123; System.out.println(str); &#125;&#125;public class GenericDemo &#123; public static void main(String[] args) &#123; InterImpl inter = new InterImpl(); inter.show("haha"); &#125;&#125; 当接口的实现类也不确定要使用的数据类型时，也可以让接口用泛型： 12345678910111213141516171819interface Inter&lt;T&gt; &#123; void show(T t);&#125;class InterImpl&lt;T&gt; implements Inter&lt;T&gt; &#123; public void show (T t) &#123; System.out.println(t); &#125;&#125;public class GenericDemo &#123; public static void main(String[] args) &#123; InterImpl&lt;String&gt; inter = new InterImpl&lt;String&gt;(); inter.show("haha"); InterImpl&lt;Integer&gt; inter2 = new InterImpl&lt;Integer&gt;(); inter2.show(5); &#125;&#125; 泛型限定占位符1234567public static void printColl(ArrayList&lt;?&gt; al) &#123; Iterator&lt;?&gt; it = al.iterator(); while (it.hashNext()) &#123; Systen.out.println(it.next()); &#125;&#125; 上方代码展示了一个占位符的应用场景，占位符有一个缺陷就是无法操作这个元素，例如使用 时还可以 T t = it.next() ，而使用了占位符 ? 的话就不能 ? t = it.next() 了 上下限1234567public static void printColl(ArrayList&lt;? extends Person&gt; al) &#123; Iterator&lt;?&gt; it = al.iterator(); while (it.hashNext()) &#123; Systen.out.println(it.next()); &#125;&#125; 这是一个上限的例子，表示 ？ 只能接收 Person 与 Person 的子类 下限则是指其父类，格式是：&lt;? super Person&gt;。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：StringBuffer 与 StringBuilder]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-StringBuffer%20%E4%B8%8E%20StringBuilder%2F</url>
    <content type="text"><![CDATA[两者的特点和区别StringBuffer 和 StringBuilder 都是字符串缓冲区。 共同点： 都是是一个容器。 长度是可变化的。 可以操作多个数据类型。 最终会通过 toString() 方法变成字符串。 不同点： JDK1.5 版本之后出现了 StringBuilder. StringBuffer 是线程同步。 StringBuilder 是线程不同步。 常用操作存储StringBuffer append(基本数据类型); //将指定数据作为参数添加到已有数据结尾处.。 StringBuffer insert(int index,基本数据类型); //可以将数据插入到指定index位置。 删除StringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。 StringBuffer deleteCharAt(index):删除指定位置的字符。 获取char charAt(int index); int indexOf(String str); int lastIndexOf(String str); int length(); String substring(int start, int end); 修改StringBuffer replace(int start,int end,String str); void setCharAt(int index, char ch); 反转StringBuffer reverse(); 其他//将缓冲区中指定数据存储到指定字符数组中。 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) StringBuffer sb = new StringBuffer("abcedf"); char[] chs = new char[4]; sb.getChars(1,4,chs,1); //然后chs的内容就为: [][b][c][d];]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：字符串]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[概述 字符串是一个特殊的对象 字符串一旦初始化就不可以被改变 字符串的创建方式String str1 = "abc"; String str2 = new String("abc"); str1 和 str2 有什么区别？ s1 在内存中有一个对象 s2 在内存中有两个对象 System.out.println(str1 == str2); //false 比较地址是否相同 System.out.println(str1.equals(str2)); //true 比较字符串的内容是否相同。 字符串常见操作获取 获取长度 int length(); //返回字符串的长度。 根据位置获取某个字符 char charAt(int index); //根据数组元素的角标值来获取某个元素。 根据字符获取位置 //这里的 int ch 指的是字符在 ASCII 码中的对应数字。 //返回的是 ch 在字符串中第一次出现的位置 int indexOf(int ch); //返回的是 ch 在字符串中第一次出现的位置 int indexOf(int ch, int fromIndex); //返回的是字符串 str 在字符串中第一次出现的位置 int indexOf(String str)： //从 fromIndex 这个位置开始，获取字符串 str 在字符串中出现的位置 int indexOf(String str, int fromIndex); //这里跟上面的 indexOf() 类似，只不过是倒序查找，也有四种重载的方法。 int lastIndexOf(int ch); ... ... ... 判断 判断字符串中是否包含某一个子串 //其实与获取中的 indexOf(String str) 方法效果也是相同的，返回值为 -1 时即包含不存在。 boolean contains(String str); 判断字符串是否为空 //其实就是判断字符串长度是否等于 0 boolean isEmpty(); 判断字符串是否以指定内容开头 boolean startsWith(String str); 判断字符串是否以指定内容结尾 boolean endsWith(String str); 转换 将字符数组转成字符串 构造函数：String(char[]) String(char[],offset,count); //从 offset开始，一共 count 个 静态方法： static String copyValueOf(char[] data); static String copyValueOf(char[] data, int offset, int count); static String valueOf(char[] data); 将字符串转成字符数组 char[] toCharArray(); 将字节数组转成字符串 String(byte[]); String(byte[],offset,count); //将字节数组中的一部分转成字符串。 将字符串转成字节数组 byte[] getBytes(); 将基本数据类型转成字符串 static String valueOf(int); static String valueOf(double); ... ... ... 替换//将字符串中所有的 oldchar 替换为 newchar，如果要替换的字符不存在，那么返回的还是原字符串 String replace(char oldchar,char newchar); //可以根据正则表达式进行替换 String replaceAll(String regex, String replacement); 切割String[] split(String regex); //将字符串根据某种规则进行切割。 String str = "zhangsan,lisi,wangwu"; String[] arr = str.split(","); 然后字符串数组 arr 中的结果就是三个字符串 zhagnsan lisi wangwu 子串String substring(int begin); //从指定位置开始到结尾 //包含头，不包含尾 对字符串 "abcdefg" substring(2,4) 的结果是 "cd" String substring(int begin, int end); 其他操作String toUpperCase(); //转换为大写 String toLowerCase(); //转换为小写 String trim(); //去除两端空格。 //按照自然顺序进行比较，到第一个不相同的字符上，进行 ASCII 比较，返回相差数。 int compareTo(String str);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：内部类]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类的定义内部类是指将一个类定义在另一个类的里面，对里面那个类就称为内部类 内部类的访问特点 内部类可以直接访问外部类中的成员，包括私有成员。 而外部类要访问内部类中的成员必须要建立内部类的对象 普通内部类123456789101112public class Outer &#123; int x = 6; public class Inner &#123; int x = 5; public void method()&#123; int x = 3; System.out.println(x); &#125; &#125;&#125; 当内部类定义在外部类的成员位置上，并且为非私有，在其他外部类中想创建 Outer 的内部类 Inner 的对象时，则需 外部类名.内部类： Outer.Inner inner = new Outer().new Inner(); 不能直接 Inner inner = new Inner(); 因为可能其他的类中也有名为 Inner 的内部类，所以需要标明是哪个类的内部类才行。 Inner 的 method() 的打印语句，默认输出的是方法体内的局部变量，也就是3，访问 Inner 类中的成员变量可以写 this.x，访问 Outer 类中的成员变量可以写 Outer.this.x 内部类定义在局部时： 不可以被成员修饰符修饰 可以直接访问外部类中的成员，因为还持有外部类中的引用。 但是不可以访问它所在的局部中的变量。只能访问被final修饰的局部变量。12345678910111213141516171819class Outer&#123; int x = 3; void method(final int a) &#123; final int y = 4; class Inner &#123; void function() &#123; System.out.println(y); &#125; &#125; new Inner().function(); &#125;&#125; 静态内部类当内部类在成员位置上，就可以被成员修饰符所修饰。 比如： private：将内部类在外部类中进行封装，禁止其他类访问。 static：内部类就具备了静态的特性。 123456789101112public class Outer &#123; int x = 6; public static class Inner &#123; int x = 5; public void method()&#123; int x = 3; System.out.println(x); &#125; &#125;&#125; 当内部类被 static 修饰后，只能直接访问外部类中的 &gt; static ，出现了访问局限。 在外部其他类中，如何直接访问 static 内部类的非静态成员呢？new Outer.Inner().method(); 在外部其他类中，如何直接访问 static 内部类的静态成员呢？Outer.Inner.method(); 当内部类中定义了静态成员，该内部类必须也是静态的。 当外部类中的静态方法访问内部类时，内部类也必须是静态的。 匿名内部类匿名内部类其实就是内部类的简写格式。123456789101112abstract class AbsDemo &#123; abstract void show();&#125;class Outer &#123; new AbsDemo()&#123; public void show()&#123; System.out.println("show..") &#125; &#125;&#125; 定义匿名内部类的前提：内部类必须继承一个类或实现一个接口 匿名内部类中定义的方法最好不要超过3个，不然会影响阅读。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：单例设计模式]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[饿汉式1234567public class Single &#123; private static Single s = new Single(); private Single() &#123;&#125; public static Single getInstance () &#123; return s; &#125;&#125; 特点：Single 类一进内存，就已经创建好了对象。 存在的问题： 如果构造方法中存在过多的处理，会导致加载这个类时比较慢，可能引起性能问题。 如果使用饿汉式的话，只进行了类的装载，并没有实质的调用，会造成资源的浪费 懒汉式12345678910public class Single &#123; private static Single s = null; private Single() &#123;&#125; public static Single getInstance () &#123; if (s == null) &#123; s == new Single(); &#125; return s; &#125;&#125; 特点：Single 类进内存，对象还没有存在，只有调用了 getInstance() 方法时，才建立对象。 存在的问题： 在多线程的情况下可能会出现安全问题：上述代码在多个线程并发调用 getInstance() 时，可能会创建出多个实例。比如 A 线程进行判断 s == null 这段代码后，还未创建实例之前，B线程也进入了 s == null 此代码块，那么就会造成创建了两个不同的实例的结果，违背了单例设计模式。 解决方案 一只需要在 getInstance() 方法上加上 synchronized 修饰符，即可加锁，当一个线程进入此代码块后，其他线程无法进入。 12345678910public class Single &#123; private static Single s = null; private Single() &#123;&#125; public static synchronized Single getInstance () &#123; if (s == null) &#123; s == new Single(); &#125; return s; &#125;&#125; 但是这种解决办法，每个线程调用这个方法时，都要判断一下锁，效率会很低。 解决方案 二为了解决方案一的效率低下的问题，可以用双重判断的形式来实现：1234567891011121314public class Single &#123; private static Single s = null; private Single() &#123;&#125; public static Single getInstance () &#123; if (s == null) &#123; synchronized (Single.class) &#123; if (s == null) &#123; s == new Single(); &#125; &#125; &#125; return s; &#125;&#125; 使用双重判断加锁，首先进入该方法时进行null == sInstance检查，如果第一次检查通过，即没有实例创建，则进入synchronized控制的同步块,并再次检查实例是否创建，如果仍未创建，则创建该实例。 双重检查加锁保证了多线程下只创建一个实例，并且加锁代码块只在实例创建的之前进行同步。如果实例已经创建后，进入该方法，则不会执行到同步块的代码。 单例设计模式真的只有一个对象么其实，单例模式并不能保证实例的唯一性，只要我们想办法的话，还是可以打破这种唯一性的。以下几种方法都能实现。 使用反射，虽然构造器为非公开，但是在反射面前就不起作用了。 如果单例的类实现了 cloneable，那么还是可以拷贝出多个实例的。 Java 中的对象序列化也有可能导致创建多个实例。避免使用 readObject 方法。 使用多个类加载器加载单例类，也会导致创建多个实例并存的问题。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：接口的特性]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[声明接口其实就是一个完全抽象类，不提供任何具体实现，使用 Interface 关键字修饰。 特性 接口中的方法可以有参数列表和返回类型，但不能有任何方法体。 接口中的成员修饰符是固定的，即使不写也会自动加上。 成员常量：public static final 成员方法：public abstract 接口的实现类必须实现接口中的所有方法。 一个类可以实现多个接口，同理，该类也要实现多个接口中的所有方法，如果多个接口中有重名方法，那么实现一个即可 ( 但是同名方法的返回值必须相同 )。 接口与接口之间可以有继承关系，且一个接口可以继承多个其他接口 ( Java 从这种方面看来是可以多继承的 )。例如有一个 A 接口，一个 B 接口。那么 C 接口可以同时继承 A 和 B 接口，但是 C 接口的实现类，就必须将 A、B、C 三个接口的所有方法都实现。 Java 中接口的特性有些复杂，要特别注意。例如 Java 中的接口可以多继承其他接口这一特性，容易被考到。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：构造代码块]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[作用给所有的对象进行统一的初始化。 实例12345678910111213141516171819202122232425262728package demo;public class Person &#123; private String name; private int age; &#123; System.out.println("构造代码块"); &#125; public Person() &#123; System.out.println("空构造函数"); &#125; public Person(String name, int age) &#123; System.out.println("有参构造函数，name:" + name + ",age:" + age ); &#125; public static void main(String[] args) &#123; Person person = new Person(); Person person1 = new Person("张三",18); &#125; &#125; 运行结果： 构造代码块 空构造函数 构造代码块 有参构造函数，name:张三,age:18 特性对象一创建构造代码块就会运行，是先于构造函数运行的。构造代码块的主要作用是对所有构造方法中的公共的内容进行抽取。 构造函数与构造代码块的区别构造代码块是给所有对象进行统一初始化而构造函数则是给对应的对象进行初始化的，例如带一个参数的构造方法，无参构造方法等。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>构造代码块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础：位运算]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80-%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[位运算位运算是直接对二进制进行运算。 位运算符 运算符 运算 范例 &lt;&lt; 左移 4&lt;&lt;3 = 4*2^3 = 32 &gt;&gt; 右移 16&gt;&gt;3=16/2^3=2 &gt;&gt;&gt; 无符号右移 16&gt;&gt;&gt;3=16/2^3=2 &amp; 与运算 6 &amp; 3 = 2 丨 或运算 6丨3=7 ^ 异或运算 6^3=5 ~ 反码 ~6 = -7 详解基础概念在 Java 中，一个 int 类型 占用 4 个字节，每个字节 8 位，所以一个 int 占用 32 位存储空间。 左移左移是指将16的32位二进制表示，向左移 2 位，即舍弃前面 2 位，后面空缺的 2 位，补0 右移右移是指将16的32位二进制表示，向右移 2 位，即舍弃最后 2 位，最高位空缺的 2 位，根据原有数据最高位的值而定。一般整数为0，负数为1 图略. 无符号右移基础运算跟右移一样，不过最高位空缺的两位，无条件全部补0. 图略. 与运算是指将其运算数的二进制每一位都进行与运算，二进制中 0&amp;0=0,0&amp;1=0,1&amp;1=1。 或运算是指将其运算数的二进制每一位都进行或运算，二进制中 0|0=0,0|1=1,1|1=1。 异或运算是指将其运算数的二进制每一位都进行异或运算，如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。二进制中 0^0=0,0^1=1,1^1=0。 异或可以用作加密用途，一个数异或同一个数2次，结果还是那个数，如：7 ^ 4 ^ 4 = 7 反码正数的补码就是该数取反后+1，如 ~6=-7 ~5=-6]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个字符串是变位词]]></title>
    <url>%2Ftwo-strings-are-anagrams%2F</url>
    <content type="text"><![CDATA[描述写出一个函数 anagram(s, t) 判断两个字符串是否可以通过改变字母的顺序变成一样的字符串。 样例给出 s = &quot;abcd&quot;，t=&quot;dcab&quot;，返回 true.给出 s = &quot;ab&quot;, t = &quot;ab&quot;, 返回 true.给出 s = &quot;ab&quot;, t = “ac&quot;, 返回 false. 解法1234567891011121314151617181920public class Solution &#123; /** * @param s: The first string * @param b: The second string * @return true or false */ public boolean anagram(String s, String t) &#123; //转为字符数组以便使用Arrays.sort方法 char[] arr1 = s.toCharArray(); char[] arr2 = t.toCharArray(); //对转换后的字符数组进行按a-z的顺序进行排序 Arrays.sort(arr1); Arrays.sort(arr2); //排序完成后，再转回字符串，然后用equals方法进行比较是否为变位词 if(String.copyValueOf(arr1).equals(String.copyValueOf(arr2))) return true; else return false; &#125;&#125;; 本题目来自LintCode : 两个字符串是变位词]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交换两个数]]></title>
    <url>%2Fswap-two-number%2F</url>
    <content type="text"><![CDATA[用临时变量交换2个数示例代码：12345678910int a = 20;int b = 15;System.out.println("a="+a+",b="+b); //交换前2个数的值int temp = a;a = b;b = temp;System.out.println("a="+a+",b="+b); //交换后2个数的值 这种方式也是我们经常用到的，比较容易理解的一种方法。 不用临时变量交换2个数 方式一示例代码：12345678910int a = 20;int b = 15;System.out.println("a="+a+",b="+b); //交换前2个数的值a = a + b;b = a - b;a = a - b;System.out.println("a="+a+",b="+b); //交换后2个数的值 使用这种方式要注意：如果a和b的值非常大，容易超出int的取值范围。 方式二示例代码：12345678910int a = 20;int b = 15;System.out.println("a="+a+",b="+b); //交换前2个数的值a = a ^ b;b = a ^ b;a = a ^ b;System.out.println("a="+a+",b="+b); //交换后2个数的值 本方法使用了位运算的相关知识。没有上面的方法易于理解，但是可能会被考到。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建 --- 3、Hexo发布文章详解]]></title>
    <url>%2Fhexo-install-03%2F</url>
    <content type="text"><![CDATA[简单发布文章 在Hexo根目录下打开cmd终端命令：1hexo new &quot;文件名&quot; 此命令会在/hexo/source/_posts下创建一个文件名.md文件，然后就可以使用markdown编辑器开始写自己的博客了。 打开生成的默认文章模板。 123456---title: new #博客标题date: 2017-2-19 21:20:57 #创建时间tags: #标签--- 这里写正文（上面的---是必要的） 本地查看预览效果 1hexo s 浏览器打开 http://localhost:4000/ 即可查看效果，默认端口为4000自定义端口为80： hexo s p 80 部署到Coding上1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d hexo clean 清理本地缓存hexo g 全称： generate，生成静态html文件。hexo d 全称：deploy 部署到Coding上。注：部署到Coding上需要先按照插件，在cmd中输入 npm install hexo-deployer-git --save 高级文章设置Hexo new 的分类Hexo对生成文章有三种分类： post：也是默认的方式，一般指一篇博客。 page：指生成一个页面，一般用来做标签和关于页 draft：指草稿，我个人很少用。 生成方式是：hexo new [layout] &lt;title&gt;比如： hexo new page tags ，即为生成一个名为tags的页面。 文档模板修改当我们使用 hexo new [layout] &lt;title&gt; 生成文章的生成的文件都是有默认模板的。比如hexo new post 模板测试 12345---title: 模板测试date: 2017-2-19 21:53:03 tags: --- 比如我的博客每次都要加 markdown源码下载。那么对每个文件都要加上相应的代码，那么不如修改一下模板文件，让new文章的时候就能加上相应的代码，岂不省事。 实现修改模板功能其实每次我们执行 hexo new [layout] &lt;title&gt; 时，Hexo都会去scaffolds文件夹中寻找[layout].md，并根据其内容建立文章。那么我们直接修改对应的 .md 模板文件即可，或者自己添加一个 demo.md 文件，创建文件的时候执行hexo new demo &lt;title&gt; 即可。 Front-matter详解Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：1234---title: 模板测试date: 2017-2-19 22:04:39tags: 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 注意： 如一个文章有多个tags的话，语法为：1234567---title: 标题date: 2017-2-19 22:12:29tags:- 标签1- 标签2--- Hexo官方说明不支持一个文章与多个categories(分类) Hexo官方文档对于分类的解释 如何关闭新建页面的评论功能？当集成了评论系统，如 多说 或者 Disqus，所有新建的页面都将自动开启评论。若你不需要评论，请在页面的 Front-matter 里添加 comments 字段，并将值设置为 false。如下所示：12345---title: new titledate: 2017-2-21 21:34:29comments: false--- 如何设置页面文章的篇数？ 使用 npm install --save 命令来安装需要的 Hexo 插件。 等待扩展全部安装完成后，在 站点配置文章 中，设定如下选项：12345678910index_generator: per_page: 5 ##首页显示的文章篇数archive_generator: per_page: 20 ##归档页显示的文章篇数 yearly: true monthly: true tag_generator: per_page: 10 内置标签标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。 文本居中使用方式：123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt; &lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt; &lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125; &lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 效果示例： 引用块在文章中插入引言，可包含作者、来源和标题。123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; 简单点说两种用法： 引用名人名言123&#123;% blockquote 鲁迅, 《记念刘和珍君》%&#125;真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血&#123;% endblockquote %&#125; 引用别人网站的文章或其他123&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;NEW: DevDocs now comes with syntax highlighting. http://devdocs.io&#123;% endblockquote %&#125; 突破容器宽度限制的图片当使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上提升图片的吸引力。 此标签有两种调用方式（详细参看底下示例）：使用方式：123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;full-image&quot; 是必须的 --&gt;&lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt; &lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% fullimage /image-url, alt, title %&#125;&lt;!-- 别名 --&gt;&#123;% fi /image-url, alt, title %&#125; 效果示例：]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建 --- 2、Hexo主题安装与配置]]></title>
    <url>%2Fhexo-install-02%2F</url>
    <content type="text"><![CDATA[简介本次演示，使用Hexo最受欢迎的主题，也是本站使用的主题Next。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 本文中站点配置文件的路径分别指的是： 站点配置文件：/root/blog/_config.yml 主题配置文件：/root/blog/themes/next/_config.yml 下载主题在Hexo根目录下打开cmd，输入以下代码1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题打开 站点配置文件 找到theme字段，将其值修改为next。1theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题首先启动 Hexo 本地站点，命令是 hexo s 当命令行输出中提示出：INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse 现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 主题设定选择 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。 设置 语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：1language: zh-Hans 语言 代码 设置示例 English en language: en 简体中文 zh-Hans language: zh-Hans 繁体中文 zh-hk language: zh-hk 设置 菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑 主题配置文件 ，修改以下内容： 设定菜单内容对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。12345678910menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html ##比如添加一个菜单项，跳转到百度。 baidu: http://www.baidu.com 设置菜单项的显示文本在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项： 1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 ##为我们刚才设置的百度链接设置中文字体显示 baidu: 百度 设置菜单项的图标可以看到默认的3个菜单前都有小图标 下面我们为刚才设置的百度添加图标。找到 menu_icons 字段。格式是 item name : icon name,其中item name就是刚才我们设置的名字baidu,而icon name是Font Awesome图标的名称。 123456789101112menu_icons: enable: true ##控制是否显示图标，默认为true。 # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat ##为 baidu 设置图标 ， 如未配置，则会使用 ？ 作为图标。 baidu: bookmark 设置作者昵称编辑 站点配置文件， 设置 author 为你的昵称。 设置站点描述编辑 站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名 创建”关于我”页面新建一个 about 页面：1hexo new page &quot;about&quot; 让菜单显示 “关于我” 链接，在主题配置文件 设置中将 menu 中 about 前面的注释去掉即可12345menu: home: / archives: /archives tags: /tags about: /about 创建”分类”页面新建一个页面，命名为 categories 。命令如下： 1hexo new page categories 编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。 123456---title: categoriesdate: 2017-2-20 22:23:04type: &quot;categories&quot;comments: false #禁止评论，可自行选择--- 在菜单中添加链接。编辑主题配置文件 ，将 menu 中的 categories: /categories 注释去掉，如下:12345menu: home: / categories: /categories archives: /archives tags: /tags 创建”标签”页面新建一个页面，命名为 tags 。命令如下：1hexo new page &quot;tags&quot; 编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。1234title: tagsdate: 2017-2-20 22:26:56type: &quot;tags&quot;comments: false #禁止评论，可自行选择 在菜单中添加链接。编辑主题配置文件 ，添加 tags 到 menu 中，如下:1234menu: home: / archives: /archives tags: /tags 设置侧边栏头像编辑站点配置文件，新增字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 完整的互联网 URL，例如：https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460站点内的地址，例如： /uploads/avatar.jpg 需要将你的头像图片放置在 站点的 source/uploads/（可能需要新建uploads目录） /images/avatar.jpg 需要将你的头像图片放置在 主题的 source/images/ 目录下。 设置侧边栏社交链接编辑站点配置文件，新增字段 social，然后添加社交站点名称与地址即可。例如：12345678# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name Weibo: http://weibo.com/your-user-name douban: http://douban.com/people/your-user-name zhihu: http://www.zhihu.com/people/your-user-name # 等等 编辑主题配置文件, 在social_icons字段下添加社交站点名称（注意大小写）与图标，例如：12345678social_icons: enable: true # Icon Mappings. # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter Weibo: weibo Linkedin: linkedin 图标名称可以参考：http://fontawesome.io/cheatsheet/ 设置多说评论 使用多说前需要先在 多说 创建一个站点。具体步骤如下： 登录后在首页选择 “我要安装”。 创建站点，填写站点相关信息。注意，多说域名 这一栏填写的即是你的 duoshuo_shortname。 编辑站点配置文件 添加 duoshuo_shortname 字段（先搜索，如果有就不用），设置如下1duoshuo_shortname: your-duoshuo-shortname 添加搜索功能 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能，这个字段 local_search 下的 enable 改为 true： 1234567local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 开启打赏功能只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能。123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image Next主题常见问题如何设置阅读全文大家发布文章后可能会发现，文章直接在主页显示完了，没有阅读全文按钮来的舒服。官方也给提供了3中解决方案。 在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式。 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在 ·主题配置文件· 中添加：123auto_excerpt: enable: true length: 150 #默认截取的长度为 150 字符，可以根据需要自行设定 建议使用 （即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。 如何更改内容区域的宽度？NexT 对于内容的宽度的设定如下： 700px，当屏幕宽度 &lt; 1600px 900px，当屏幕宽度 &gt;= 1600px 移动设备下，宽度自适应 如果你需要修改内容的宽度，同样需要编辑样式文件。 编辑主题的 source/css/_variables/custom.styl 文件，新增变量：12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 此方法不适用于 Pisces Scheme，关于如何修改 Pisces Scheme 的宽度请参看 这个 Issue 如何设置页面文章的篇数？在 Hexo 里可以为首页和归档页面设置不同的文章篇数，但可能需要安装 Hexo 插件。详细步骤如下。 1.使用 npm install –save 命令来安装需要的 Hexo 插件。123npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tag 2.等待扩展全部安装完成后，在 站点配置文件 中，设定如下选项：12345678910index_generator: per_page: 5archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 10 需要注意的是，Hexo 3.2 版本不允许配置文件中存在重复的选项设置。 因此，最好检查下 站点配置文件 中是否有存在上述同名的配置。 如果存在，请将两者配置在一起。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建 --- 1、搭建 Hexo 博客并部署到 Coding]]></title>
    <url>%2Fhexo-install-01%2F</url>
    <content type="text"><![CDATA[前言我一直想搭建一个个人博客，要求就是简洁，支持Markdown，可以显示文章的TOC目录。寻找的过程中也遇到了很多坑，教程基本上都不完整，或者是直接copy别人的，而且很多教程中是将其部署到github pages上 ，但是介于网速问题，还是选择了国内的Coding。下面先将我的经历给大家分享下。 JPress ：国产，开源，基于JFinal开发的，主题生态系统正在快速完善中，但是markdown支持不好，所以就放弃了。 Ghost : 也很简洁，基于Node.js开发，有后台管理页。与markdown支持不错，但是本人英语不好，Ghost国内站也不再继续更新，虽然基本可以满足我的需求，但是迫于强迫症还是放弃了。 Hexo ： 很简洁，可以直接生成纯html界面，优点是支持它的环境十分好找，可以直接用github、coding、七牛云存储等静态页面托管，可以省下VPS服务器的费用。 需求条件 Windows电脑一台 (没用过Mac，所以无法做Mac的教程) 熟悉Markdown语法 (现学也可以，入门教程 ) 耐心 (有耐心按照教程一步一步执行下，不能嫌麻烦就半途而废) 安装Git下载地址：传送门这一步最好选择第二项，其他的默认就好 安装完后打开 cmd 输入 git --version 来测试是否安装成功。 安装Node.js下载地址：传送门下载安装即可，没有特殊配置，无限下一步。安装完后打开 cmd 输入 node -v 来测试是否安装成功。 安装Hexo首先在你电脑上找一个位置来安装Hexo。然后在那个文件夹中打开cmd (shift + 右键) 下载12npm config set registry http://registry.cnpmjs.org #修改安装源为中国镜像。npm install hexo-cli -g 初始化Hexo123hexo initnpm installnpm install hexo-util --save 测试Hexo1hexo s 然后在浏览器的地址栏上面输入localhost:4000就可看到自己博客的样子。Ctrl + C 可以终止预览 配置CodingCdoing官网：https://coding.net/注册后创建一个新项目 项目名称，项目描述随意填写，项目选择私有项目。然后点击创建。 然后在电脑桌面右键，打开Git Bash Here 然后配置SSH： 配置shh key是让本地git项目与远程的coding建立联系 检查是否已经有SSH Key，打开Git Bash Here，输入 1cd ~/.ssh 如果没有.ssh这个目录，则我们生成一个SSH，输入 1ssh-keygen -t rsa -C "你的邮箱" 接下来几步中系统会要你输入密码 12Enter passphrase (empty for no passphrase):&lt;输入密码&gt;Enter same passphrase again:&lt;再次输入密码&gt; 这个密码是在你提交项目给服务器的时候使用的，可以为空，如果为空的话提交项目时则不用输入密码就能提交。 最好看到类似这样的界面，就成功设置ssh key了 然后查看公钥 1cat ~/.ssh/id_rsa.pub 然后将这些内容全部复制下来。 回到Coding 添加你的公钥 然后直接把刚才复制的内容粘贴进去,点击添加即可。 设置自己的身份，这里设置自己的名字和邮箱 12git config --global user.name "Your Name"git config --global user.email "email@example.com" 在Git Bash Here 中输入 1ssh -T git@git.coding.net 如果显示以下则说明coding中的ssh配置成功Hello username You&#39;ve connected to Coding.net by SSH successfully! 开启Coding Pages服务进入你刚才创建的项目。 先在根目录下找到_config.yml文件，并进入编辑。我们找到deploy这一项，修改看下面： 123456789# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: #我们是使用 git 来部署的。 type: git # git 仓库的地址。 repo: https://git.coding.net/xxx/xxxx.git # 分支名称。 branch: master 仓库的地址可以在coding网站上找到，复制过来即可 测试Coding配置 新建一篇文章，并且部署到Coding上面。在Hexo安装路径下打开cmd1hexo new 第一篇文章 然后在给出的路径里打开.md文件，用markdown语法写作即可 在部署之前还有一步，就是要安装一个插件，不然无法部署上去。 1npm install hexo-deployer-git --save 发布部署文章 1hexo g -d 然后在去Coding上就可以看到部署的文件了 至此，搭建完成。有关Hexo的详细配置，请参阅Hexo官方文档。 如本文中有错误，欢迎在评论中进行指正。转账请注明出处，谢谢支持。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
